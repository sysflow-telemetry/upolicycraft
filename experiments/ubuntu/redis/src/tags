!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A0	rand.c	57;"	d	file:
A1	rand.c	58;"	d	file:
A2	rand.c	59;"	d	file:
ACLAddAllowedSubcommand	acl.c	/^void ACLAddAllowedSubcommand(user *u, unsigned long id, const char *sub) {$/;"	f
ACLAppendUserForLoading	acl.c	/^int ACLAppendUserForLoading(sds *argv, int argc, int *argc_err) {$/;"	f
ACLAuthenticateUser	acl.c	/^int ACLAuthenticateUser(client *c, robj *username, robj *password) {$/;"	f
ACLCategoryItem	acl.c	/^struct ACLCategoryItem {$/;"	s	file:
ACLCheckAllPerm	acl.c	/^int ACLCheckAllPerm(client *c, int *idxptr) {$/;"	f
ACLCheckCommandPerm	acl.c	/^int ACLCheckCommandPerm(client *c, int *keyidxptr) {$/;"	f
ACLCheckPasswordHash	acl.c	/^int ACLCheckPasswordHash(unsigned char *hash, int hashlen) {$/;"	f
ACLCheckPubsubChannelPerm	acl.c	/^int ACLCheckPubsubChannelPerm(sds channel, list *allowed, int literal) {$/;"	f
ACLCheckPubsubPerm	acl.c	/^int ACLCheckPubsubPerm(client *c, int idx, int count, int literal, int *idxptr) {$/;"	f
ACLCheckUserCredentials	acl.c	/^int ACLCheckUserCredentials(robj *username, robj *password) {$/;"	f
ACLClearCommandID	acl.c	/^void ACLClearCommandID(void) {$/;"	f
ACLCommandCategories	acl.c	/^} ACLCommandCategories[] = {$/;"	v	typeref:struct:ACLCategoryItem
ACLCopyUser	acl.c	/^void ACLCopyUser(user *dst, user *src) {$/;"	f
ACLCountCategoryBitsForUser	acl.c	/^int ACLCountCategoryBitsForUser(user *u, unsigned long *on, unsigned long *off,$/;"	f
ACLCreateUnlinkedUser	acl.c	/^user *ACLCreateUnlinkedUser(void) {$/;"	f
ACLCreateUser	acl.c	/^user *ACLCreateUser(const char *name, size_t namelen) {$/;"	f
ACLDescribeUser	acl.c	/^sds ACLDescribeUser(user *u) {$/;"	f
ACLDescribeUserCommandRules	acl.c	/^sds ACLDescribeUserCommandRules(user *u) {$/;"	f
ACLFreeLogEntry	acl.c	/^void ACLFreeLogEntry(void *leptr) {$/;"	f
ACLFreeUser	acl.c	/^void ACLFreeUser(user *u) {$/;"	f
ACLFreeUserAndKillClients	acl.c	/^void ACLFreeUserAndKillClients(user *u) {$/;"	f
ACLFreeUsersSet	acl.c	/^void ACLFreeUsersSet(rax *users) {$/;"	f
ACLGetCommandBitCoordinates	acl.c	/^int ACLGetCommandBitCoordinates(uint64_t id, uint64_t *word, uint64_t *bit) {$/;"	f
ACLGetCommandCategoryFlagByName	acl.c	/^uint64_t ACLGetCommandCategoryFlagByName(const char *name) {$/;"	f
ACLGetCommandID	acl.c	/^unsigned long ACLGetCommandID(const char *cmdname) {$/;"	f
ACLGetUserByName	acl.c	/^user *ACLGetUserByName(const char *name, size_t namelen) {$/;"	f
ACLGetUserCommandBit	acl.c	/^int ACLGetUserCommandBit(user *u, unsigned long id) {$/;"	f
ACLHashPassword	acl.c	/^sds ACLHashPassword(unsigned char *cleartext, size_t len) {$/;"	f
ACLInit	acl.c	/^void ACLInit(void) {$/;"	f
ACLInitDefaultUser	acl.c	/^void ACLInitDefaultUser(void) {$/;"	f
ACLKillPubsubClientsIfNeeded	acl.c	/^void ACLKillPubsubClientsIfNeeded(user *u, list *upcoming) {$/;"	f
ACLListDupSds	acl.c	/^void *ACLListDupSds(void *item) {$/;"	f
ACLListFreeSds	acl.c	/^void ACLListFreeSds(void *item) {$/;"	f
ACLListMatchSds	acl.c	/^int ACLListMatchSds(void *a, void *b) {$/;"	f
ACLLoadConfiguredUsers	acl.c	/^int ACLLoadConfiguredUsers(void) {$/;"	f
ACLLoadFromFile	acl.c	/^sds ACLLoadFromFile(const char *filename) {$/;"	f
ACLLoadUsersAtStartup	acl.c	/^void ACLLoadUsersAtStartup(void) {$/;"	f
ACLLog	acl.c	/^list *ACLLog;       \/* Our security log, the user is able to inspect that$/;"	v
ACLLogEntry	acl.c	/^typedef struct ACLLogEntry {$/;"	s	file:
ACLLogEntry	acl.c	/^} ACLLogEntry;$/;"	t	typeref:struct:ACLLogEntry	file:
ACLLogMatchEntry	acl.c	/^int ACLLogMatchEntry(ACLLogEntry *a, ACLLogEntry *b) {$/;"	f
ACLLookupCommand	acl.c	/^struct redisCommand *ACLLookupCommand(const char *name) {$/;"	f
ACLResetSubcommands	acl.c	/^void ACLResetSubcommands(user *u) {$/;"	f
ACLResetSubcommandsForCommand	acl.c	/^void ACLResetSubcommandsForCommand(user *u, unsigned long id) {$/;"	f
ACLSaveToFile	acl.c	/^int ACLSaveToFile(const char *filename) {$/;"	f
ACLSetUser	acl.c	/^int ACLSetUser(user *u, const char *op, ssize_t oplen) {$/;"	f
ACLSetUserCommandBit	acl.c	/^void ACLSetUserCommandBit(user *u, unsigned long id, int value) {$/;"	f
ACLSetUserCommandBitsForCategory	acl.c	/^int ACLSetUserCommandBitsForCategory(user *u, const char *category, int value) {$/;"	f
ACLSetUserStringError	acl.c	/^const char *ACLSetUserStringError(void) {$/;"	f
ACLStringHasSpaces	acl.c	/^int ACLStringHasSpaces(const char *s, size_t len) {$/;"	f
ACLUpdateDefaultUserPassword	acl.c	/^void ACLUpdateDefaultUserPassword(sds password) {$/;"	f
ACLUserCanExecuteFutureCommands	acl.c	/^int ACLUserCanExecuteFutureCommands(user *u) {$/;"	f
ACLUserFlag	acl.c	/^struct ACLUserFlag {$/;"	s	file:
ACLUserFlags	acl.c	/^} ACLUserFlags[] = {$/;"	v	typeref:struct:ACLUserFlag
ACL_DENIED_AUTH	server.h	2108;"	d
ACL_DENIED_CHANNEL	server.h	2109;"	d
ACL_DENIED_CMD	server.h	2106;"	d
ACL_DENIED_KEY	server.h	2107;"	d
ACL_LOG_CTX_LUA	acl.c	1753;"	d	file:
ACL_LOG_CTX_MULTI	acl.c	1754;"	d	file:
ACL_LOG_CTX_TOPLEVEL	acl.c	1752;"	d	file:
ACL_LOG_GROUPING_MAX_TIME_DELTA	acl.c	1755;"	d	file:
ACL_OK	server.h	2105;"	d
ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE	expire.c	123;"	d	file:
ACTIVE_EXPIRE_CYCLE_FAST	server.h	123;"	d
ACTIVE_EXPIRE_CYCLE_FAST_DURATION	expire.c	121;"	d	file:
ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP	expire.c	120;"	d	file:
ACTIVE_EXPIRE_CYCLE_SLOW	server.h	122;"	d
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC	expire.c	122;"	d	file:
ADDEQU	rand.c	53;"	d	file:
AE_ALL_EVENTS	ae.h	52;"	d
AE_BARRIER	ae.h	44;"	d
AE_CALL_AFTER_SLEEP	ae.h	55;"	d
AE_CALL_BEFORE_SLEEP	ae.h	54;"	d
AE_DELETED_EVENT_ID	ae.h	58;"	d
AE_DONT_WAIT	ae.h	53;"	d
AE_ERR	ae.h	39;"	d
AE_FILE_EVENTS	ae.h	50;"	d
AE_NOMORE	ae.h	57;"	d
AE_NONE	ae.h	41;"	d
AE_NOTUSED	ae.h	61;"	d
AE_OK	ae.h	38;"	d
AE_READABLE	ae.h	42;"	d
AE_TIME_EVENTS	ae.h	51;"	d
AE_WRITABLE	ae.h	43;"	d
AF_LOCAL	anet.h	45;"	d
ALLOC	Makefile	/^	echo MALLOC=$(MALLOC) >> .make-settings$/;"	m
ALLOW_EMPTY_STRING	config.c	1854;"	d	file:
AL_START_HEAD	adlist.h	93;"	d
AL_START_HEAD	quicklist.h	206;"	d
AL_START_TAIL	adlist.h	94;"	d
AL_START_TAIL	quicklist.h	207;"	d
ANET_CONNECT_BE_BINDING	anet.c	279;"	d	file:
ANET_CONNECT_NONBLOCK	anet.c	278;"	d	file:
ANET_CONNECT_NONE	anet.c	277;"	d	file:
ANET_ERR	anet.h	37;"	d
ANET_ERR_LEN	anet.h	38;"	d
ANET_H	anet.h	32;"	d
ANET_IP_ONLY	anet.h	42;"	d
ANET_NONE	anet.h	41;"	d
ANET_OK	anet.h	36;"	d
ANNOTATE_HAPPENS_AFTER	atomicvar.h	81;"	d
ANNOTATE_HAPPENS_BEFORE	atomicvar.h	80;"	d
AOF_FSYNC_ALWAYS	server.h	385;"	d
AOF_FSYNC_EVERYSEC	server.h	386;"	d
AOF_FSYNC_NO	server.h	384;"	d
AOF_OFF	server.h	221;"	d
AOF_ON	server.h	222;"	d
AOF_READ_DIFF_INTERVAL_BYTES	server.h	104;"	d
AOF_REWRITE_ITEMS_PER_CMD	server.h	103;"	d
AOF_RW_BUF_BLOCK_SIZE	aof.c	60;"	d	file:
AOF_WAIT_REWRITE	server.h	223;"	d
AOF_WRITE_LOG_ERROR_RATE	aof.c	357;"	d	file:
ARN	Makefile	/^	echo WARN=$(WARN) >> .make-settings$/;"	m
ASSERT_INTEGRITY	listpack.c	124;"	d	file:
ASSERT_INTEGRITY_LEN	listpack.c	130;"	d	file:
ASSERT_NO_SIZE_OVERFLOW	zmalloc.c	53;"	d	file:
ASSERT_NO_SIZE_OVERFLOW	zmalloc.c	60;"	d	file:
AVOID_ERRNO	lzfP.h	104;"	d
AddReplyFromClient	networking.c	/^void AddReplyFromClient(client *dst, client *src) {$/;"	f
AuthAsyncCommand_RedisCommand	modules/helloacl.c	/^int AuthAsyncCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
AuthGlobalCommand_RedisCommand	modules/helloacl.c	/^int AuthGlobalCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
AutoMemEntry	module.c	/^struct AutoMemEntry {$/;"	s	file:
BFOVERFLOW_FAIL	bitops.c	286;"	d	file:
BFOVERFLOW_SAT	bitops.c	285;"	d	file:
BFOVERFLOW_WRAP	bitops.c	284;"	d	file:
BIG_ENDIAN	config.h	151;"	d
BIG_ENDIAN	config.h	185;"	d
BINCOLOR	Makefile	/^BINCOLOR="\\033[37;1m"$/;"	m
BIO_AOF_FSYNC	bio.h	47;"	d
BIO_CLOSE_FILE	bio.h	46;"	d
BIO_LAZY_FREE	bio.h	48;"	d
BIO_NUM_OPS	bio.h	49;"	d
BITFIELDOP_GET	bitops.c	402;"	d	file:
BITFIELDOP_INCRBY	bitops.c	404;"	d	file:
BITFIELDOP_SET	bitops.c	403;"	d	file:
BITFIELD_FLAG_NONE	bitops.c	919;"	d	file:
BITFIELD_FLAG_READONLY	bitops.c	920;"	d	file:
BITOP_AND	bitops.c	397;"	d	file:
BITOP_NOT	bitops.c	400;"	d	file:
BITOP_OR	bitops.c	398;"	d	file:
BITOP_XOR	bitops.c	399;"	d	file:
BLOCKED_LIST	server.h	287;"	d
BLOCKED_MODULE	server.h	289;"	d
BLOCKED_NONE	server.h	286;"	d
BLOCKED_NUM	server.h	293;"	d
BLOCKED_PAUSE	server.h	292;"	d
BLOCKED_STREAM	server.h	290;"	d
BLOCKED_WAIT	server.h	288;"	d
BLOCKED_ZSET	server.h	291;"	d
BUFSIZE	sha1.c	201;"	d	file:
BUILD_WITH_SYSTEMD	Makefile	/^	BUILD_WITH_SYSTEMD=yes$/;"	m
BUILD_WITH_SYSTEMD	Makefile	/^BUILD_WITH_SYSTEMD=no$/;"	m
BYTE	sha256.h	/^typedef uint8_t BYTE;   \/\/ 8-bit byte$/;"	t
BYTE_ORDER	config.h	158;"	d
BYTE_ORDER	config.h	168;"	d
BYTE_ORDER	config.h	188;"	d
BYTE_ORDER	config.h	190;"	d
BenchmarkDictType	dict.c	/^dictType BenchmarkDictType = {$/;"	v
C	rand.c	60;"	d	file:
C11_ATOMIC	Makefile	/^C11_ATOMIC := $(shell sh -c 'echo "\\#include <stdatomic.h>" > foo.c; \\$/;"	m
CARRY	rand.c	52;"	d	file:
CCCOLOR	Makefile	/^CCCOLOR="\\033[34m"$/;"	m
CC_FORCE	redis-cli.c	154;"	d	file:
CC_QUIET	redis-cli.c	155;"	d	file:
CH	sha256.c	24;"	d	file:
CHECK_INPUT	lzfP.h	125;"	d
CHILD_COW_DUTY_CYCLE	server.h	136;"	d
CHILD_INFO_TYPE_AOF_COW_SIZE	server.h	/^    CHILD_INFO_TYPE_AOF_COW_SIZE,$/;"	e	enum:childInfoType
CHILD_INFO_TYPE_CURRENT_INFO	server.h	/^    CHILD_INFO_TYPE_CURRENT_INFO,$/;"	e	enum:childInfoType
CHILD_INFO_TYPE_MODULE_COW_SIZE	server.h	/^    CHILD_INFO_TYPE_MODULE_COW_SIZE$/;"	e	enum:childInfoType
CHILD_INFO_TYPE_RDB_COW_SIZE	server.h	/^    CHILD_INFO_TYPE_RDB_COW_SIZE,$/;"	e	enum:childInfoType
CHILD_TYPE_AOF	server.h	1154;"	d
CHILD_TYPE_LDB	server.h	1155;"	d
CHILD_TYPE_MODULE	server.h	1156;"	d
CHILD_TYPE_NONE	server.h	1152;"	d
CHILD_TYPE_RDB	server.h	1153;"	d
CIRCULAR_TYPE	geohash.h	93;"	d
CLIENTS_CRON_MIN_ITERATIONS	server.c	1790;"	d	file:
CLIENTS_PEAK_MEM_USAGE_SLOTS	server.c	1723;"	d	file:
CLIENT_ASKING	server.h	236;"	d
CLIENT_BLOCKED	server.h	230;"	d
CLIENT_CLOSE_AFTER_COMMAND	server.h	275;"	d
CLIENT_CLOSE_AFTER_REPLY	server.h	232;"	d
CLIENT_CLOSE_ASAP	server.h	237;"	d
CLIENT_DENY_BLOCKING	server.h	277;"	d
CLIENT_DIRTY_CAS	server.h	231;"	d
CLIENT_DIRTY_EXEC	server.h	239;"	d
CLIENT_FORCE_AOF	server.h	241;"	d
CLIENT_FORCE_REPL	server.h	242;"	d
CLIENT_GET_EVENTLOOP	redis-benchmark.c	74;"	d	file:
CLIENT_ID_AOF	server.h	855;"	d
CLIENT_IN_TO_TABLE	server.h	273;"	d
CLIENT_LUA	server.h	235;"	d
CLIENT_LUA_DEBUG	server.h	254;"	d
CLIENT_LUA_DEBUG_SYNC	server.h	255;"	d
CLIENT_MASTER	server.h	227;"	d
CLIENT_MASTER_FORCE_REPLY	server.h	240;"	d
CLIENT_MODULE	server.h	256;"	d
CLIENT_MONITOR	server.h	228;"	d
CLIENT_MULTI	server.h	229;"	d
CLIENT_PAUSE_ALL	server.h	/^    CLIENT_PAUSE_ALL      \/* Pause all commands *\/$/;"	e	enum:__anon44
CLIENT_PAUSE_OFF	server.h	/^    CLIENT_PAUSE_OFF = 0, \/* Pause no commands *\/$/;"	e	enum:__anon44
CLIENT_PAUSE_WRITE	server.h	/^    CLIENT_PAUSE_WRITE,   \/* Pause write commands *\/$/;"	e	enum:__anon44
CLIENT_PENDING_COMMAND	server.h	261;"	d
CLIENT_PENDING_READ	server.h	258;"	d
CLIENT_PENDING_WRITE	server.h	249;"	d
CLIENT_PREVENT_AOF_PROP	server.h	246;"	d
CLIENT_PREVENT_LOGGING	server.h	282;"	d
CLIENT_PREVENT_PROP	server.h	248;"	d
CLIENT_PREVENT_REPL_PROP	server.h	247;"	d
CLIENT_PRE_PSYNC	server.h	243;"	d
CLIENT_PROTECTED	server.h	257;"	d
CLIENT_PROTOCOL_ERROR	server.h	274;"	d
CLIENT_PUBSUB	server.h	245;"	d
CLIENT_READONLY	server.h	244;"	d
CLIENT_REPLY_OFF	server.h	251;"	d
CLIENT_REPLY_SKIP	server.h	253;"	d
CLIENT_REPLY_SKIP_NEXT	server.h	252;"	d
CLIENT_REPL_RDBONLY	server.h	280;"	d
CLIENT_SLAVE	server.h	226;"	d
CLIENT_ST_KEYLEN	timeout.c	93;"	d	file:
CLIENT_TRACKING	server.h	263;"	d
CLIENT_TRACKING_BCAST	server.h	266;"	d
CLIENT_TRACKING_BROKEN_REDIR	server.h	265;"	d
CLIENT_TRACKING_CACHING	server.h	269;"	d
CLIENT_TRACKING_NOLOOP	server.h	271;"	d
CLIENT_TRACKING_OPTIN	server.h	267;"	d
CLIENT_TRACKING_OPTOUT	server.h	268;"	d
CLIENT_TYPE_COUNT	server.h	305;"	d
CLIENT_TYPE_MASTER	server.h	304;"	d
CLIENT_TYPE_NORMAL	server.h	301;"	d
CLIENT_TYPE_OBUF_COUNT	server.h	306;"	d
CLIENT_TYPE_PUBSUB	server.h	303;"	d
CLIENT_TYPE_SLAVE	server.h	302;"	d
CLIENT_UNBLOCKED	server.h	233;"	d
CLIENT_UNIX_SOCKET	server.h	238;"	d
CLI_HELP_COMMAND	redis-cli.c	490;"	d	file:
CLI_HELP_GROUP	redis-cli.c	491;"	d	file:
CLUSTERMSG_FLAG0_FORCEACK	cluster.h	287;"	d
CLUSTERMSG_FLAG0_PAUSED	cluster.h	286;"	d
CLUSTERMSG_MIN_LEN	cluster.h	282;"	d
CLUSTERMSG_TYPE_COUNT	cluster.h	100;"	d
CLUSTERMSG_TYPE_FAIL	cluster.h	93;"	d
CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK	cluster.h	96;"	d
CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST	cluster.h	95;"	d
CLUSTERMSG_TYPE_MEET	cluster.h	92;"	d
CLUSTERMSG_TYPE_MFSTART	cluster.h	98;"	d
CLUSTERMSG_TYPE_MODULE	cluster.h	99;"	d
CLUSTERMSG_TYPE_PING	cluster.h	90;"	d
CLUSTERMSG_TYPE_PONG	cluster.h	91;"	d
CLUSTERMSG_TYPE_PUBLISH	cluster.h	94;"	d
CLUSTERMSG_TYPE_UPDATE	cluster.h	97;"	d
CLUSTER_BLACKLIST_TTL	cluster.c	1205;"	d	file:
CLUSTER_BROADCAST_ALL	cluster.c	2677;"	d	file:
CLUSTER_BROADCAST_LOCAL_SLAVES	cluster.c	2678;"	d	file:
CLUSTER_CANT_FAILOVER_DATA_AGE	cluster.h	71;"	d
CLUSTER_CANT_FAILOVER_EXPIRED	cluster.h	73;"	d
CLUSTER_CANT_FAILOVER_NONE	cluster.h	70;"	d
CLUSTER_CANT_FAILOVER_RELOG_PERIOD	cluster.h	75;"	d
CLUSTER_CANT_FAILOVER_WAITING_DELAY	cluster.h	72;"	d
CLUSTER_CANT_FAILOVER_WAITING_VOTES	cluster.h	74;"	d
CLUSTER_FAIL	cluster.h	10;"	d
CLUSTER_FAILOVER_DELAY	cluster.h	19;"	d
CLUSTER_FAIL_REPORT_VALIDITY_MULT	cluster.h	16;"	d
CLUSTER_FAIL_UNDO_TIME_ADD	cluster.h	18;"	d
CLUSTER_FAIL_UNDO_TIME_MULT	cluster.h	17;"	d
CLUSTER_JOIN_CHECK_AFTER	redis-cli.c	145;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS	redis-cli.c	123;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS	redis-cli.c	129;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_COLOR	redis-cli.c	128;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_COPY	redis-cli.c	127;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER	redis-cli.c	124;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_FIX	redis-cli.c	120;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS	redis-cli.c	130;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_MASTERS_ONLY	redis-cli.c	131;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_REPLACE	redis-cli.c	126;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_SIMULATE	redis-cli.c	125;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_SLAVE	redis-cli.c	121;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_SLAVES_ONLY	redis-cli.c	132;"	d	file:
CLUSTER_MANAGER_CMD_FLAG_YES	redis-cli.c	122;"	d	file:
CLUSTER_MANAGER_COMMAND	redis-cli.c	92;"	d	file:
CLUSTER_MANAGER_FLAG_DISCONNECT	redis-cli.c	117;"	d	file:
CLUSTER_MANAGER_FLAG_FAIL	redis-cli.c	118;"	d	file:
CLUSTER_MANAGER_FLAG_FRIEND	redis-cli.c	115;"	d	file:
CLUSTER_MANAGER_FLAG_MYSELF	redis-cli.c	113;"	d	file:
CLUSTER_MANAGER_FLAG_NOADDR	redis-cli.c	116;"	d	file:
CLUSTER_MANAGER_FLAG_SLAVE	redis-cli.c	114;"	d	file:
CLUSTER_MANAGER_INVALID_HOST_ARG	redis-cli.c	86;"	d	file:
CLUSTER_MANAGER_LOG_LVL_ERR	redis-cli.c	142;"	d	file:
CLUSTER_MANAGER_LOG_LVL_INFO	redis-cli.c	140;"	d	file:
CLUSTER_MANAGER_LOG_LVL_SUCCESS	redis-cli.c	143;"	d	file:
CLUSTER_MANAGER_LOG_LVL_WARN	redis-cli.c	141;"	d	file:
CLUSTER_MANAGER_MASTERS_COUNT	redis-cli.c	91;"	d	file:
CLUSTER_MANAGER_MIGRATE_PIPELINE	redis-cli.c	83;"	d	file:
CLUSTER_MANAGER_MIGRATE_TIMEOUT	redis-cli.c	82;"	d	file:
CLUSTER_MANAGER_MODE	redis-cli.c	90;"	d	file:
CLUSTER_MANAGER_NODE_ARRAY_FREE	redis-cli.c	95;"	d	file:
CLUSTER_MANAGER_OPT_COLD	redis-cli.c	135;"	d	file:
CLUSTER_MANAGER_OPT_GETFRIENDS	redis-cli.c	134;"	d	file:
CLUSTER_MANAGER_OPT_QUIET	redis-cli.c	137;"	d	file:
CLUSTER_MANAGER_OPT_UPDATE	redis-cli.c	136;"	d	file:
CLUSTER_MANAGER_OPT_VERBOSE	redis-cli.c	138;"	d	file:
CLUSTER_MANAGER_PRINT_REPLY_ERROR	redis-cli.c	97;"	d	file:
CLUSTER_MANAGER_REBALANCE_THRESHOLD	redis-cli.c	84;"	d	file:
CLUSTER_MANAGER_SLOTS	redis-cli.c	81;"	d	file:
CLUSTER_MAX_REJOIN_DELAY	cluster.c	3935;"	d	file:
CLUSTER_MF_PAUSE_MULT	cluster.h	21;"	d
CLUSTER_MF_TIMEOUT	cluster.h	20;"	d
CLUSTER_MIN_REJOIN_DELAY	cluster.c	3936;"	d	file:
CLUSTER_MODULE_FLAG_NONE	cluster.h	105;"	d
CLUSTER_MODULE_FLAG_NO_FAILOVER	cluster.h	106;"	d
CLUSTER_MODULE_FLAG_NO_REDIRECTION	cluster.h	107;"	d
CLUSTER_NAMELEN	cluster.h	11;"	d
CLUSTER_NODE_FAIL	cluster.h	51;"	d
CLUSTER_NODE_HANDSHAKE	cluster.h	53;"	d
CLUSTER_NODE_MASTER	cluster.h	48;"	d
CLUSTER_NODE_MEET	cluster.h	55;"	d
CLUSTER_NODE_MIGRATE_TO	cluster.h	56;"	d
CLUSTER_NODE_MYSELF	cluster.h	52;"	d
CLUSTER_NODE_NOADDR	cluster.h	54;"	d
CLUSTER_NODE_NOFAILOVER	cluster.h	57;"	d
CLUSTER_NODE_NULL_NAME	cluster.h	58;"	d
CLUSTER_NODE_PFAIL	cluster.h	50;"	d
CLUSTER_NODE_SLAVE	cluster.h	49;"	d
CLUSTER_OK	cluster.h	9;"	d
CLUSTER_PORT_INCR	cluster.h	12;"	d
CLUSTER_PROTO_VER	cluster.h	254;"	d
CLUSTER_REDIR_ASK	cluster.h	28;"	d
CLUSTER_REDIR_CROSS_SLOT	cluster.h	26;"	d
CLUSTER_REDIR_DOWN_RO_STATE	cluster.h	32;"	d
CLUSTER_REDIR_DOWN_STATE	cluster.h	30;"	d
CLUSTER_REDIR_DOWN_UNBOUND	cluster.h	31;"	d
CLUSTER_REDIR_MOVED	cluster.h	29;"	d
CLUSTER_REDIR_NONE	cluster.h	25;"	d
CLUSTER_REDIR_UNSTABLE	cluster.h	27;"	d
CLUSTER_SLAVE_MIGRATION_DELAY	cluster.h	22;"	d
CLUSTER_SLOTS	cluster.h	8;"	d
CLUSTER_SLOTS	redis-benchmark.c	69;"	d	file:
CLUSTER_TODO_FSYNC_CONFIG	cluster.h	81;"	d
CLUSTER_TODO_HANDLE_FAILOVER	cluster.h	78;"	d
CLUSTER_TODO_HANDLE_MANUALFAILOVER	cluster.h	82;"	d
CLUSTER_TODO_SAVE_CONFIG	cluster.h	80;"	d
CLUSTER_TODO_UPDATE_STATE	cluster.h	79;"	d
CLUSTER_WRITABLE_DELAY	cluster.c	3937;"	d	file:
CMD_ADMIN	server.h	179;"	d
CMD_ASKING	server.h	188;"	d
CMD_CALL_FULL	server.h	448;"	d
CMD_CALL_NONE	server.h	442;"	d
CMD_CALL_NOWRAP	server.h	449;"	d
CMD_CALL_PROPAGATE	server.h	447;"	d
CMD_CALL_PROPAGATE_AOF	server.h	445;"	d
CMD_CALL_PROPAGATE_REPL	server.h	446;"	d
CMD_CALL_SLOWLOG	server.h	443;"	d
CMD_CALL_STATS	server.h	444;"	d
CMD_CATEGORY_ADMIN	server.h	211;"	d
CMD_CATEGORY_BITMAP	server.h	206;"	d
CMD_CATEGORY_BLOCKING	server.h	214;"	d
CMD_CATEGORY_CONNECTION	server.h	216;"	d
CMD_CATEGORY_DANGEROUS	server.h	215;"	d
CMD_CATEGORY_FAST	server.h	212;"	d
CMD_CATEGORY_GEO	server.h	208;"	d
CMD_CATEGORY_HASH	server.h	204;"	d
CMD_CATEGORY_HYPERLOGLOG	server.h	207;"	d
CMD_CATEGORY_KEYSPACE	server.h	198;"	d
CMD_CATEGORY_LIST	server.h	203;"	d
CMD_CATEGORY_PUBSUB	server.h	210;"	d
CMD_CATEGORY_READ	server.h	199;"	d
CMD_CATEGORY_SCRIPTING	server.h	218;"	d
CMD_CATEGORY_SET	server.h	201;"	d
CMD_CATEGORY_SLOW	server.h	213;"	d
CMD_CATEGORY_SORTEDSET	server.h	202;"	d
CMD_CATEGORY_STREAM	server.h	209;"	d
CMD_CATEGORY_STRING	server.h	205;"	d
CMD_CATEGORY_TRANSACTION	server.h	217;"	d
CMD_CATEGORY_WRITE	server.h	200;"	d
CMD_DENYOOM	server.h	177;"	d
CMD_FAST	server.h	189;"	d
CMD_LOADING	server.h	184;"	d
CMD_MAY_REPLICATE	server.h	191;"	d
CMD_MODULE	server.h	178;"	d
CMD_MODULE_GETKEYS	server.h	194;"	d
CMD_MODULE_NO_CLUSTER	server.h	195;"	d
CMD_NOSCRIPT	server.h	181;"	d
CMD_NO_AUTH	server.h	190;"	d
CMD_PUBSUB	server.h	180;"	d
CMD_RANDOM	server.h	182;"	d
CMD_READONLY	server.h	176;"	d
CMD_SKIP_MONITOR	server.h	186;"	d
CMD_SKIP_SLOWLOG	server.h	187;"	d
CMD_SORT_FOR_SCRIPT	server.h	183;"	d
CMD_STALE	server.h	185;"	d
CMD_WRITE	server.h	175;"	d
COM	geohash_helper.c	47;"	d	file:
COMMAND_GET	t_string.c	153;"	d	file:
COMMAND_SET	t_string.c	154;"	d	file:
COMPRESS_MAX	quicklist.c	107;"	d	file:
CONFIG_AUTHPASS_MAX_LEN	server.h	105;"	d
CONFIG_BGSAVE_RETRY_DELAY	server.h	109;"	d
CONFIG_BINDADDR_MAX	server.h	118;"	d
CONFIG_DEFAULT_CLUSTER_CONFIG_FILE	server.h	111;"	d
CONFIG_DEFAULT_HZ	server.h	92;"	d
CONFIG_DEFAULT_LOGFILE	server.h	113;"	d
CONFIG_DEFAULT_PID_FILE	server.h	110;"	d
CONFIG_DEFAULT_PROC_TITLE_TEMPLATE	server.h	120;"	d
CONFIG_DEFAULT_UNIX_SOCKET_PERM	server.h	112;"	d
CONFIG_FDSET_INCR	server.h	159;"	d
CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE	redis-benchmark.c	72;"	d	file:
CONFIG_LATENCY_HISTOGRAM_MAX_VALUE	redis-benchmark.c	71;"	d	file:
CONFIG_LATENCY_HISTOGRAM_MIN_VALUE	redis-benchmark.c	70;"	d	file:
CONFIG_MAX_HZ	server.h	94;"	d
CONFIG_MAX_LINE	server.h	96;"	d
CONFIG_MIN_HZ	server.h	93;"	d
CONFIG_MIN_RESERVED_FDS	server.h	119;"	d
CONFIG_OOM_BGCHILD	server.h	164;"	d
CONFIG_OOM_COUNT	server.h	165;"	d
CONFIG_OOM_MASTER	server.h	162;"	d
CONFIG_OOM_REPLICA	server.h	163;"	d
CONFIG_REPL_BACKLOG_MIN_SIZE	server.h	108;"	d
CONFIG_REPL_SYNCIO_TIMEOUT	server.h	353;"	d
CONFIG_RUN_ID_SIZE	server.h	106;"	d
CONN_FLAG_CLOSE_SCHEDULED	connection.h	48;"	d
CONN_FLAG_WRITE_BARRIER	connection.h	49;"	d
CONN_INFO_LEN	connection.h	34;"	d
CONN_STATE_ACCEPTING	connection.h	/^    CONN_STATE_ACCEPTING,$/;"	e	enum:__anon15
CONN_STATE_CLOSED	connection.h	/^    CONN_STATE_CLOSED,$/;"	e	enum:__anon15
CONN_STATE_CONNECTED	connection.h	/^    CONN_STATE_CONNECTED,$/;"	e	enum:__anon15
CONN_STATE_CONNECTING	connection.h	/^    CONN_STATE_CONNECTING,$/;"	e	enum:__anon15
CONN_STATE_ERROR	connection.h	/^    CONN_STATE_ERROR$/;"	e	enum:__anon15
CONN_STATE_NONE	connection.h	/^    CONN_STATE_NONE = 0,$/;"	e	enum:__anon15
CONN_TYPE_SOCKET	connection.h	51;"	d
CONN_TYPE_TLS	connection.h	52;"	d
CRC64_H	crc64.h	2;"	d
CRCSPEED_H	crcspeed.h	29;"	d
CRON_DBS_PER_CALL	server.h	97;"	d
CT_Socket	connection.c	/^ConnectionType CT_Socket = {$/;"	v
CT_Socket	connection.c	/^ConnectionType CT_Socket;$/;"	v
CT_TLS	tls.c	/^ConnectionType CT_TLS = {$/;"	v
CT_TLS	tls.c	/^ConnectionType CT_TLS;$/;"	v
C_ERR	server.h	89;"	d
C_OK	server.h	88;"	d
ClientsPeakMemInput	server.c	/^size_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS] = {0};$/;"	v
ClientsPeakMemOutput	server.c	/^size_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS] = {0};$/;"	v
ConnectionCallbackFunc	connection.h	/^typedef void (*ConnectionCallbackFunc)(struct connection *conn);$/;"	t
ConnectionState	connection.h	/^} ConnectionState;$/;"	t	typeref:enum:__anon15
ConnectionType	connection.h	/^typedef struct ConnectionType {$/;"	s
ConnectionType	connection.h	/^} ConnectionType;$/;"	t	typeref:struct:ConnectionType
D	debugmacro.h	34;"	d
D	quicklist.c	65;"	d	file:
D	quicklist.c	67;"	d	file:
DEBUG	Makefile	/^	DEBUG=-g$/;"	m
DEBUG	Makefile	/^DEBUG=-g -ggdb$/;"	m
DEBUG_FLAGS	Makefile	/^	DEBUG_FLAGS=-g$/;"	m
DEFAULT_LATENCY_PRECISION	redis-benchmark.c	66;"	d	file:
DEFRAG_SDS_DICT_NO_VAL	defrag.c	256;"	d	file:
DEFRAG_SDS_DICT_VAL_IS_SDS	defrag.c	257;"	d	file:
DEFRAG_SDS_DICT_VAL_IS_STROB	defrag.c	258;"	d	file:
DEFRAG_SDS_DICT_VAL_VOID_PTR	defrag.c	259;"	d	file:
DEG_TO_RAD	geohash_helper.c	/^const double DEG_TO_RAD = 0.017453292519943295769236907684886;$/;"	v
DEP	Makefile	/^DEP = $(REDIS_SERVER_OBJ:%.o=%.d) $(REDIS_CLI_OBJ:%.o=%.d) $(REDIS_BENCHMARK_OBJ:%.o=%.d)$/;"	m
DEPENDENCY_TARGETS	Makefile	/^DEPENDENCY_TARGETS=hiredis linenoise lua hdr_histogram$/;"	m
DFLAGS	Makefile	/^	echo LDFLAGS=$(LDFLAGS) >> .make-settings$/;"	m
DICT_ERR	dict.h	45;"	d
DICT_HT_INITIAL_SIZE	dict.h	105;"	d
DICT_NOTUSED	dict.h	48;"	d
DICT_OK	dict.h	44;"	d
DICT_STATS_VECTLEN	dict.c	1095;"	d	file:
DISK_ERROR_TYPE_AOF	server.h	2061;"	d
DISK_ERROR_TYPE_NONE	server.h	2063;"	d
DISK_ERROR_TYPE_RDB	server.h	2062;"	d
D_R	geohash_helper.c	42;"	d	file:
DefaultUser	acl.c	/^user *DefaultUser;  \/* Global reference to the default user.$/;"	v
EARTH_RADIUS_IN_METERS	geohash_helper.c	/^const double EARTH_RADIUS_IN_METERS = 6372797.560856;$/;"	v
ECCENT	geohash_helper.c	46;"	d	file:
EDIS_CFLAGS	Makefile	/^	echo REDIS_CFLAGS=$(REDIS_CFLAGS) >> .make-settings$/;"	m
EDIS_LDFLAGS	Makefile	/^	echo REDIS_LDFLAGS=$(REDIS_LDFLAGS) >> .make-settings$/;"	m
EMPTYDB_ASYNC	server.h	2351;"	d
EMPTYDB_NO_FLAGS	server.h	2350;"	d
EMPTY_STRING_IS_NULL	config.c	1855;"	d	file:
ENDCOLOR	Makefile	/^ENDCOLOR="\\033[0m"$/;"	m
EP0	sha256.c	26;"	d	file:
EP1	sha256.c	27;"	d	file:
ERR	quicklist.c	1529;"	d	file:
ERROR	quicklist.c	1523;"	d	file:
ERROR	redis-check-aof.c	34;"	d	file:
ESOCKTNOSUPPORT	config.h	130;"	d
EVICT_FAIL	server.h	2463;"	d
EVICT_OK	server.h	2461;"	d
EVICT_RUNNING	server.h	2462;"	d
EVPOOL_CACHED_SDS_SIZE	evict.c	54;"	d	file:
EVPOOL_SIZE	evict.c	53;"	d	file:
EvictionPoolLRU	evict.c	/^static struct evictionPoolEntry *EvictionPoolLRU;$/;"	v	typeref:struct:evictionPoolEntry	file:
FAIL	modules/testmodule.c	174;"	d	file:
FAIL	modules/testmodule.c	260;"	d	file:
FAIL	modules/testmodule.c	261;"	d	file:
FAILOVER_IN_PROGRESS	server.h	/^    FAILOVER_IN_PROGRESS    \/* Waiting for target replica to accept$/;"	e	enum:__anon43
FAILOVER_WAIT_FOR_SYNC	server.h	/^    FAILOVER_WAIT_FOR_SYNC, \/* Waiting for target replica to catch up *\/$/;"	e	enum:__anon43
FD_TO_PEER_NAME	anet.h	53;"	d
FD_TO_SOCK_NAME	anet.h	54;"	d
FILL_MAX	quicklist.c	117;"	d	file:
FINAL_CFLAGS	Makefile	/^FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)$/;"	m
FINAL_LDFLAGS	Makefile	/^FINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)$/;"	m
FINAL_LIBS	Makefile	/^	FINAL_LIBS := ..\/deps\/jemalloc\/lib\/libjemalloc.a $(FINAL_LIBS)$/;"	m
FINAL_LIBS	Makefile	/^FINAL_LIBS=-lm$/;"	m
FLAGS	Makefile	/^	echo CFLAGS=$(CFLAGS) >> .make-settings$/;"	m
FRST	lzf_c.c	48;"	d	file:
GENPASS_MAX_BITS	acl.c	2106;"	d	file:
GEOHASH_EAST	geohash.h	/^    GEOHASH_EAST,$/;"	e	enum:__anon19
GEOHASH_HELPER_HPP_	geohash_helper.h	33;"	d
GEOHASH_H_	geohash.h	33;"	d
GEOHASH_NORTH	geohash.h	/^    GEOHASH_NORTH = 0,$/;"	e	enum:__anon19
GEOHASH_NORT_EAST	geohash.h	/^    GEOHASH_NORT_EAST$/;"	e	enum:__anon19
GEOHASH_NORT_WEST	geohash.h	/^    GEOHASH_NORT_WEST,$/;"	e	enum:__anon19
GEOHASH_SOUTH	geohash.h	/^    GEOHASH_SOUTH,$/;"	e	enum:__anon19
GEOHASH_SOUTH_EAST	geohash.h	/^    GEOHASH_SOUTH_EAST,$/;"	e	enum:__anon19
GEOHASH_SOUTH_WEST	geohash.h	/^    GEOHASH_SOUTH_WEST,$/;"	e	enum:__anon19
GEOHASH_WEST	geohash.h	/^    GEOHASH_WEST,$/;"	e	enum:__anon19
GEOSEARCH	geo.c	505;"	d	file:
GEOSEARCHSTORE	geo.c	506;"	d	file:
GEO_LAT_MAX	geohash.h	51;"	d
GEO_LAT_MIN	geohash.h	50;"	d
GEO_LONG_MAX	geohash.h	53;"	d
GEO_LONG_MIN	geohash.h	52;"	d
GEO_STEP_MAX	geohash.h	47;"	d
GETFAIR_NUM_ENTRIES	dict.c	774;"	d	file:
GETKEYS_RESULT_INIT	server.h	1641;"	d
GET_NUMERIC_TYPE	config.c	1964;"	d	file:
GISNOTZERO	geohash_helper.h	39;"	d
GISZERO	geohash_helper.h	38;"	d
GNUC_VERSION	config.h	207;"	d
GZERO	geohash_helper.h	37;"	d
GeoDirection	geohash.h	/^} GeoDirection;$/;"	t	typeref:enum:__anon19
GeoHashArea	geohash.h	/^} GeoHashArea;$/;"	t	typeref:struct:__anon22
GeoHashBits	geohash.h	/^} GeoHashBits;$/;"	t	typeref:struct:__anon20
GeoHashFix52Bits	geohash_helper.h	/^typedef uint64_t GeoHashFix52Bits;$/;"	t
GeoHashNeighbors	geohash.h	/^} GeoHashNeighbors;$/;"	t	typeref:struct:__anon23
GeoHashRadius	geohash_helper.h	/^} GeoHashRadius;$/;"	t	typeref:struct:__anon27
GeoHashRange	geohash.h	/^} GeoHashRange;$/;"	t	typeref:struct:__anon21
GeoHashVarBits	geohash_helper.h	/^typedef uint64_t GeoHashVarBits;$/;"	t
GeoShape	geohash.h	/^} GeoShape;$/;"	t	typeref:struct:__anon24
HASHISZERO	geohash.h	43;"	d
HASHTABLE_MAX_LOAD_FACTOR	server.h	171;"	d
HASHTABLE_MIN_FILL	server.h	170;"	d
HASH_PASSWORD_LEN	acl.c	110;"	d	file:
HASH_SET_COPY	server.h	2275;"	d
HASH_SET_COPY	t_hash.c	201;"	d	file:
HASH_SET_TAKE_FIELD	server.h	2273;"	d
HASH_SET_TAKE_FIELD	t_hash.c	199;"	d	file:
HASH_SET_TAKE_VALUE	server.h	2274;"	d
HASH_SET_TAKE_VALUE	t_hash.c	200;"	d	file:
HAVE_ATOMIC	config.h	209;"	d
HAVE_ATOMIC	config.h	213;"	d
HAVE_BACKTRACE	config.h	68;"	d
HAVE_CLEARENV	setproctitle.c	54;"	d	file:
HAVE_DEFRAG	zmalloc.h	96;"	d
HAVE_EPOLL	config.h	78;"	d
HAVE_EVPORT	config.h	88;"	d
HAVE_KQUEUE	config.h	82;"	d
HAVE_MALLOC_SIZE	zmalloc.h	42;"	d
HAVE_MALLOC_SIZE	zmalloc.h	52;"	d
HAVE_MALLOC_SIZE	zmalloc.h	60;"	d
HAVE_MALLOC_SIZE	zmalloc.h	86;"	d
HAVE_MSG_NOSIGNAL	config.h	73;"	d
HAVE_PROC_MAPS	config.h	53;"	d
HAVE_PROC_OOM_SCORE_ADJ	config.h	56;"	d
HAVE_PROC_SMAPS	config.h	54;"	d
HAVE_PROC_SOMAXCONN	config.h	55;"	d
HAVE_PROC_STAT	config.h	52;"	d
HAVE_PSINFO	config.h	89;"	d
HAVE_SETPROCTITLE	setproctitle.c	43;"	d	file:
HAVE_SETPROCTITLE	setproctitle.c	45;"	d	file:
HAVE_TASKINFO	config.h	61;"	d
HIGH	rand.c	49;"	d	file:
HI_BIT	rand.c	66;"	d	file:
HLL_ALPHA_INF	hyperloglog.c	389;"	d	file:
HLL_BITS	hyperloglog.c	199;"	d	file:
HLL_DENSE	hyperloglog.c	203;"	d	file:
HLL_DENSE_GET_REGISTER	hyperloglog.c	339;"	d	file:
HLL_DENSE_SET_REGISTER	hyperloglog.c	351;"	d	file:
HLL_DENSE_SIZE	hyperloglog.c	202;"	d	file:
HLL_HDR_SIZE	hyperloglog.c	201;"	d	file:
HLL_INVALIDATE_CACHE	hyperloglog.c	191;"	d	file:
HLL_MAX_ENCODING	hyperloglog.c	206;"	d	file:
HLL_P	hyperloglog.c	194;"	d	file:
HLL_P_MASK	hyperloglog.c	198;"	d	file:
HLL_Q	hyperloglog.c	195;"	d	file:
HLL_RAW	hyperloglog.c	205;"	d	file:
HLL_REGISTERS	hyperloglog.c	197;"	d	file:
HLL_REGISTER_MAX	hyperloglog.c	200;"	d	file:
HLL_SPARSE	hyperloglog.c	204;"	d	file:
HLL_SPARSE_IS_VAL	hyperloglog.c	369;"	d	file:
HLL_SPARSE_IS_XZERO	hyperloglog.c	368;"	d	file:
HLL_SPARSE_IS_ZERO	hyperloglog.c	367;"	d	file:
HLL_SPARSE_VAL_BIT	hyperloglog.c	366;"	d	file:
HLL_SPARSE_VAL_LEN	hyperloglog.c	373;"	d	file:
HLL_SPARSE_VAL_MAX_LEN	hyperloglog.c	375;"	d	file:
HLL_SPARSE_VAL_MAX_VALUE	hyperloglog.c	374;"	d	file:
HLL_SPARSE_VAL_SET	hyperloglog.c	378;"	d	file:
HLL_SPARSE_VAL_VALUE	hyperloglog.c	372;"	d	file:
HLL_SPARSE_XZERO_BIT	hyperloglog.c	365;"	d	file:
HLL_SPARSE_XZERO_LEN	hyperloglog.c	371;"	d	file:
HLL_SPARSE_XZERO_MAX_LEN	hyperloglog.c	377;"	d	file:
HLL_SPARSE_XZERO_SET	hyperloglog.c	384;"	d	file:
HLL_SPARSE_ZERO_LEN	hyperloglog.c	370;"	d	file:
HLL_SPARSE_ZERO_MAX_LEN	hyperloglog.c	376;"	d	file:
HLL_SPARSE_ZERO_SET	hyperloglog.c	381;"	d	file:
HLL_TEST_CYCLES	hyperloglog.c	1388;"	d	file:
HLL_VALID_CACHE	hyperloglog.c	192;"	d	file:
HLOG	lzfP.h	55;"	d
HOTKEYS_SAMPLE	redis-cli.c	7756;"	d	file:
HRANDFIELD_RANDOM_SAMPLE_LIMIT	t_hash.c	982;"	d	file:
HRANDFIELD_SUB_STRATEGY_MUL	t_hash.c	977;"	d	file:
HSIZE	lzf_c.c	39;"	d	file:
HelloACL_FreeData	modules/helloacl.c	/^void HelloACL_FreeData(RedisModuleCtx *ctx, void *privdata) {$/;"	f
HelloACL_Reply	modules/helloacl.c	/^int HelloACL_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloACL_ThreadMain	modules/helloacl.c	/^void *HelloACL_ThreadMain(void *args) {$/;"	f
HelloACL_Timeout	modules/helloacl.c	/^int HelloACL_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloACL_UserChanged	modules/helloacl.c	/^void HelloACL_UserChanged(uint64_t client_id, void *privdata) {$/;"	f
HelloBlock_Disconnected	modules/helloblock.c	/^void HelloBlock_Disconnected(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc) {$/;"	f
HelloBlock_FreeData	modules/helloblock.c	/^void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {$/;"	f
HelloBlock_FreeData	modules/hellotype.c	/^void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {$/;"	f
HelloBlock_RedisCommand	modules/helloblock.c	/^int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloBlock_Reply	modules/helloblock.c	/^int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloBlock_Reply	modules/hellotype.c	/^int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloBlock_ThreadMain	modules/helloblock.c	/^void *HelloBlock_ThreadMain(void *arg) {$/;"	f
HelloBlock_Timeout	modules/helloblock.c	/^int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloBlock_Timeout	modules/hellotype.c	/^int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloHCopy_RedisCommand	modules/helloworld.c	/^int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloKeys_RedisCommand	modules/helloblock.c	/^int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloKeys_ThreadMain	modules/helloblock.c	/^void *HelloKeys_ThreadMain(void *arg) {$/;"	f
HelloLeftPad_RedisCommand	modules/helloworld.c	/^int HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloLexRange_RedisCommand	modules/helloworld.c	/^int HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloListSpliceAuto_RedisCommand	modules/helloworld.c	/^int HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloListSplice_RedisCommand	modules/helloworld.c	/^int HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloListSumLen_RedisCommand	modules/helloworld.c	/^int HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f
HelloMoreExpire_RedisCommand	modules/helloworld.c	/^int HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloPushCall2_RedisCommand	modules/helloworld.c	/^int HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f
HelloPushCall_RedisCommand	modules/helloworld.c	/^int HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f
HelloPushNative_RedisCommand	modules/helloworld.c	/^int HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f
HelloRandArray_RedisCommand	modules/helloworld.c	/^int HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloRepl1_RedisCommand	modules/helloworld.c	/^int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f
HelloRepl2_RedisCommand	modules/helloworld.c	/^int HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloSimple_RedisCommand	modules/helloworld.c	/^int HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloToggleCase_RedisCommand	modules/helloworld.c	/^int HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloType	modules/hellotype.c	/^static RedisModuleType *HelloType;$/;"	v	file:
HelloTypeAofRewrite	modules/hellotype.c	/^void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {$/;"	f
HelloTypeBRange_RedisCommand	modules/hellotype.c	/^int HelloTypeBRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloTypeDigest	modules/hellotype.c	/^void HelloTypeDigest(RedisModuleDigest *md, void *value) {$/;"	f
HelloTypeFree	modules/hellotype.c	/^void HelloTypeFree(void *value) {$/;"	f
HelloTypeInsert	modules/hellotype.c	/^void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {$/;"	f
HelloTypeInsert_RedisCommand	modules/hellotype.c	/^int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloTypeLen_RedisCommand	modules/hellotype.c	/^int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloTypeMemUsage	modules/hellotype.c	/^size_t HelloTypeMemUsage(const void *value) {$/;"	f
HelloTypeNode	modules/hellotype.c	/^struct HelloTypeNode {$/;"	s	file:
HelloTypeObject	modules/hellotype.c	/^struct HelloTypeObject {$/;"	s	file:
HelloTypeRange_RedisCommand	modules/hellotype.c	/^int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
HelloTypeRdbLoad	modules/hellotype.c	/^void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {$/;"	f
HelloTypeRdbSave	modules/hellotype.c	/^void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {$/;"	f
HelloTypeReleaseObject	modules/hellotype.c	/^void HelloTypeReleaseObject(struct HelloTypeObject *o) {$/;"	f
HelloZsumRange_RedisCommand	modules/helloworld.c	/^int HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
IDX	lzf_c.c	51;"	d	file:
IDX	lzf_c.c	53;"	d	file:
IDX	lzf_c.c	55;"	d	file:
IMMUTABLE_CONFIG	config.c	251;"	d	file:
INIT_HTAB	lzfP.h	95;"	d
INIT_SETPROCTITLE_REPLACEMENT	config.h	135;"	d
INIT_SETPROCTITLE_REPLACEMENT	server.c	6193;"	d	file:
INSTALL	Makefile	/^	INSTALL=cp -pf$/;"	m
INSTALL	Makefile	/^INSTALL=install$/;"	m
INSTALL_BIN	Makefile	/^INSTALL_BIN=$(PREFIX)\/bin$/;"	m
INT24_MAX	ziplist.c	222;"	d	file:
INT24_MIN	ziplist.c	223;"	d	file:
INTEGER_CONFIG	config.c	2076;"	d	file:
INTERPOLATE	defrag.c	1042;"	d	file:
INTSET_ENC_INT16	intset.c	41;"	d	file:
INTSET_ENC_INT32	intset.c	42;"	d	file:
INTSET_ENC_INT64	intset.c	43;"	d	file:
IOThreadMain	networking.c	/^void *IOThreadMain(void *myid) {$/;"	f
IO_THREADS_MAX_NUM	networking.c	3387;"	d	file:
IO_THREADS_OP_READ	networking.c	3388;"	d	file:
IO_THREADS_OP_WRITE	networking.c	3389;"	d	file:
InitServerLast	server.c	/^void InitServerLast() {$/;"	f
Keyspace	modules/hellodict.c	/^static RedisModuleDict *Keyspace;$/;"	v	file:
LATENCY_DIST_DEFAULT_INTERVAL	redis-cli.c	6845;"	d	file:
LATENCY_GRAPH_COLS	latency.c	533;"	d	file:
LATENCY_HISTORY_DEFAULT_INTERVAL	redis-cli.c	6780;"	d	file:
LATENCY_SAMPLE_RATE	redis-cli.c	6779;"	d	file:
LATENCY_TS_LEN	latency.h	37;"	d
LAZYFREE_THRESHOLD	lazyfree.c	145;"	d	file:
LCS	t_string.c	809;"	d	file:
LDB_BREAKPOINTS_MAX	scripting.c	62;"	d	file:
LDB_MAX_LEN_DEFAULT	scripting.c	63;"	d	file:
LDB_MAX_VALUES_DEPTH	scripting.c	2164;"	d	file:
LD_STR_AUTO	util.h	/^    LD_STR_AUTO,     \/* %.17Lg *\/$/;"	e	enum:__anon71
LD_STR_HEX	util.h	/^    LD_STR_HEX       \/* %La *\/$/;"	e	enum:__anon71
LD_STR_HUMAN	util.h	/^    LD_STR_HUMAN,    \/* %.17Lf + Trimming of trailing zeros *\/$/;"	e	enum:__anon71
LFUDecrAndReturn	evict.c	/^unsigned long LFUDecrAndReturn(robj *o) {$/;"	f
LFUGetTimeInMinutes	evict.c	/^unsigned long LFUGetTimeInMinutes(void) {$/;"	f
LFULogIncr	evict.c	/^uint8_t LFULogIncr(uint8_t counter) {$/;"	f
LFUTimeElapsed	evict.c	/^unsigned long LFUTimeElapsed(unsigned long ldt) {$/;"	f
LFU_INIT_VAL	server.h	2457;"	d
LIBCRYPTO_LIBS	Makefile	/^	LIBCRYPTO_LIBS=$(shell $(PKG_CONFIG) --libs libcrypto)$/;"	m
LIBCRYPTO_LIBS	Makefile	/^	LIBCRYPTO_LIBS=-lcrypto$/;"	m
LIBCRYPTO_PKGCONFIG	Makefile	/^	LIBCRYPTO_PKGCONFIG := $(shell $(PKG_CONFIG) --exists libcrypto && echo $$?)$/;"	m
LIBSSL_LIBS	Makefile	/^	LIBSSL_LIBS=$(shell $(PKG_CONFIG) --libs libssl)$/;"	m
LIBSSL_LIBS	Makefile	/^	LIBSSL_LIBS=-lssl$/;"	m
LIBSSL_PKGCONFIG	Makefile	/^	LIBSSL_PKGCONFIG := $(shell $(PKG_CONFIG) --exists libssl && echo $$?)$/;"	m
LIBSYSTEMD_LIBS	Makefile	/^	LIBSYSTEMD_LIBS=$(shell $(PKG_CONFIG) --libs libsystemd)$/;"	m
LIBSYSTEMD_LIBS	Makefile	/^LIBSYSTEMD_LIBS=-lsystemd$/;"	m
LIBSYSTEMD_PKGCONFIG	Makefile	/^	LIBSYSTEMD_PKGCONFIG := $(shell $(PKG_CONFIG) --exists libsystemd && echo $$?)$/;"	m
LIMIT	defrag.c	1043;"	d	file:
LIMIT_PENDING_QUERYBUF	server.h	153;"	d
LINKCOLOR	Makefile	/^LINKCOLOR="\\033[34;1m"$/;"	m
LISTPACK_ALLOC_H	listpack_malloc.h	40;"	d
LIST_HEAD	server.h	356;"	d
LIST_TAIL	server.h	357;"	d
LITTLE_ENDIAN	config.h	150;"	d
LITTLE_ENDIAN	config.h	182;"	d
LL_DEBUG	server.h	365;"	d
LL_NOTICE	server.h	367;"	d
LL_RAW	server.h	369;"	d
LL_VERBOSE	server.h	366;"	d
LL_WARNING	server.h	368;"	d
LM	mt19937-64.c	64;"	d	file:
LOADBUF_SIZE	config.c	1727;"	d	file:
LOG_COLOR_BOLD	redis-cli.c	147;"	d	file:
LOG_COLOR_GREEN	redis-cli.c	149;"	d	file:
LOG_COLOR_RED	redis-cli.c	148;"	d	file:
LOG_COLOR_RESET	redis-cli.c	151;"	d	file:
LOG_COLOR_YELLOW	redis-cli.c	150;"	d	file:
LOG_MAX_LEN	server.h	102;"	d
LONG_STR_SIZE	server.h	150;"	d
LOOKUP_NONE	server.h	2337;"	d
LOOKUP_NONOTIFY	server.h	2339;"	d
LOOKUP_NOTOUCH	server.h	2338;"	d
LOW	rand.c	48;"	d	file:
LP_AFTER	listpack.h	45;"	d
LP_BEFORE	listpack.h	44;"	d
LP_ENCODING_12BIT_STR	listpack.c	67;"	d	file:
LP_ENCODING_12BIT_STR_LEN	listpack.c	94;"	d	file:
LP_ENCODING_12BIT_STR_MASK	listpack.c	68;"	d	file:
LP_ENCODING_13BIT_INT	listpack.c	63;"	d	file:
LP_ENCODING_13BIT_INT_MASK	listpack.c	64;"	d	file:
LP_ENCODING_16BIT_INT	listpack.c	71;"	d	file:
LP_ENCODING_16BIT_INT_MASK	listpack.c	72;"	d	file:
LP_ENCODING_24BIT_INT	listpack.c	75;"	d	file:
LP_ENCODING_24BIT_INT_MASK	listpack.c	76;"	d	file:
LP_ENCODING_32BIT_INT	listpack.c	79;"	d	file:
LP_ENCODING_32BIT_INT_MASK	listpack.c	80;"	d	file:
LP_ENCODING_32BIT_STR	listpack.c	87;"	d	file:
LP_ENCODING_32BIT_STR_LEN	listpack.c	95;"	d	file:
LP_ENCODING_32BIT_STR_MASK	listpack.c	88;"	d	file:
LP_ENCODING_64BIT_INT	listpack.c	83;"	d	file:
LP_ENCODING_64BIT_INT_MASK	listpack.c	84;"	d	file:
LP_ENCODING_6BIT_STR	listpack.c	59;"	d	file:
LP_ENCODING_6BIT_STR_LEN	listpack.c	93;"	d	file:
LP_ENCODING_6BIT_STR_MASK	listpack.c	60;"	d	file:
LP_ENCODING_7BIT_UINT	listpack.c	55;"	d	file:
LP_ENCODING_7BIT_UINT_MASK	listpack.c	56;"	d	file:
LP_ENCODING_INT	listpack.c	52;"	d	file:
LP_ENCODING_IS_12BIT_STR	listpack.c	69;"	d	file:
LP_ENCODING_IS_13BIT_INT	listpack.c	65;"	d	file:
LP_ENCODING_IS_16BIT_INT	listpack.c	73;"	d	file:
LP_ENCODING_IS_24BIT_INT	listpack.c	77;"	d	file:
LP_ENCODING_IS_32BIT_INT	listpack.c	81;"	d	file:
LP_ENCODING_IS_32BIT_STR	listpack.c	89;"	d	file:
LP_ENCODING_IS_64BIT_INT	listpack.c	85;"	d	file:
LP_ENCODING_IS_6BIT_STR	listpack.c	61;"	d	file:
LP_ENCODING_IS_7BIT_UINT	listpack.c	57;"	d	file:
LP_ENCODING_STRING	listpack.c	53;"	d	file:
LP_EOF	listpack.c	91;"	d	file:
LP_HDR_NUMELE_UNKNOWN	listpack.c	48;"	d	file:
LP_HDR_SIZE	listpack.c	47;"	d	file:
LP_INTBUF_SIZE	listpack.h	41;"	d
LP_MAX_BACKLEN_SIZE	listpack.c	50;"	d	file:
LP_MAX_ENTRY_BACKLEN	listpack.c	51;"	d	file:
LP_MAX_INT_ENCODING_LEN	listpack.c	49;"	d	file:
LP_REPLACE	listpack.h	46;"	d
LRUTestGenKey	redis-cli.c	/^void LRUTestGenKey(char *buf, size_t buflen) {$/;"	f
LRUTestMode	redis-cli.c	/^static void LRUTestMode(void) {$/;"	f	file:
LRU_BITS	server.h	667;"	d
LRU_CLOCK	evict.c	/^unsigned int LRU_CLOCK(void) {$/;"	f
LRU_CLOCK_MAX	server.h	668;"	d
LRU_CLOCK_RESOLUTION	server.h	669;"	d
LRU_CYCLE_PERIOD	redis-cli.c	8050;"	d	file:
LRU_CYCLE_PIPELINE_SIZE	redis-cli.c	8051;"	d	file:
LUA_CMD_OBJCACHE_MAX_LEN	scripting.c	472;"	d	file:
LUA_CMD_OBJCACHE_SIZE	scripting.c	471;"	d	file:
LUA_GC_CYCLE_PERIOD	scripting.c	1623;"	d	file:
LZFP_h	lzfP.h	38;"	d
LZF_H	lzf.h	38;"	d
LZF_HSLOT	lzfP.h	/^  typedef const u8 *LZF_HSLOT;$/;"	t
LZF_HSLOT	lzfP.h	/^  typedef unsigned int LZF_HSLOT;$/;"	t
LZF_HSLOT_BIAS	lzfP.h	163;"	d
LZF_HSLOT_BIAS	lzfP.h	166;"	d
LZF_STATE	lzfP.h	/^typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];$/;"	t
LZF_STATE_ARG	lzfP.h	113;"	d
LZF_USE_OFFSETS	lzfP.h	149;"	d
LZF_VERSION	lzf.h	49;"	d
ListCommand_RedisCommand	modules/hellocluster.c	/^int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
MADV_FREE	server.c	5478;"	d	file:
MAJ	sha256.c	25;"	d	file:
MAKECOLOR	Makefile	/^MAKECOLOR="\\033[32;1m"$/;"	m
MAKE_INSTALL	Makefile	/^    define MAKE_INSTALL$/;"	m
MALLOC	Makefile	/^	MALLOC=jemalloc$/;"	m
MALLOC	Makefile	/^	MALLOC=libc$/;"	m
MALLOC	Makefile	/^	MALLOC=tcmalloc$/;"	m
MALLOC	Makefile	/^	MALLOC=tcmalloc_minimal$/;"	m
MALLOC	Makefile	/^MALLOC=libc$/;"	m
MALLOC_MIN_SIZE	zmalloc.c	66;"	d	file:
MASK	rand.c	47;"	d	file:
MATRIX_A	mt19937-64.c	62;"	d	file:
MAXMEMORY_ALLKEYS_LFU	server.h	427;"	d
MAXMEMORY_ALLKEYS_LRU	server.h	426;"	d
MAXMEMORY_ALLKEYS_RANDOM	server.h	428;"	d
MAXMEMORY_FLAG_ALLKEYS	server.h	418;"	d
MAXMEMORY_FLAG_LFU	server.h	417;"	d
MAXMEMORY_FLAG_LRU	server.h	416;"	d
MAXMEMORY_FLAG_NO_SHARED_INTEGERS	server.h	419;"	d
MAXMEMORY_NO_EVICTION	server.h	429;"	d
MAXMEMORY_VOLATILE_LFU	server.h	423;"	d
MAXMEMORY_VOLATILE_LRU	server.h	422;"	d
MAXMEMORY_VOLATILE_RANDOM	server.h	425;"	d
MAXMEMORY_VOLATILE_TTL	server.h	424;"	d
MAX_ACCEPTS_PER_CALL	networking.c	1033;"	d	file:
MAX_CLIENTS_PER_CLOCK_TICK	server.h	95;"	d
MAX_CLUSTER_ACCEPTS_PER_CALL	cluster.c	675;"	d	file:
MAX_EVENT_BATCHSZ	ae_evport.c	66;"	d	file:
MAX_KEYS_BUFFER	server.h	1630;"	d
MAX_LATENCY_PRECISION	redis-benchmark.c	67;"	d	file:
MAX_LIT	lzf_c.c	74;"	d	file:
MAX_LONG_DOUBLE_CHARS	util.h	39;"	d
MAX_OFF	lzf_c.c	75;"	d	file:
MAX_REF	lzf_c.c	76;"	d	file:
MAX_THREADS	redis-benchmark.c	68;"	d	file:
MEMORY_CONFIG	config.c	2077;"	d	file:
MEMTEST_32BIT	memtest.c	44;"	d	file:
MEMTEST_64BIT	memtest.c	46;"	d	file:
MEMTEST_BACKUP_WORDS	memtest.c	275;"	d	file:
MEMTEST_DECACHE_SIZE	memtest.c	279;"	d	file:
MEMTEST_MAX_REGIONS	debug.c	1642;"	d	file:
MERCATOR_MAX	geohash_helper.c	/^const double MERCATOR_MAX = 20037726.37;$/;"	v
MERCATOR_MIN	geohash_helper.c	/^const double MERCATOR_MIN = -20037726.37;$/;"	v
MIGRATE_SOCKET_CACHE_ITEMS	cluster.c	5221;"	d	file:
MIGRATE_SOCKET_CACHE_TTL	cluster.c	5222;"	d	file:
MIN_COMPRESS_BYTES	quicklist.c	56;"	d	file:
MIN_COMPRESS_IMPROVE	quicklist.c	61;"	d	file:
MM	mt19937-64.c	61;"	d	file:
MODIFIABLE_CONFIG	config.c	249;"	d	file:
MODULE_LOOKUP_CACHE_SIZE	module.c	4314;"	d	file:
MSGTYPE_PING	modules/hellocluster.c	40;"	d	file:
MSGTYPE_PONG	modules/hellocluster.c	41;"	d	file:
MUL	rand.c	50;"	d	file:
ModuleForkDoneHandler	module.c	/^void ModuleForkDoneHandler(int exitcode, int bysignal) {$/;"	f
ModuleTypeNameCharSet	module.c	/^const char *ModuleTypeNameCharSet =$/;"	v
ModulesInHooks	module.c	/^unsigned long long ModulesInHooks = 0; \/* Total number of modules in hooks$/;"	v
MurmurHash64A	hyperloglog.c	/^uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {$/;"	f
N	rand.c	46;"	d	file:
NDEBUG	monotonic.c	7;"	d	file:
NET_ADDR_STR_LEN	server.h	116;"	d
NET_FIRST_BIND_ADDR	server.h	489;"	d
NET_HOST_PORT_STR_LEN	server.h	117;"	d
NET_HOST_STR_LEN	server.h	114;"	d
NET_IP_STR_LEN	server.h	115;"	d
NET_MAX_WRITES_PER_EVENT	server.h	98;"	d
NEXT	lzf_c.c	49;"	d	file:
NN	mt19937-64.c	60;"	d	file:
NODEPS	Makefile	/^NODEPS:=clean distclean$/;"	m
NOTIFY_ALL	server.h	486;"	d
NOTIFY_EVICTED	server.h	481;"	d
NOTIFY_EXPIRED	server.h	480;"	d
NOTIFY_GENERIC	server.h	474;"	d
NOTIFY_HASH	server.h	478;"	d
NOTIFY_KEYEVENT	server.h	473;"	d
NOTIFY_KEYSPACE	server.h	472;"	d
NOTIFY_KEY_MISS	server.h	483;"	d
NOTIFY_LIST	server.h	476;"	d
NOTIFY_LOADED	server.h	484;"	d
NOTIFY_MODULE	server.h	485;"	d
NOTIFY_SET	server.h	477;"	d
NOTIFY_STREAM	server.h	482;"	d
NOTIFY_STRING	server.h	475;"	d
NOTIFY_ZSET	server.h	479;"	d
NO_FAILOVER	server.h	/^    NO_FAILOVER = 0,        \/* No failover in progress *\/$/;"	e	enum:__anon43
NUMERIC_TYPE_INT	config.c	/^    NUMERIC_TYPE_INT,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_LONG	config.c	/^    NUMERIC_TYPE_LONG,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_LONG_LONG	config.c	/^    NUMERIC_TYPE_LONG_LONG,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_OFF_T	config.c	/^    NUMERIC_TYPE_OFF_T,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_SIZE_T	config.c	/^    NUMERIC_TYPE_SIZE_T,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_SSIZE_T	config.c	/^    NUMERIC_TYPE_SSIZE_T,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_TIME_T	config.c	/^    NUMERIC_TYPE_TIME_T,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_UINT	config.c	/^    NUMERIC_TYPE_UINT,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_ULONG	config.c	/^    NUMERIC_TYPE_ULONG,$/;"	e	enum:numericType	file:
NUMERIC_TYPE_ULONG_LONG	config.c	/^    NUMERIC_TYPE_ULONG_LONG,$/;"	e	enum:numericType	file:
NotifyCallback	modules/testmodule.c	/^int NotifyCallback(RedisModuleCtx *ctx, int type, const char *event,$/;"	f
OBJ_COMPUTE_SIZE_DEF_SAMPLES	object.c	792;"	d	file:
OBJ_ENCODING_EMBSTR	server.h	663;"	d
OBJ_ENCODING_EMBSTR_SIZE_LIMIT	object.c	118;"	d	file:
OBJ_ENCODING_HT	server.h	657;"	d
OBJ_ENCODING_INT	server.h	656;"	d
OBJ_ENCODING_INTSET	server.h	661;"	d
OBJ_ENCODING_LINKEDLIST	server.h	659;"	d
OBJ_ENCODING_QUICKLIST	server.h	664;"	d
OBJ_ENCODING_RAW	server.h	655;"	d
OBJ_ENCODING_SKIPLIST	server.h	662;"	d
OBJ_ENCODING_STREAM	server.h	665;"	d
OBJ_ENCODING_ZIPLIST	server.h	660;"	d
OBJ_ENCODING_ZIPMAP	server.h	658;"	d
OBJ_EX	t_string.c	67;"	d	file:
OBJ_EXAT	t_string.c	71;"	d	file:
OBJ_FIRST_SPECIAL_REFCOUNT	server.h	673;"	d
OBJ_HASH	server.h	512;"	d
OBJ_HASH_KEY	server.h	1726;"	d
OBJ_HASH_VALUE	server.h	1727;"	d
OBJ_KEEPTTL	t_string.c	69;"	d	file:
OBJ_LIST	server.h	509;"	d
OBJ_MODULE	server.h	525;"	d
OBJ_NO_FLAGS	t_string.c	64;"	d	file:
OBJ_PERSIST	t_string.c	73;"	d	file:
OBJ_PX	t_string.c	68;"	d	file:
OBJ_PXAT	t_string.c	72;"	d	file:
OBJ_SET	server.h	510;"	d
OBJ_SET_GET	t_string.c	70;"	d	file:
OBJ_SET_NX	t_string.c	65;"	d	file:
OBJ_SET_XX	t_string.c	66;"	d	file:
OBJ_SHARED_BULKHDR_LEN	server.h	101;"	d
OBJ_SHARED_INTEGERS	server.h	100;"	d
OBJ_SHARED_REFCOUNT	server.h	671;"	d
OBJ_STATIC_REFCOUNT	server.h	672;"	d
OBJ_STREAM	server.h	526;"	d
OBJ_STRING	server.h	508;"	d
OBJ_ZSET	server.h	511;"	d
OOM_SCORE_ADJ_ABSOLUTE	server.h	411;"	d
OOM_SCORE_ADJ_NO	server.h	409;"	d
OOM_SCORE_RELATIVE	server.h	410;"	d
OPENSSL_CFLAGS	Makefile	/^	OPENSSL_CFLAGS=-I\/opt\/homebrew\/opt\/openssl\/include$/;"	m
OPENSSL_CFLAGS	Makefile	/^	OPENSSL_CFLAGS=-I\/usr\/local\/opt\/openssl\/include$/;"	m
OPENSSL_LDFLAGS	Makefile	/^	OPENSSL_LDFLAGS=-L\/opt\/homebrew\/opt\/openssl\/lib$/;"	m
OPENSSL_LDFLAGS	Makefile	/^	OPENSSL_LDFLAGS=-L\/usr\/local\/opt\/openssl\/lib$/;"	m
OPT	Makefile	/^OPT=$(OPTIMIZATION)$/;"	m
OPTIMIZATION	Makefile	/^OPTIMIZATION?=-O2$/;"	m
OPVAL_DIRTY_LL	t_zset.c	2041;"	d	file:
OPVAL_DIRTY_SDS	t_zset.c	2040;"	d	file:
OPVAL_VALID_LL	t_zset.c	2042;"	d	file:
OUTPUT_CSV	redis-cli.c	71;"	d	file:
OUTPUT_RAW	redis-cli.c	70;"	d	file:
OUTPUT_STANDARD	redis-cli.c	69;"	d	file:
OUT_OF_RANGE	listpack.c	868;"	d	file:
OUT_OF_RANGE	listpack.c	908;"	d	file:
OUT_OF_RANGE	ziplist.c	621;"	d	file:
OUT_OF_RANGE	ziplist.c	677;"	d	file:
OUT_OF_RANGE	zipmap.c	381;"	d	file:
OUT_OF_RANGE	zipmap.c	438;"	d	file:
PDP_ENDIAN	config.h	152;"	d
PIPEMODE_WRITE_LOOP_MAX_BYTES	redis-cli.c	7223;"	d	file:
PKG_CONFIG	Makefile	/^PKG_CONFIG?=pkg-config$/;"	m
POLY	crc64.c	33;"	d	file:
PREFIX	Makefile	/^PREFIX?=\/usr\/local$/;"	m
PREFIX_SIZE	zmalloc.c	52;"	d	file:
PREFIX_SIZE	zmalloc.c	56;"	d	file:
PREFIX_SIZE	zmalloc.c	58;"	d	file:
PROPAGATE_AOF	server.h	454;"	d
PROPAGATE_NONE	server.h	453;"	d
PROPAGATE_REPL	server.h	455;"	d
PROTO_DUMP_LEN	networking.c	1786;"	d	file:
PROTO_INLINE_MAX_SIZE	server.h	148;"	d
PROTO_IOBUF_LEN	server.h	146;"	d
PROTO_MBULK_BIG_ARG	server.h	149;"	d
PROTO_REPLY_CHUNK_BYTES	server.h	147;"	d
PROTO_REQ_INLINE	server.h	296;"	d
PROTO_REQ_MULTIBULK	server.h	297;"	d
PROTO_SHARED_SELECT_CMDS	server.h	99;"	d
PSYNC_CONTINUE	replication.c	2056;"	d	file:
PSYNC_FULLRESYNC	replication.c	2057;"	d	file:
PSYNC_NOT_SUPPORTED	replication.c	2058;"	d	file:
PSYNC_TRY_LATER	replication.c	2059;"	d	file:
PSYNC_WAIT_REPLY	replication.c	2055;"	d	file:
PSYNC_WRITE_ERROR	replication.c	2054;"	d	file:
PT	Makefile	/^	echo OPT=$(OPT) >> .make-settings$/;"	m
PendingEntryContext	defrag.c	/^} PendingEntryContext;$/;"	t	typeref:struct:__anon17	file:
PingReceiver	modules/hellocluster.c	/^void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {$/;"	f
PingallCommand_RedisCommand	modules/hellocluster.c	/^int PingallCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
PongReceiver	modules/hellocluster.c	/^void PongReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {$/;"	f
PrefixTable	tracking.c	/^rax *PrefixTable = NULL;$/;"	v
ProcessingEventsWhileBlocked	networking.c	/^int ProcessingEventsWhileBlocked = 0; \/* See processEventsWhileBlocked(). *\/$/;"	v
QL_BM_BITS	quicklist.h	86;"	d
QL_BM_BITS	quicklist.h	91;"	d
QL_COMP_BITS	quicklist.h	85;"	d
QL_COMP_BITS	quicklist.h	90;"	d
QL_FILL_BITS	quicklist.h	84;"	d
QL_FILL_BITS	quicklist.h	89;"	d
QL_MAX_BM	quicklist.c	76;"	d	file:
QL_TEST_VERBOSE	quicklist.c	1539;"	d	file:
QUICKLIST_HEAD	quicklist.h	134;"	d
QUICKLIST_NOCOMPRESS	quicklist.h	142;"	d
QUICKLIST_NODE_CONTAINER_NONE	quicklist.h	145;"	d
QUICKLIST_NODE_CONTAINER_ZIPLIST	quicklist.h	146;"	d
QUICKLIST_NODE_ENCODING_LZF	quicklist.h	139;"	d
QUICKLIST_NODE_ENCODING_RAW	quicklist.h	138;"	d
QUICKLIST_TAIL	quicklist.h	135;"	d
QUIET_CC	Makefile	/^QUIET_CC = @printf '    %b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;$/;"	m
QUIET_INSTALL	Makefile	/^QUIET_INSTALL = @printf '    %b %b\\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;$/;"	m
QUIET_LINK	Makefile	/^QUIET_LINK = @printf '    %b %b\\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;$/;"	m
R0	sha1.c	47;"	d	file:
R1	sha1.c	48;"	d	file:
R2	sha1.c	49;"	d	file:
R3	sha1.c	50;"	d	file:
R4	sha1.c	51;"	d	file:
RADIUS_COORDS	geo.c	502;"	d	file:
RADIUS_MEMBER	geo.c	503;"	d	file:
RADIUS_NOSTORE	geo.c	504;"	d	file:
RANDPTR_INITIAL_SIZE	redis-benchmark.c	65;"	d	file:
RANGEISZERO	geohash.h	44;"	d
RANGEPISZERO	geohash.h	45;"	d
RATIO	geohash_helper.c	45;"	d	file:
RAX_ALLOC_H	rax_malloc.h	39;"	d
RAX_H	rax.h	32;"	d
RAX_ITER_EOF	rax.h	172;"	d
RAX_ITER_JUST_SEEKED	rax.h	169;"	d
RAX_ITER_SAFE	rax.h	173;"	d
RAX_ITER_STATIC_LEN	rax.h	168;"	d
RAX_MALLOC_INCLUDE	rax.c	42;"	d	file:
RAX_NODE_MAX_SIZE	rax.h	97;"	d
RAX_STACK_STATIC_ITEMS	rax.h	142;"	d
RCVBUF_INIT_LEN	cluster.c	80;"	d	file:
RCVBUF_MAX_PREALLOC	cluster.c	81;"	d	file:
RDBFLAGS_ALLOW_DUP	rdb.h	128;"	d
RDBFLAGS_AOF_PREAMBLE	rdb.h	126;"	d
RDBFLAGS_NONE	rdb.h	125;"	d
RDBFLAGS_REPLICATION	rdb.h	127;"	d
RDBGeneratedByReplication	replication.c	/^int RDBGeneratedByReplication = 0;$/;"	v
RDB_14BITLEN	rdb.h	58;"	d
RDB_32BITLEN	rdb.h	59;"	d
RDB_64BITLEN	rdb.h	60;"	d
RDB_6BITLEN	rdb.h	57;"	d
RDB_CHECK_DOING_CHECK_SUM	redis-check-rdb.c	61;"	d	file:
RDB_CHECK_DOING_READ_AUX	redis-check-rdb.c	63;"	d	file:
RDB_CHECK_DOING_READ_EXPIRE	redis-check-rdb.c	58;"	d	file:
RDB_CHECK_DOING_READ_KEY	redis-check-rdb.c	59;"	d	file:
RDB_CHECK_DOING_READ_LEN	redis-check-rdb.c	62;"	d	file:
RDB_CHECK_DOING_READ_MODULE_AUX	redis-check-rdb.c	64;"	d	file:
RDB_CHECK_DOING_READ_OBJECT_VALUE	redis-check-rdb.c	60;"	d	file:
RDB_CHECK_DOING_READ_TYPE	redis-check-rdb.c	57;"	d	file:
RDB_CHECK_DOING_START	redis-check-rdb.c	56;"	d	file:
RDB_CHILD_TYPE_DISK	server.h	467;"	d
RDB_CHILD_TYPE_NONE	server.h	466;"	d
RDB_CHILD_TYPE_SOCKET	server.h	468;"	d
RDB_ENCVAL	rdb.h	61;"	d
RDB_ENC_INT16	rdb.h	68;"	d
RDB_ENC_INT32	rdb.h	69;"	d
RDB_ENC_INT8	rdb.h	67;"	d
RDB_ENC_LZF	rdb.h	70;"	d
RDB_EOF_MARK_SIZE	redis-cli.c	6987;"	d	file:
RDB_EOF_MARK_SIZE	server.h	107;"	d
RDB_LENERR	rdb.h	62;"	d
RDB_LOAD_ENC	rdb.h	120;"	d
RDB_LOAD_NONE	rdb.h	119;"	d
RDB_LOAD_PLAIN	rdb.h	121;"	d
RDB_LOAD_SDS	rdb.h	122;"	d
RDB_MODULE_OPCODE_DOUBLE	rdb.h	115;"	d
RDB_MODULE_OPCODE_EOF	rdb.h	111;"	d
RDB_MODULE_OPCODE_FLOAT	rdb.h	114;"	d
RDB_MODULE_OPCODE_SINT	rdb.h	112;"	d
RDB_MODULE_OPCODE_STRING	rdb.h	116;"	d
RDB_MODULE_OPCODE_UINT	rdb.h	113;"	d
RDB_OPCODE_AUX	rdb.h	103;"	d
RDB_OPCODE_EOF	rdb.h	108;"	d
RDB_OPCODE_EXPIRETIME	rdb.h	106;"	d
RDB_OPCODE_EXPIRETIME_MS	rdb.h	105;"	d
RDB_OPCODE_FREQ	rdb.h	102;"	d
RDB_OPCODE_IDLE	rdb.h	101;"	d
RDB_OPCODE_MODULE_AUX	rdb.h	100;"	d
RDB_OPCODE_RESIZEDB	rdb.h	104;"	d
RDB_OPCODE_SELECTDB	rdb.h	107;"	d
RDB_SAVE_INFO_INIT	server.h	1102;"	d
RDB_TYPE_HASH	rdb.h	79;"	d
RDB_TYPE_HASH_ZIPLIST	rdb.h	91;"	d
RDB_TYPE_HASH_ZIPMAP	rdb.h	87;"	d
RDB_TYPE_LIST	rdb.h	76;"	d
RDB_TYPE_LIST_QUICKLIST	rdb.h	92;"	d
RDB_TYPE_LIST_ZIPLIST	rdb.h	88;"	d
RDB_TYPE_MODULE	rdb.h	81;"	d
RDB_TYPE_MODULE_2	rdb.h	82;"	d
RDB_TYPE_SET	rdb.h	77;"	d
RDB_TYPE_SET_INTSET	rdb.h	89;"	d
RDB_TYPE_STREAM_LISTPACKS	rdb.h	93;"	d
RDB_TYPE_STRING	rdb.h	75;"	d
RDB_TYPE_ZSET	rdb.h	78;"	d
RDB_TYPE_ZSET_2	rdb.h	80;"	d
RDB_TYPE_ZSET_ZIPLIST	rdb.h	90;"	d
RDB_VERSION	rdb.h	41;"	d
RECTANGLE_TYPE	geohash.h	94;"	d
REDISMODULE_AM_DICT	module.c	124;"	d	file:
REDISMODULE_AM_FREED	module.c	123;"	d	file:
REDISMODULE_AM_INFO	module.c	125;"	d	file:
REDISMODULE_AM_KEY	module.c	120;"	d	file:
REDISMODULE_AM_REPLY	module.c	122;"	d	file:
REDISMODULE_AM_STRING	module.c	121;"	d	file:
REDISMODULE_API	redismodule.h	571;"	d
REDISMODULE_APIVER_1	redismodule.h	15;"	d
REDISMODULE_ARGV_NO_AOF	module.c	373;"	d	file:
REDISMODULE_ARGV_NO_REPLICAS	module.c	374;"	d	file:
REDISMODULE_ARGV_REPLICATE	module.c	372;"	d	file:
REDISMODULE_ATTR	redismodule.h	576;"	d
REDISMODULE_ATTR_COMMON	redismodule.h	498;"	d
REDISMODULE_ATTR_COMMON	redismodule.h	500;"	d
REDISMODULE_ATTR_PRINTF	redismodule.h	490;"	d
REDISMODULE_ATTR_PRINTF	redismodule.h	492;"	d
REDISMODULE_ATTR_UNUSED	redismodule.h	482;"	d
REDISMODULE_ATTR_UNUSED	redismodule.h	484;"	d
REDISMODULE_AUX_AFTER_RDB	redismodule.h	205;"	d
REDISMODULE_AUX_AFTER_RDB	server.h	536;"	d
REDISMODULE_AUX_BEFORE_RDB	redismodule.h	204;"	d
REDISMODULE_AUX_BEFORE_RDB	server.h	535;"	d
REDISMODULE_CLIENTINFO_FLAG_BLOCKED	redismodule.h	370;"	d
REDISMODULE_CLIENTINFO_FLAG_MULTI	redismodule.h	373;"	d
REDISMODULE_CLIENTINFO_FLAG_PUBSUB	redismodule.h	369;"	d
REDISMODULE_CLIENTINFO_FLAG_SSL	redismodule.h	368;"	d
REDISMODULE_CLIENTINFO_FLAG_TRACKING	redismodule.h	371;"	d
REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET	redismodule.h	372;"	d
REDISMODULE_CLIENTINFO_VERSION	redismodule.h	390;"	d
REDISMODULE_CLUSTER_FLAG_NONE	redismodule.h	191;"	d
REDISMODULE_CLUSTER_FLAG_NO_FAILOVER	redismodule.h	192;"	d
REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION	redismodule.h	193;"	d
REDISMODULE_CMDFILTER_NOSELF	redismodule.h	216;"	d
REDISMODULE_CORE	server.h	78;"	d
REDISMODULE_CRON_LOOP_VERSION	redismodule.h	440;"	d
REDISMODULE_CTX_AUTO_MEMORY	module.c	189;"	d	file:
REDISMODULE_CTX_BLOCKED_DISCONNECTED	module.c	194;"	d	file:
REDISMODULE_CTX_BLOCKED_REPLY	module.c	191;"	d	file:
REDISMODULE_CTX_BLOCKED_TIMEOUT	module.c	192;"	d	file:
REDISMODULE_CTX_FLAGS_ACTIVE_CHILD	redismodule.h	133;"	d
REDISMODULE_CTX_FLAGS_AOF	redismodule.h	103;"	d
REDISMODULE_CTX_FLAGS_CLUSTER	redismodule.h	101;"	d
REDISMODULE_CTX_FLAGS_DENY_BLOCKING	redismodule.h	140;"	d
REDISMODULE_CTX_FLAGS_EVICT	redismodule.h	109;"	d
REDISMODULE_CTX_FLAGS_IS_CHILD	redismodule.h	137;"	d
REDISMODULE_CTX_FLAGS_LOADING	redismodule.h	117;"	d
REDISMODULE_CTX_FLAGS_LUA	redismodule.h	91;"	d
REDISMODULE_CTX_FLAGS_MASTER	redismodule.h	95;"	d
REDISMODULE_CTX_FLAGS_MAXMEMORY	redismodule.h	107;"	d
REDISMODULE_CTX_FLAGS_MULTI	redismodule.h	93;"	d
REDISMODULE_CTX_FLAGS_MULTI_DIRTY	redismodule.h	135;"	d
REDISMODULE_CTX_FLAGS_OOM	redismodule.h	111;"	d
REDISMODULE_CTX_FLAGS_OOM_WARNING	redismodule.h	113;"	d
REDISMODULE_CTX_FLAGS_RDB	redismodule.h	105;"	d
REDISMODULE_CTX_FLAGS_READONLY	redismodule.h	99;"	d
REDISMODULE_CTX_FLAGS_REPLICATED	redismodule.h	115;"	d
REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING	redismodule.h	127;"	d
REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE	redismodule.h	131;"	d
REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE	redismodule.h	124;"	d
REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING	redismodule.h	129;"	d
REDISMODULE_CTX_FLAGS_SLAVE	redismodule.h	97;"	d
REDISMODULE_CTX_INIT	module.c	188;"	d	file:
REDISMODULE_CTX_KEYS_POS_REQUEST	module.c	190;"	d	file:
REDISMODULE_CTX_MODULE_COMMAND_CALL	module.c	195;"	d	file:
REDISMODULE_CTX_MULTI_EMITTED	module.c	196;"	d	file:
REDISMODULE_CTX_THREAD_SAFE	module.c	193;"	d	file:
REDISMODULE_ERR	redismodule.h	12;"	d
REDISMODULE_ERRORMSG_WRONGTYPE	redismodule.h	177;"	d
REDISMODULE_EVENT_CLIENT_CHANGE	redismodule.h	232;"	d
REDISMODULE_EVENT_CRON_LOOP	redismodule.h	236;"	d
REDISMODULE_EVENT_FLUSHDB	redismodule.h	230;"	d
REDISMODULE_EVENT_FORK_CHILD	redismodule.h	241;"	d
REDISMODULE_EVENT_LOADING	redismodule.h	231;"	d
REDISMODULE_EVENT_LOADING_PROGRESS	redismodule.h	238;"	d
REDISMODULE_EVENT_MASTER_LINK_CHANGE	redismodule.h	235;"	d
REDISMODULE_EVENT_MODULE_CHANGE	redismodule.h	237;"	d
REDISMODULE_EVENT_PERSISTENCE	redismodule.h	229;"	d
REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED	redismodule.h	228;"	d
REDISMODULE_EVENT_REPLICA_CHANGE	redismodule.h	234;"	d
REDISMODULE_EVENT_REPLROLECHANGED_NOW_MASTER	redismodule.h	338;"	d
REDISMODULE_EVENT_REPLROLECHANGED_NOW_REPLICA	redismodule.h	339;"	d
REDISMODULE_EVENT_REPL_BACKUP	redismodule.h	240;"	d
REDISMODULE_EVENT_SHUTDOWN	redismodule.h	233;"	d
REDISMODULE_EVENT_SWAPDB	redismodule.h	239;"	d
REDISMODULE_EXPERIMENTAL_API	modules/helloacl.c	34;"	d	file:
REDISMODULE_EXPERIMENTAL_API	modules/helloblock.c	34;"	d	file:
REDISMODULE_EXPERIMENTAL_API	modules/hellocluster.c	33;"	d	file:
REDISMODULE_EXPERIMENTAL_API	modules/hellodict.c	36;"	d	file:
REDISMODULE_EXPERIMENTAL_API	modules/hellohook.c	33;"	d	file:
REDISMODULE_EXPERIMENTAL_API	modules/hellotimer.c	33;"	d	file:
REDISMODULE_EXPERIMENTAL_API	modules/testmodule.c	33;"	d	file:
REDISMODULE_EXPERIMENTAL_API_VERSION	redismodule.h	782;"	d
REDISMODULE_FLUSHINFO_VERSION	redismodule.h	418;"	d
REDISMODULE_GET_API	redismodule.h	566;"	d
REDISMODULE_H	redismodule.h	2;"	d
REDISMODULE_HASH_CFIELDS	redismodule.h	69;"	d
REDISMODULE_HASH_COUNT_ALL	redismodule.h	71;"	d
REDISMODULE_HASH_DELETE	redismodule.h	174;"	d
REDISMODULE_HASH_EXISTS	redismodule.h	70;"	d
REDISMODULE_HASH_NONE	redismodule.h	66;"	d
REDISMODULE_HASH_NX	redismodule.h	67;"	d
REDISMODULE_HASH_XX	redismodule.h	68;"	d
REDISMODULE_KEYTYPE_EMPTY	redismodule.h	33;"	d
REDISMODULE_KEYTYPE_HASH	redismodule.h	36;"	d
REDISMODULE_KEYTYPE_LIST	redismodule.h	35;"	d
REDISMODULE_KEYTYPE_MODULE	redismodule.h	39;"	d
REDISMODULE_KEYTYPE_SET	redismodule.h	37;"	d
REDISMODULE_KEYTYPE_STREAM	redismodule.h	40;"	d
REDISMODULE_KEYTYPE_STRING	redismodule.h	34;"	d
REDISMODULE_KEYTYPE_ZSET	redismodule.h	38;"	d
REDISMODULE_LIST_HEAD	redismodule.h	29;"	d
REDISMODULE_LIST_TAIL	redismodule.h	30;"	d
REDISMODULE_LOADING_PROGRESS_VERSION	redismodule.h	450;"	d
REDISMODULE_LOGLEVEL_DEBUG	redismodule.h	198;"	d
REDISMODULE_LOGLEVEL_NOTICE	redismodule.h	200;"	d
REDISMODULE_LOGLEVEL_VERBOSE	redismodule.h	199;"	d
REDISMODULE_LOGLEVEL_WARNING	redismodule.h	201;"	d
REDISMODULE_MODULE_CHANGE_VERSION	redismodule.h	429;"	d
REDISMODULE_NEGATIVE_INFINITE	redismodule.h	180;"	d
REDISMODULE_NODE_FAIL	redismodule.h	188;"	d
REDISMODULE_NODE_ID_LEN	redismodule.h	183;"	d
REDISMODULE_NODE_MASTER	redismodule.h	185;"	d
REDISMODULE_NODE_MYSELF	redismodule.h	184;"	d
REDISMODULE_NODE_NOFAILOVER	redismodule.h	189;"	d
REDISMODULE_NODE_PFAIL	redismodule.h	187;"	d
REDISMODULE_NODE_SLAVE	redismodule.h	186;"	d
REDISMODULE_NOTIFY_ALL	redismodule.h	170;"	d
REDISMODULE_NOTIFY_EVICTED	redismodule.h	159;"	d
REDISMODULE_NOTIFY_EXPIRED	redismodule.h	158;"	d
REDISMODULE_NOTIFY_GENERIC	redismodule.h	152;"	d
REDISMODULE_NOTIFY_HASH	redismodule.h	156;"	d
REDISMODULE_NOTIFY_KEYEVENT	redismodule.h	151;"	d
REDISMODULE_NOTIFY_KEYSPACE	redismodule.h	150;"	d
REDISMODULE_NOTIFY_KEY_MISS	redismodule.h	161;"	d
REDISMODULE_NOTIFY_LIST	redismodule.h	154;"	d
REDISMODULE_NOTIFY_LOADED	redismodule.h	162;"	d
REDISMODULE_NOTIFY_MODULE	redismodule.h	163;"	d
REDISMODULE_NOTIFY_SET	redismodule.h	155;"	d
REDISMODULE_NOTIFY_STREAM	redismodule.h	160;"	d
REDISMODULE_NOTIFY_STRING	redismodule.h	153;"	d
REDISMODULE_NOTIFY_ZSET	redismodule.h	157;"	d
REDISMODULE_NOT_USED	redismodule.h	195;"	d
REDISMODULE_NO_EXPIRE	redismodule.h	54;"	d
REDISMODULE_OK	redismodule.h	11;"	d
REDISMODULE_OPEN_KEY_NOTOUCH	redismodule.h	27;"	d
REDISMODULE_OPTIONS_HANDLE_IO_ERRORS	redismodule.h	219;"	d
REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED	redismodule.h	223;"	d
REDISMODULE_POOL_ALLOC_ALIGN	module.c	141;"	d	file:
REDISMODULE_POOL_ALLOC_MIN_SIZE	module.c	140;"	d	file:
REDISMODULE_POSITIVE_INFINITE	redismodule.h	179;"	d
REDISMODULE_POSTPONED_ARRAY_LEN	redismodule.h	51;"	d
REDISMODULE_READ	redismodule.h	22;"	d
REDISMODULE_REPLICATIONINFO_VERSION	redismodule.h	402;"	d
REDISMODULE_REPLYFLAG_NESTED	module.c	251;"	d	file:
REDISMODULE_REPLYFLAG_NONE	module.c	249;"	d	file:
REDISMODULE_REPLYFLAG_TOPARSE	module.c	250;"	d	file:
REDISMODULE_REPLY_ARRAY	redismodule.h	47;"	d
REDISMODULE_REPLY_ERROR	redismodule.h	45;"	d
REDISMODULE_REPLY_INTEGER	redismodule.h	46;"	d
REDISMODULE_REPLY_NULL	redismodule.h	48;"	d
REDISMODULE_REPLY_STRING	redismodule.h	44;"	d
REDISMODULE_REPLY_UNKNOWN	redismodule.h	43;"	d
REDISMODULE_STREAM_ADD_AUTOID	redismodule.h	80;"	d
REDISMODULE_STREAM_ITERATOR_EXCLUSIVE	redismodule.h	82;"	d
REDISMODULE_STREAM_ITERATOR_REVERSE	redismodule.h	83;"	d
REDISMODULE_STREAM_TRIM_APPROX	redismodule.h	85;"	d
REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED	redismodule.h	326;"	d
REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED	redismodule.h	327;"	d
REDISMODULE_SUBEVENT_FLUSHDB_END	redismodule.h	343;"	d
REDISMODULE_SUBEVENT_FLUSHDB_START	redismodule.h	342;"	d
REDISMODULE_SUBEVENT_FORK_CHILD_BORN	redismodule.h	359;"	d
REDISMODULE_SUBEVENT_FORK_CHILD_DIED	redismodule.h	360;"	d
REDISMODULE_SUBEVENT_LOADING_AOF_START	redismodule.h	320;"	d
REDISMODULE_SUBEVENT_LOADING_ENDED	redismodule.h	322;"	d
REDISMODULE_SUBEVENT_LOADING_FAILED	redismodule.h	323;"	d
REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF	redismodule.h	351;"	d
REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB	redismodule.h	350;"	d
REDISMODULE_SUBEVENT_LOADING_RDB_START	redismodule.h	319;"	d
REDISMODULE_SUBEVENT_LOADING_REPL_START	redismodule.h	321;"	d
REDISMODULE_SUBEVENT_MASTER_LINK_DOWN	redismodule.h	331;"	d
REDISMODULE_SUBEVENT_MASTER_LINK_UP	redismodule.h	330;"	d
REDISMODULE_SUBEVENT_MODULE_LOADED	redismodule.h	346;"	d
REDISMODULE_SUBEVENT_MODULE_UNLOADED	redismodule.h	347;"	d
REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START	redismodule.h	313;"	d
REDISMODULE_SUBEVENT_PERSISTENCE_ENDED	redismodule.h	315;"	d
REDISMODULE_SUBEVENT_PERSISTENCE_FAILED	redismodule.h	316;"	d
REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START	redismodule.h	312;"	d
REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START	redismodule.h	314;"	d
REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE	redismodule.h	335;"	d
REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE	redismodule.h	334;"	d
REDISMODULE_SUBEVENT_REPL_BACKUP_CREATE	redismodule.h	354;"	d
REDISMODULE_SUBEVENT_REPL_BACKUP_DISCARD	redismodule.h	356;"	d
REDISMODULE_SUBEVENT_REPL_BACKUP_RESTORE	redismodule.h	355;"	d
REDISMODULE_SWAPDBINFO_VERSION	redismodule.h	462;"	d
REDISMODULE_TYPE_ENCVER	server.h	531;"	d
REDISMODULE_TYPE_ENCVER_BITS	server.h	529;"	d
REDISMODULE_TYPE_ENCVER_MASK	server.h	530;"	d
REDISMODULE_TYPE_METHOD_VERSION	redismodule.h	19;"	d
REDISMODULE_TYPE_SIGN	server.h	532;"	d
REDISMODULE_WRITE	redismodule.h	23;"	d
REDISMODULE_ZADD_ADDED	redismodule.h	59;"	d
REDISMODULE_ZADD_GT	redismodule.h	62;"	d
REDISMODULE_ZADD_LT	redismodule.h	63;"	d
REDISMODULE_ZADD_NOP	redismodule.h	61;"	d
REDISMODULE_ZADD_NX	redismodule.h	58;"	d
REDISMODULE_ZADD_UPDATED	redismodule.h	60;"	d
REDISMODULE_ZADD_XX	redismodule.h	57;"	d
REDISMODULE_ZSET_RANGE_LEX	module.c	231;"	d	file:
REDISMODULE_ZSET_RANGE_NONE	module.c	230;"	d	file:
REDISMODULE_ZSET_RANGE_POS	module.c	233;"	d	file:
REDISMODULE_ZSET_RANGE_SCORE	module.c	232;"	d	file:
REDIS_AGGR_MAX	t_zset.c	2344;"	d	file:
REDIS_AGGR_MIN	t_zset.c	2343;"	d	file:
REDIS_AGGR_SUM	t_zset.c	2342;"	d	file:
REDIS_ATOMIC_API	atomicvar.h	106;"	d
REDIS_ATOMIC_API	atomicvar.h	127;"	d
REDIS_ATOMIC_API	atomicvar.h	152;"	d
REDIS_AUTOSYNC_BYTES	server.h	151;"	d
REDIS_BENCHMARK_NAME	Makefile	/^REDIS_BENCHMARK_NAME=redis-benchmark$(PROG_SUFFIX)$/;"	m
REDIS_BENCHMARK_OBJ	Makefile	/^REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o dict.o zmalloc.o release.o crcspeed.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o$/;"	m
REDIS_BUILD_ID	release.h	3;"	d
REDIS_CC	Makefile	/^REDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)$/;"	m
REDIS_CHECK_AOF_NAME	Makefile	/^REDIS_CHECK_AOF_NAME=redis-check-aof$(PROG_SUFFIX)$/;"	m
REDIS_CHECK_RDB_NAME	Makefile	/^REDIS_CHECK_RDB_NAME=redis-check-rdb$(PROG_SUFFIX)$/;"	m
REDIS_CLI_AUTH_ENV	redis-cli.c	78;"	d	file:
REDIS_CLI_CLUSTER_YES_ENV	redis-cli.c	79;"	d	file:
REDIS_CLI_DEFAULT_PIPE_TIMEOUT	redis-cli.c	73;"	d	file:
REDIS_CLI_HISTFILE_DEFAULT	redis-cli.c	75;"	d	file:
REDIS_CLI_HISTFILE_ENV	redis-cli.c	74;"	d	file:
REDIS_CLI_KEEPALIVE_INTERVAL	redis-cli.c	72;"	d	file:
REDIS_CLI_NAME	Makefile	/^REDIS_CLI_NAME=redis-cli$(PROG_SUFFIX)$/;"	m
REDIS_CLI_OBJ	Makefile	/^REDIS_CLI_OBJ=anet.o adlist.o dict.o redis-cli.o zmalloc.o release.o ae.o crcspeed.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o$/;"	m
REDIS_CLI_RCFILE_DEFAULT	redis-cli.c	77;"	d	file:
REDIS_CLI_RCFILE_ENV	redis-cli.c	76;"	d	file:
REDIS_COMPARE_BINARY	object.c	530;"	d	file:
REDIS_COMPARE_COLL	object.c	531;"	d	file:
REDIS_CONFIG_REWRITE_SIGNATURE	config.c	1056;"	d	file:
REDIS_GIT_DIRTY	release.h	2;"	d
REDIS_GIT_SHA1	release.h	1;"	d
REDIS_INSTALL	Makefile	/^REDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)$/;"	m
REDIS_LD	Makefile	/^REDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)$/;"	m
REDIS_LRAND48_MAX	rand.h	36;"	d
REDIS_RANDOM_H	rand.h	31;"	d
REDIS_SENTINEL_NAME	Makefile	/^REDIS_SENTINEL_NAME=redis-sentinel$(PROG_SUFFIX)$/;"	m
REDIS_SENTINEL_PORT	sentinel.c	52;"	d	file:
REDIS_SERVER_NAME	Makefile	/^REDIS_SERVER_NAME=redis-server$(PROG_SUFFIX)$/;"	m
REDIS_SERVER_OBJ	Makefile	/^REDIS_SERVER_OBJ=server.o $/;"	m
REDIS_STATIC	quicklist.c	45;"	d	file:
REDIS_THREAD_STACK_SIZE	bio.c	91;"	d	file:
REDIS_TLS_PROTO_DEFAULT	tls.c	50;"	d	file:
REDIS_TLS_PROTO_DEFAULT	tls.c	52;"	d	file:
REDIS_TLS_PROTO_TLSv1	tls.c	43;"	d	file:
REDIS_TLS_PROTO_TLSv1_1	tls.c	44;"	d	file:
REDIS_TLS_PROTO_TLSv1_2	tls.c	45;"	d	file:
REDIS_TLS_PROTO_TLSv1_3	tls.c	46;"	d	file:
REDIS_VERSION	version.h	1;"	d
REDIS_VERSION_NUM	version.h	2;"	d
REGISTER_API	module.c	8406;"	d	file:
REPL_DISKLESS_LOAD_DISABLED	server.h	389;"	d
REPL_DISKLESS_LOAD_SWAPDB	server.h	391;"	d
REPL_DISKLESS_LOAD_WHEN_DB_EMPTY	server.h	390;"	d
REPL_MAX_WRITTEN_BEFORE_FSYNC	replication.c	1542;"	d	file:
REPL_STATE_CONNECT	server.h	/^    REPL_STATE_CONNECT,             \/* Must connect to master *\/$/;"	e	enum:__anon42
REPL_STATE_CONNECTED	server.h	/^    REPL_STATE_CONNECTED,       \/* Connected to master *\/$/;"	e	enum:__anon42
REPL_STATE_CONNECTING	server.h	/^    REPL_STATE_CONNECTING,          \/* Connecting to master *\/$/;"	e	enum:__anon42
REPL_STATE_NONE	server.h	/^    REPL_STATE_NONE = 0,            \/* No active replication *\/$/;"	e	enum:__anon42
REPL_STATE_RECEIVE_AUTH_REPLY	server.h	/^    REPL_STATE_RECEIVE_AUTH_REPLY,  \/* Wait for AUTH reply *\/$/;"	e	enum:__anon42
REPL_STATE_RECEIVE_CAPA_REPLY	server.h	/^    REPL_STATE_RECEIVE_CAPA_REPLY,  \/* Wait for REPLCONF reply *\/$/;"	e	enum:__anon42
REPL_STATE_RECEIVE_IP_REPLY	server.h	/^    REPL_STATE_RECEIVE_IP_REPLY,    \/* Wait for REPLCONF reply *\/$/;"	e	enum:__anon42
REPL_STATE_RECEIVE_PING_REPLY	server.h	/^    REPL_STATE_RECEIVE_PING_REPLY,  \/* Wait for PING reply *\/$/;"	e	enum:__anon42
REPL_STATE_RECEIVE_PORT_REPLY	server.h	/^    REPL_STATE_RECEIVE_PORT_REPLY,  \/* Wait for REPLCONF reply *\/$/;"	e	enum:__anon42
REPL_STATE_RECEIVE_PSYNC_REPLY	server.h	/^    REPL_STATE_RECEIVE_PSYNC_REPLY, \/* Wait for PSYNC reply *\/$/;"	e	enum:__anon42
REPL_STATE_SEND_HANDSHAKE	server.h	/^    REPL_STATE_SEND_HANDSHAKE,      \/* Send handshake sequance to master *\/$/;"	e	enum:__anon42
REPL_STATE_SEND_PSYNC	server.h	/^    REPL_STATE_SEND_PSYNC,          \/* Send PSYNC *\/$/;"	e	enum:__anon42
REPL_STATE_TRANSFER	server.h	/^    REPL_STATE_TRANSFER,        \/* Receiving .rdb from master *\/$/;"	e	enum:__anon42
REST	rand.c	64;"	d	file:
RESTART_SERVER_CONFIG_REWRITE	server.h	2254;"	d
RESTART_SERVER_GRACEFULLY	server.h	2253;"	d
RESTART_SERVER_NONE	server.h	2252;"	d
REV_FINAL_CFLAGS	Makefile	/^	echo PREV_FINAL_CFLAGS=$(FINAL_CFLAGS) >> .make-settings$/;"	m
REV_FINAL_LDFLAGS	Makefile	/^	echo PREV_FINAL_LDFLAGS=$(FINAL_LDFLAGS) >> .make-settings$/;"	m
RIO_FLAG_READ_ERROR	rio.h	40;"	d
RIO_FLAG_WRITE_ERROR	rio.h	41;"	d
RMAPI_FUNC_SUPPORTED	redismodule.h	1126;"	d
RM_AbortBlock	module.c	/^int RM_AbortBlock(RedisModuleBlockedClient *bc) {$/;"	f
RM_Alloc	module.c	/^void *RM_Alloc(size_t bytes) {$/;"	f
RM_AuthenticateClientWithACLUser	module.c	/^int RM_AuthenticateClientWithACLUser(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {$/;"	f
RM_AuthenticateClientWithUser	module.c	/^int RM_AuthenticateClientWithUser(RedisModuleCtx *ctx, RedisModuleUser *module_user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {$/;"	f
RM_AutoMemory	module.c	/^void RM_AutoMemory(RedisModuleCtx *ctx) {$/;"	f
RM_AvoidReplicaTraffic	module.c	/^int RM_AvoidReplicaTraffic() {$/;"	f
RM_BlockClient	module.c	/^RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) {$/;"	f
RM_BlockClientOnKeys	module.c	/^RedisModuleBlockedClient *RM_BlockClientOnKeys(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) {$/;"	f
RM_BlockedClientDisconnected	module.c	/^int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {$/;"	f
RM_BlockedClientMeasureTimeEnd	module.c	/^int RM_BlockedClientMeasureTimeEnd(RedisModuleBlockedClient *bc) {$/;"	f
RM_BlockedClientMeasureTimeStart	module.c	/^int RM_BlockedClientMeasureTimeStart(RedisModuleBlockedClient *bc) {$/;"	f
RM_Call	module.c	/^RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {$/;"	f
RM_CallReplyArrayElement	module.c	/^RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {$/;"	f
RM_CallReplyInteger	module.c	/^long long RM_CallReplyInteger(RedisModuleCallReply *reply) {$/;"	f
RM_CallReplyLength	module.c	/^size_t RM_CallReplyLength(RedisModuleCallReply *reply) {$/;"	f
RM_CallReplyProto	module.c	/^const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {$/;"	f
RM_CallReplyStringPtr	module.c	/^const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {$/;"	f
RM_CallReplyType	module.c	/^int RM_CallReplyType(RedisModuleCallReply *reply) {$/;"	f
RM_Calloc	module.c	/^void *RM_Calloc(size_t nmemb, size_t size) {$/;"	f
RM_CloseKey	module.c	/^void RM_CloseKey(RedisModuleKey *key) {$/;"	f
RM_CommandFilterArgDelete	module.c	/^int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)$/;"	f
RM_CommandFilterArgGet	module.c	/^const RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)$/;"	f
RM_CommandFilterArgInsert	module.c	/^int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)$/;"	f
RM_CommandFilterArgReplace	module.c	/^int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)$/;"	f
RM_CommandFilterArgsCount	module.c	/^int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)$/;"	f
RM_CreateCommand	module.c	/^int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {$/;"	f
RM_CreateDataType	module.c	/^moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {$/;"	f
RM_CreateDict	module.c	/^RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {$/;"	f
RM_CreateModuleUser	module.c	/^RedisModuleUser *RM_CreateModuleUser(const char *name) {$/;"	f
RM_CreateString	module.c	/^RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {$/;"	f
RM_CreateStringFromCallReply	module.c	/^RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {$/;"	f
RM_CreateStringFromDouble	module.c	/^RedisModuleString *RM_CreateStringFromDouble(RedisModuleCtx *ctx, double d) {$/;"	f
RM_CreateStringFromLongDouble	module.c	/^RedisModuleString *RM_CreateStringFromLongDouble(RedisModuleCtx *ctx, long double ld, int humanfriendly) {$/;"	f
RM_CreateStringFromLongLong	module.c	/^RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {$/;"	f
RM_CreateStringFromStreamID	module.c	/^RedisModuleString *RM_CreateStringFromStreamID(RedisModuleCtx *ctx, const RedisModuleStreamID *id) {$/;"	f
RM_CreateStringFromString	module.c	/^RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {$/;"	f
RM_CreateStringPrintf	module.c	/^RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {$/;"	f
RM_CreateTimer	module.c	/^RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {$/;"	f
RM_DbSize	module.c	/^unsigned long long RM_DbSize(RedisModuleCtx *ctx) {$/;"	f
RM_DeauthenticateAndCloseClient	module.c	/^int RM_DeauthenticateAndCloseClient(RedisModuleCtx *ctx, uint64_t client_id) {$/;"	f
RM_DefragAlloc	module.c	/^void *RM_DefragAlloc(RedisModuleDefragCtx *ctx, void *ptr) {$/;"	f
RM_DefragCursorGet	module.c	/^int RM_DefragCursorGet(RedisModuleDefragCtx *ctx, unsigned long *cursor) {$/;"	f
RM_DefragCursorSet	module.c	/^int RM_DefragCursorSet(RedisModuleDefragCtx *ctx, unsigned long cursor) {$/;"	f
RM_DefragRedisModuleString	module.c	/^RedisModuleString *RM_DefragRedisModuleString(RedisModuleDefragCtx *ctx, RedisModuleString *str) {$/;"	f
RM_DefragShouldStop	module.c	/^int RM_DefragShouldStop(RedisModuleDefragCtx *ctx) {$/;"	f
RM_DeleteKey	module.c	/^int RM_DeleteKey(RedisModuleKey *key) {$/;"	f
RM_DictCompare	module.c	/^int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {$/;"	f
RM_DictCompareC	module.c	/^int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {$/;"	f
RM_DictDel	module.c	/^int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {$/;"	f
RM_DictDelC	module.c	/^int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {$/;"	f
RM_DictGet	module.c	/^void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {$/;"	f
RM_DictGetC	module.c	/^void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {$/;"	f
RM_DictIteratorReseek	module.c	/^int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {$/;"	f
RM_DictIteratorReseekC	module.c	/^int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {$/;"	f
RM_DictIteratorStart	module.c	/^RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {$/;"	f
RM_DictIteratorStartC	module.c	/^RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {$/;"	f
RM_DictIteratorStop	module.c	/^void RM_DictIteratorStop(RedisModuleDictIter *di) {$/;"	f
RM_DictNext	module.c	/^RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {$/;"	f
RM_DictNextC	module.c	/^void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {$/;"	f
RM_DictPrev	module.c	/^RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {$/;"	f
RM_DictPrevC	module.c	/^void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {$/;"	f
RM_DictReplace	module.c	/^int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {$/;"	f
RM_DictReplaceC	module.c	/^int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {$/;"	f
RM_DictSet	module.c	/^int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {$/;"	f
RM_DictSetC	module.c	/^int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {$/;"	f
RM_DictSize	module.c	/^uint64_t RM_DictSize(RedisModuleDict *d) {$/;"	f
RM_DigestAddLongLong	module.c	/^void RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {$/;"	f
RM_DigestAddStringBuffer	module.c	/^void RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {$/;"	f
RM_DigestEndSequence	module.c	/^void RM_DigestEndSequence(RedisModuleDigest *md) {$/;"	f
RM_EmitAOF	module.c	/^void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {$/;"	f
RM_ExitFromChild	module.c	/^int RM_ExitFromChild(int retcode) {$/;"	f
RM_ExportSharedAPI	module.c	/^int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {$/;"	f
RM_Fork	module.c	/^int RM_Fork(RedisModuleForkDoneHandler cb, void *user_data) {$/;"	f
RM_Free	module.c	/^void RM_Free(void *ptr) {$/;"	f
RM_FreeCallReply	module.c	/^void RM_FreeCallReply(RedisModuleCallReply *reply) {$/;"	f
RM_FreeClusterNodesList	module.c	/^void RM_FreeClusterNodesList(char **ids) {$/;"	f
RM_FreeDict	module.c	/^void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {$/;"	f
RM_FreeModuleUser	module.c	/^int RM_FreeModuleUser(RedisModuleUser *user) {$/;"	f
RM_FreeServerInfo	module.c	/^void RM_FreeServerInfo(RedisModuleCtx *ctx, RedisModuleServerInfoData *data) {$/;"	f
RM_FreeString	module.c	/^void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f
RM_FreeThreadSafeContext	module.c	/^void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {$/;"	f
RM_GetAbsExpire	module.c	/^mstime_t RM_GetAbsExpire(RedisModuleKey *key) {$/;"	f
RM_GetApi	module.c	/^int RM_GetApi(const char *funcname, void **targetPtrPtr) {$/;"	f
RM_GetBlockedClientHandle	module.c	/^RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {$/;"	f
RM_GetBlockedClientPrivateData	module.c	/^void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {$/;"	f
RM_GetBlockedClientReadyKey	module.c	/^RedisModuleString *RM_GetBlockedClientReadyKey(RedisModuleCtx *ctx) {$/;"	f
RM_GetClientCertificate	module.c	/^RedisModuleString *RM_GetClientCertificate(RedisModuleCtx *ctx, uint64_t client_id) {$/;"	f
RM_GetClientId	module.c	/^unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {$/;"	f
RM_GetClientInfoById	module.c	/^int RM_GetClientInfoById(void *ci, uint64_t id) {$/;"	f
RM_GetClientUserNameById	module.c	/^RedisModuleString *RM_GetClientUserNameById(RedisModuleCtx *ctx, uint64_t id) {$/;"	f
RM_GetClusterNodeInfo	module.c	/^int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {$/;"	f
RM_GetClusterNodesList	module.c	/^char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {$/;"	f
RM_GetClusterSize	module.c	/^size_t RM_GetClusterSize(void) {$/;"	f
RM_GetCommandKeys	module.c	/^int *RM_GetCommandKeys(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys) {$/;"	f
RM_GetContextFlags	module.c	/^int RM_GetContextFlags(RedisModuleCtx *ctx) {$/;"	f
RM_GetContextFlagsAll	module.c	/^int RM_GetContextFlagsAll() {$/;"	f
RM_GetContextFromIO	module.c	/^RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {$/;"	f
RM_GetDetachedThreadSafeContext	module.c	/^RedisModuleCtx *RM_GetDetachedThreadSafeContext(RedisModuleCtx *ctx) {$/;"	f
RM_GetExpire	module.c	/^mstime_t RM_GetExpire(RedisModuleKey *key) {$/;"	f
RM_GetKeyNameFromIO	module.c	/^const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {$/;"	f
RM_GetKeyNameFromModuleKey	module.c	/^const RedisModuleString *RM_GetKeyNameFromModuleKey(RedisModuleKey *key) {$/;"	f
RM_GetKeyspaceNotificationFlagsAll	module.c	/^int RM_GetKeyspaceNotificationFlagsAll() {$/;"	f
RM_GetLFU	module.c	/^int RM_GetLFU(RedisModuleKey *key, long long *lfu_freq) {$/;"	f
RM_GetLRU	module.c	/^int RM_GetLRU(RedisModuleKey *key, mstime_t *lru_idle) {$/;"	f
RM_GetMyClusterID	module.c	/^const char *RM_GetMyClusterID(void) {$/;"	f
RM_GetNotifyKeyspaceEvents	module.c	/^int RM_GetNotifyKeyspaceEvents() {$/;"	f
RM_GetRandomBytes	module.c	/^void RM_GetRandomBytes(unsigned char *dst, size_t len) {$/;"	f
RM_GetRandomHexChars	module.c	/^void RM_GetRandomHexChars(char *dst, size_t len) {$/;"	f
RM_GetSelectedDb	module.c	/^int RM_GetSelectedDb(RedisModuleCtx *ctx) {$/;"	f
RM_GetServerInfo	module.c	/^RedisModuleServerInfoData *RM_GetServerInfo(RedisModuleCtx *ctx, const char *section) {$/;"	f
RM_GetServerVersion	module.c	/^int RM_GetServerVersion() {$/;"	f
RM_GetSharedAPI	module.c	/^void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {$/;"	f
RM_GetThreadSafeContext	module.c	/^RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {$/;"	f
RM_GetTimerInfo	module.c	/^int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {$/;"	f
RM_GetTypeMethodVersion	module.c	/^int RM_GetTypeMethodVersion() {$/;"	f
RM_GetUsedMemoryRatio	module.c	/^float RM_GetUsedMemoryRatio(){$/;"	f
RM_HashGet	module.c	/^int RM_HashGet(RedisModuleKey *key, int flags, ...) {$/;"	f
RM_HashSet	module.c	/^int RM_HashSet(RedisModuleKey *key, int flags, ...) {$/;"	f
RM_HoldString	module.c	/^RedisModuleString* RM_HoldString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f
RM_InfoAddFieldCString	module.c	/^int RM_InfoAddFieldCString(RedisModuleInfoCtx *ctx, char *field, char *value) {$/;"	f
RM_InfoAddFieldDouble	module.c	/^int RM_InfoAddFieldDouble(RedisModuleInfoCtx *ctx, char *field, double value) {$/;"	f
RM_InfoAddFieldLongLong	module.c	/^int RM_InfoAddFieldLongLong(RedisModuleInfoCtx *ctx, char *field, long long value) {$/;"	f
RM_InfoAddFieldString	module.c	/^int RM_InfoAddFieldString(RedisModuleInfoCtx *ctx, char *field, RedisModuleString *value) {$/;"	f
RM_InfoAddFieldULongLong	module.c	/^int RM_InfoAddFieldULongLong(RedisModuleInfoCtx *ctx, char *field, unsigned long long value) {$/;"	f
RM_InfoAddSection	module.c	/^int RM_InfoAddSection(RedisModuleInfoCtx *ctx, char *name) {$/;"	f
RM_InfoBeginDictField	module.c	/^int RM_InfoBeginDictField(RedisModuleInfoCtx *ctx, char *name) {$/;"	f
RM_InfoEndDictField	module.c	/^int RM_InfoEndDictField(RedisModuleInfoCtx *ctx) {$/;"	f
RM_IsBlockedReplyRequest	module.c	/^int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {$/;"	f
RM_IsBlockedTimeoutRequest	module.c	/^int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {$/;"	f
RM_IsIOError	module.c	/^int RM_IsIOError(RedisModuleIO *io) {$/;"	f
RM_IsKeysPositionRequest	module.c	/^int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {$/;"	f
RM_IsModuleNameBusy	module.c	/^int RM_IsModuleNameBusy(const char *name) {$/;"	f
RM_IsSubEventSupported	module.c	/^int RM_IsSubEventSupported(RedisModuleEvent event, int64_t subevent) {$/;"	f
RM_KeyAtPos	module.c	/^void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {$/;"	f
RM_KeyType	module.c	/^int RM_KeyType(RedisModuleKey *key) {$/;"	f
RM_KillForkChild	module.c	/^int RM_KillForkChild(int child_pid) {$/;"	f
RM_LatencyAddSample	module.c	/^void RM_LatencyAddSample(const char *event, mstime_t latency) {$/;"	f
RM_ListPop	module.c	/^RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {$/;"	f
RM_ListPush	module.c	/^int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {$/;"	f
RM_LoadDataTypeFromString	module.c	/^void *RM_LoadDataTypeFromString(const RedisModuleString *str, const moduleType *mt) {$/;"	f
RM_LoadDouble	module.c	/^double RM_LoadDouble(RedisModuleIO *io) {$/;"	f
RM_LoadFloat	module.c	/^float RM_LoadFloat(RedisModuleIO *io) {$/;"	f
RM_LoadLongDouble	module.c	/^long double RM_LoadLongDouble(RedisModuleIO *io) {$/;"	f
RM_LoadSigned	module.c	/^int64_t RM_LoadSigned(RedisModuleIO *io) {$/;"	f
RM_LoadString	module.c	/^RedisModuleString *RM_LoadString(RedisModuleIO *io) {$/;"	f
RM_LoadStringBuffer	module.c	/^char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {$/;"	f
RM_LoadUnsigned	module.c	/^uint64_t RM_LoadUnsigned(RedisModuleIO *io) {$/;"	f
RM_Log	module.c	/^void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {$/;"	f
RM_LogIOError	module.c	/^void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {$/;"	f
RM_MallocSize	module.c	/^size_t RM_MallocSize(void* ptr){$/;"	f
RM_Milliseconds	module.c	/^long long RM_Milliseconds(void) {$/;"	f
RM_ModuleTypeGetType	module.c	/^moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {$/;"	f
RM_ModuleTypeGetValue	module.c	/^void *RM_ModuleTypeGetValue(RedisModuleKey *key) {$/;"	f
RM_ModuleTypeReplaceValue	module.c	/^int RM_ModuleTypeReplaceValue(RedisModuleKey *key, moduleType *mt, void *new_value, void **old_value) {$/;"	f
RM_ModuleTypeSetValue	module.c	/^int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {$/;"	f
RM_NotifyKeyspaceEvent	module.c	/^int RM_NotifyKeyspaceEvent(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key) {$/;"	f
RM_OpenKey	module.c	/^void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {$/;"	f
RM_PoolAlloc	module.c	/^void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {$/;"	f
RM_PublishMessage	module.c	/^int RM_PublishMessage(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {$/;"	f
RM_RandomKey	module.c	/^RedisModuleString *RM_RandomKey(RedisModuleCtx *ctx) {$/;"	f
RM_Realloc	module.c	/^void* RM_Realloc(void *ptr, size_t bytes) {$/;"	f
RM_RegisterClusterMessageReceiver	module.c	/^void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {$/;"	f
RM_RegisterCommandFilter	module.c	/^RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {$/;"	f
RM_RegisterDefragFunc	module.c	/^int RM_RegisterDefragFunc(RedisModuleCtx *ctx, RedisModuleDefragFunc cb) {$/;"	f
RM_RegisterInfoFunc	module.c	/^int RM_RegisterInfoFunc(RedisModuleCtx *ctx, RedisModuleInfoFunc cb) {$/;"	f
RM_Replicate	module.c	/^int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {$/;"	f
RM_ReplicateVerbatim	module.c	/^int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {$/;"	f
RM_ReplySetArrayLength	module.c	/^void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {$/;"	f
RM_ReplyWithArray	module.c	/^int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {$/;"	f
RM_ReplyWithCString	module.c	/^int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {$/;"	f
RM_ReplyWithCallReply	module.c	/^int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {$/;"	f
RM_ReplyWithDouble	module.c	/^int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {$/;"	f
RM_ReplyWithEmptyArray	module.c	/^int RM_ReplyWithEmptyArray(RedisModuleCtx *ctx) {$/;"	f
RM_ReplyWithEmptyString	module.c	/^int RM_ReplyWithEmptyString(RedisModuleCtx *ctx) {$/;"	f
RM_ReplyWithError	module.c	/^int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {$/;"	f
RM_ReplyWithLongDouble	module.c	/^int RM_ReplyWithLongDouble(RedisModuleCtx *ctx, long double ld) {$/;"	f
RM_ReplyWithLongLong	module.c	/^int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {$/;"	f
RM_ReplyWithNull	module.c	/^int RM_ReplyWithNull(RedisModuleCtx *ctx) {$/;"	f
RM_ReplyWithNullArray	module.c	/^int RM_ReplyWithNullArray(RedisModuleCtx *ctx) {$/;"	f
RM_ReplyWithSimpleString	module.c	/^int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {$/;"	f
RM_ReplyWithString	module.c	/^int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f
RM_ReplyWithStringBuffer	module.c	/^int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {$/;"	f
RM_ReplyWithVerbatimString	module.c	/^int RM_ReplyWithVerbatimString(RedisModuleCtx *ctx, const char *buf, size_t len) {$/;"	f
RM_ResetDataset	module.c	/^void RM_ResetDataset(int restart_aof, int async) {$/;"	f
RM_RetainString	module.c	/^void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f
RM_SaveDataTypeToString	module.c	/^RedisModuleString *RM_SaveDataTypeToString(RedisModuleCtx *ctx, void *data, const moduleType *mt) {$/;"	f
RM_SaveDouble	module.c	/^void RM_SaveDouble(RedisModuleIO *io, double value) {$/;"	f
RM_SaveFloat	module.c	/^void RM_SaveFloat(RedisModuleIO *io, float value) {$/;"	f
RM_SaveLongDouble	module.c	/^void RM_SaveLongDouble(RedisModuleIO *io, long double value) {$/;"	f
RM_SaveSigned	module.c	/^void RM_SaveSigned(RedisModuleIO *io, int64_t value) {$/;"	f
RM_SaveString	module.c	/^void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {$/;"	f
RM_SaveStringBuffer	module.c	/^void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {$/;"	f
RM_SaveUnsigned	module.c	/^void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {$/;"	f
RM_Scan	module.c	/^int RM_Scan(RedisModuleCtx *ctx, RedisModuleScanCursor *cursor, RedisModuleScanCB fn, void *privdata) {$/;"	f
RM_ScanCursorCreate	module.c	/^RedisModuleScanCursor *RM_ScanCursorCreate() {$/;"	f
RM_ScanCursorDestroy	module.c	/^void RM_ScanCursorDestroy(RedisModuleScanCursor *cursor) {$/;"	f
RM_ScanCursorRestart	module.c	/^void RM_ScanCursorRestart(RedisModuleScanCursor *cursor) {$/;"	f
RM_ScanKey	module.c	/^int RM_ScanKey(RedisModuleKey *key, RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, void *privdata) {$/;"	f
RM_SelectDb	module.c	/^int RM_SelectDb(RedisModuleCtx *ctx, int newid) {$/;"	f
RM_SendChildHeartbeat	module.c	/^void RM_SendChildHeartbeat(double progress) {$/;"	f
RM_SendClusterMessage	module.c	/^int RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, unsigned char *msg, uint32_t len) {$/;"	f
RM_ServerInfoGetField	module.c	/^RedisModuleString *RM_ServerInfoGetField(RedisModuleCtx *ctx, RedisModuleServerInfoData *data, const char* field) {$/;"	f
RM_ServerInfoGetFieldC	module.c	/^const char *RM_ServerInfoGetFieldC(RedisModuleServerInfoData *data, const char* field) {$/;"	f
RM_ServerInfoGetFieldDouble	module.c	/^double RM_ServerInfoGetFieldDouble(RedisModuleServerInfoData *data, const char* field, int *out_err) {$/;"	f
RM_ServerInfoGetFieldSigned	module.c	/^long long RM_ServerInfoGetFieldSigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {$/;"	f
RM_ServerInfoGetFieldUnsigned	module.c	/^unsigned long long RM_ServerInfoGetFieldUnsigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {$/;"	f
RM_SetAbsExpire	module.c	/^int RM_SetAbsExpire(RedisModuleKey *key, mstime_t expire) {$/;"	f
RM_SetClusterFlags	module.c	/^void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {$/;"	f
RM_SetDisconnectCallback	module.c	/^void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {$/;"	f
RM_SetExpire	module.c	/^int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {$/;"	f
RM_SetLFU	module.c	/^int RM_SetLFU(RedisModuleKey *key, long long lfu_freq) {$/;"	f
RM_SetLRU	module.c	/^int RM_SetLRU(RedisModuleKey *key, mstime_t lru_idle) {$/;"	f
RM_SetModuleAttribs	module.c	/^void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {$/;"	f
RM_SetModuleOptions	module.c	/^void RM_SetModuleOptions(RedisModuleCtx *ctx, int options) {$/;"	f
RM_SetModuleUserACL	module.c	/^int RM_SetModuleUserACL(RedisModuleUser *user, const char* acl) {$/;"	f
RM_SignalKeyAsReady	module.c	/^void RM_SignalKeyAsReady(RedisModuleCtx *ctx, RedisModuleString *key) {$/;"	f
RM_SignalModifiedKey	module.c	/^int RM_SignalModifiedKey(RedisModuleCtx *ctx, RedisModuleString *keyname) {$/;"	f
RM_StopTimer	module.c	/^int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {$/;"	f
RM_Strdup	module.c	/^char *RM_Strdup(const char *str) {$/;"	f
RM_StreamAdd	module.c	/^int RM_StreamAdd(RedisModuleKey *key, int flags, RedisModuleStreamID *id, RedisModuleString **argv, long numfields) {$/;"	f
RM_StreamDelete	module.c	/^int RM_StreamDelete(RedisModuleKey *key, RedisModuleStreamID *id) {$/;"	f
RM_StreamIteratorDelete	module.c	/^int RM_StreamIteratorDelete(RedisModuleKey *key) {$/;"	f
RM_StreamIteratorNextField	module.c	/^int RM_StreamIteratorNextField(RedisModuleKey *key, RedisModuleString **field_ptr, RedisModuleString **value_ptr) {$/;"	f
RM_StreamIteratorNextID	module.c	/^int RM_StreamIteratorNextID(RedisModuleKey *key, RedisModuleStreamID *id, long *numfields) {$/;"	f
RM_StreamIteratorStart	module.c	/^int RM_StreamIteratorStart(RedisModuleKey *key, int flags, RedisModuleStreamID *start, RedisModuleStreamID *end) {$/;"	f
RM_StreamIteratorStop	module.c	/^int RM_StreamIteratorStop(RedisModuleKey *key) {$/;"	f
RM_StreamTrimByID	module.c	/^long long RM_StreamTrimByID(RedisModuleKey *key, int flags, RedisModuleStreamID *id) {$/;"	f
RM_StreamTrimByLength	module.c	/^long long RM_StreamTrimByLength(RedisModuleKey *key, int flags, long long length) {$/;"	f
RM_StringAppendBuffer	module.c	/^int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {$/;"	f
RM_StringCompare	module.c	/^int RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {$/;"	f
RM_StringDMA	module.c	/^char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {$/;"	f
RM_StringPtrLen	module.c	/^const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {$/;"	f
RM_StringSet	module.c	/^int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {$/;"	f
RM_StringToDouble	module.c	/^int RM_StringToDouble(const RedisModuleString *str, double *d) {$/;"	f
RM_StringToLongDouble	module.c	/^int RM_StringToLongDouble(const RedisModuleString *str, long double *ld) {$/;"	f
RM_StringToLongLong	module.c	/^int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {$/;"	f
RM_StringToStreamID	module.c	/^int RM_StringToStreamID(const RedisModuleString *str, RedisModuleStreamID *id) {$/;"	f
RM_StringTruncate	module.c	/^int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {$/;"	f
RM_SubscribeToKeyspaceEvents	module.c	/^int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {$/;"	f
RM_SubscribeToServerEvent	module.c	/^int RM_SubscribeToServerEvent(RedisModuleCtx *ctx, RedisModuleEvent event, RedisModuleEventCallback callback) {$/;"	f
RM_ThreadSafeContextLock	module.c	/^void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {$/;"	f
RM_ThreadSafeContextTryLock	module.c	/^int RM_ThreadSafeContextTryLock(RedisModuleCtx *ctx) {$/;"	f
RM_ThreadSafeContextUnlock	module.c	/^void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {$/;"	f
RM_UnblockClient	module.c	/^int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {$/;"	f
RM_UnlinkKey	module.c	/^int RM_UnlinkKey(RedisModuleKey *key) {$/;"	f
RM_UnregisterCommandFilter	module.c	/^int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {$/;"	f
RM_ValueLength	module.c	/^size_t RM_ValueLength(RedisModuleKey *key) {$/;"	f
RM_WrongArity	module.c	/^int RM_WrongArity(RedisModuleCtx *ctx) {$/;"	f
RM_ZsetAdd	module.c	/^int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {$/;"	f
RM_ZsetFirstInLexRange	module.c	/^int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {$/;"	f
RM_ZsetFirstInScoreRange	module.c	/^int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {$/;"	f
RM_ZsetIncrby	module.c	/^int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {$/;"	f
RM_ZsetLastInLexRange	module.c	/^int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {$/;"	f
RM_ZsetLastInScoreRange	module.c	/^int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {$/;"	f
RM_ZsetRangeCurrentElement	module.c	/^RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {$/;"	f
RM_ZsetRangeEndReached	module.c	/^int RM_ZsetRangeEndReached(RedisModuleKey *key) {$/;"	f
RM_ZsetRangeNext	module.c	/^int RM_ZsetRangeNext(RedisModuleKey *key) {$/;"	f
RM_ZsetRangePrev	module.c	/^int RM_ZsetRangePrev(RedisModuleKey *key) {$/;"	f
RM_ZsetRangeStop	module.c	/^void RM_ZsetRangeStop(RedisModuleKey *key) {$/;"	f
RM_ZsetRem	module.c	/^int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {$/;"	f
RM_ZsetScore	module.c	/^int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {$/;"	f
RM__Assert	module.c	/^void RM__Assert(const char *estr, const char *file, int line) {$/;"	f
ROTL	siphash.c	66;"	d	file:
ROTLEFT	sha256.c	21;"	d	file:
ROTRIGHT	sha256.c	22;"	d	file:
R_MAJOR	geohash_helper.c	43;"	d	file:
R_MINOR	geohash_helper.c	44;"	d	file:
R_Nan	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_NegInf	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_PosInf	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_Zero	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
RedisModule	module.c	/^struct RedisModule {$/;"	s	file:
RedisModule	module.c	/^typedef struct RedisModule RedisModule;$/;"	t	typeref:struct:RedisModule	file:
RedisModuleBlockedClient	module.c	/^typedef struct RedisModuleBlockedClient {$/;"	s	file:
RedisModuleBlockedClient	module.c	/^} RedisModuleBlockedClient;$/;"	t	typeref:struct:RedisModuleBlockedClient	file:
RedisModuleBlockedClient	redismodule.h	/^typedef struct RedisModuleBlockedClient RedisModuleBlockedClient;$/;"	t	typeref:struct:RedisModuleBlockedClient
RedisModuleCallReply	module.c	/^typedef struct RedisModuleCallReply {$/;"	s	file:
RedisModuleCallReply	module.c	/^} RedisModuleCallReply;$/;"	t	typeref:struct:RedisModuleCallReply	file:
RedisModuleCallReply	redismodule.h	/^typedef struct RedisModuleCallReply RedisModuleCallReply;$/;"	t	typeref:struct:RedisModuleCallReply
RedisModuleClientInfo	redismodule.h	/^typedef struct RedisModuleClientInfo {$/;"	s
RedisModuleClientInfo	redismodule.h	400;"	d
RedisModuleClientInfoV1	redismodule.h	/^} RedisModuleClientInfoV1;$/;"	t	typeref:struct:RedisModuleClientInfo
RedisModuleClusterInfo	redismodule.h	/^typedef struct RedisModuleClusterInfo RedisModuleClusterInfo;$/;"	t	typeref:struct:RedisModuleClusterInfo
RedisModuleClusterMessageReceiver	module.c	/^typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);$/;"	t	file:
RedisModuleClusterMessageReceiver	redismodule.h	/^typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);$/;"	t
RedisModuleCmdFunc	module.c	/^typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);$/;"	t	file:
RedisModuleCmdFunc	redismodule.h	/^typedef int (*RedisModuleCmdFunc)(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);$/;"	t
RedisModuleCommandDispatcher	module.c	/^void RedisModuleCommandDispatcher(client *c) {$/;"	f
RedisModuleCommandFilter	module.c	/^typedef struct RedisModuleCommandFilter {$/;"	s	file:
RedisModuleCommandFilter	module.c	/^} RedisModuleCommandFilter;$/;"	t	typeref:struct:RedisModuleCommandFilter	file:
RedisModuleCommandFilter	redismodule.h	/^typedef struct RedisModuleCommandFilter RedisModuleCommandFilter;$/;"	t	typeref:struct:RedisModuleCommandFilter
RedisModuleCommandFilterCtx	module.c	/^typedef struct RedisModuleCommandFilterCtx {$/;"	s	file:
RedisModuleCommandFilterCtx	module.c	/^} RedisModuleCommandFilterCtx;$/;"	t	typeref:struct:RedisModuleCommandFilterCtx	file:
RedisModuleCommandFilterCtx	redismodule.h	/^typedef struct RedisModuleCommandFilterCtx RedisModuleCommandFilterCtx;$/;"	t	typeref:struct:RedisModuleCommandFilterCtx
RedisModuleCommandFilterFunc	module.c	/^typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);$/;"	t	file:
RedisModuleCommandFilterFunc	redismodule.h	/^typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);$/;"	t
RedisModuleCommandProxy	module.c	/^struct RedisModuleCommandProxy {$/;"	s	file:
RedisModuleCommandProxy	module.c	/^typedef struct RedisModuleCommandProxy RedisModuleCommandProxy;$/;"	t	typeref:struct:RedisModuleCommandProxy	file:
RedisModuleCronLoop	redismodule.h	448;"	d
RedisModuleCronLoopInfo	redismodule.h	/^typedef struct RedisModuleCronLoopInfo {$/;"	s
RedisModuleCronLoopV1	redismodule.h	/^} RedisModuleCronLoopV1;$/;"	t	typeref:struct:RedisModuleCronLoopInfo
RedisModuleCtx	module.c	/^struct RedisModuleCtx {$/;"	s	file:
RedisModuleCtx	module.c	/^typedef struct RedisModuleCtx RedisModuleCtx;$/;"	t	typeref:struct:RedisModuleCtx	file:
RedisModuleCtx	redismodule.h	/^typedef struct RedisModuleCtx RedisModuleCtx;$/;"	t	typeref:struct:RedisModuleCtx
RedisModuleDefragCtx	module.c	/^typedef struct RedisModuleDefragCtx {$/;"	s	file:
RedisModuleDefragCtx	module.c	/^} RedisModuleDefragCtx;$/;"	t	typeref:struct:RedisModuleDefragCtx	file:
RedisModuleDefragCtx	redismodule.h	/^typedef struct RedisModuleDefragCtx RedisModuleDefragCtx;$/;"	t	typeref:struct:RedisModuleDefragCtx
RedisModuleDefragFunc	module.c	/^typedef void (*RedisModuleDefragFunc)(struct RedisModuleDefragCtx *ctx);$/;"	t	file:
RedisModuleDefragFunc	redismodule.h	/^typedef int (*RedisModuleDefragFunc)(RedisModuleDefragCtx *ctx);$/;"	t
RedisModuleDict	module.c	/^typedef struct RedisModuleDict {$/;"	s	file:
RedisModuleDict	module.c	/^} RedisModuleDict;$/;"	t	typeref:struct:RedisModuleDict	file:
RedisModuleDict	redismodule.h	/^typedef struct RedisModuleDict RedisModuleDict;$/;"	t	typeref:struct:RedisModuleDict
RedisModuleDictIter	module.c	/^typedef struct RedisModuleDictIter {$/;"	s	file:
RedisModuleDictIter	module.c	/^} RedisModuleDictIter;$/;"	t	typeref:struct:RedisModuleDictIter	file:
RedisModuleDictIter	redismodule.h	/^typedef struct RedisModuleDictIter RedisModuleDictIter;$/;"	t	typeref:struct:RedisModuleDictIter
RedisModuleDigest	redismodule.h	/^typedef struct RedisModuleDigest RedisModuleDigest;$/;"	t	typeref:struct:RedisModuleDigest
RedisModuleDigest	server.h	/^typedef struct RedisModuleDigest {$/;"	s
RedisModuleDigest	server.h	/^} RedisModuleDigest;$/;"	t	typeref:struct:RedisModuleDigest
RedisModuleDisconnectFunc	module.c	/^typedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);$/;"	t	file:
RedisModuleDisconnectFunc	redismodule.h	/^typedef void (*RedisModuleDisconnectFunc)(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc);$/;"	t
RedisModuleEvent	redismodule.h	/^typedef struct RedisModuleEvent {$/;"	s
RedisModuleEvent	redismodule.h	/^} RedisModuleEvent;$/;"	t	typeref:struct:RedisModuleEvent
RedisModuleEventCallback	redismodule.h	/^typedef void (*RedisModuleEventCallback)(struct RedisModuleCtx *ctx, RedisModuleEvent eid, uint64_t subevent, void *data);$/;"	t
RedisModuleEventListener	module.c	/^typedef struct RedisModuleEventListener {$/;"	s	file:
RedisModuleEventListener	module.c	/^} RedisModuleEventListener;$/;"	t	typeref:struct:RedisModuleEventListener	file:
RedisModuleEvent_ClientChange	redismodule.h	/^    RedisModuleEvent_ClientChange = {$/;"	v
RedisModuleEvent_CronLoop	redismodule.h	/^    RedisModuleEvent_CronLoop = {$/;"	v
RedisModuleEvent_FlushDB	redismodule.h	/^    RedisModuleEvent_FlushDB = {$/;"	v
RedisModuleEvent_ForkChild	redismodule.h	/^    RedisModuleEvent_ForkChild = {$/;"	v
RedisModuleEvent_Loading	redismodule.h	/^    RedisModuleEvent_Loading = {$/;"	v
RedisModuleEvent_LoadingProgress	redismodule.h	/^    RedisModuleEvent_LoadingProgress = {$/;"	v
RedisModuleEvent_MasterLinkChange	redismodule.h	/^    RedisModuleEvent_MasterLinkChange = {$/;"	v
RedisModuleEvent_ModuleChange	redismodule.h	/^    RedisModuleEvent_ModuleChange = {$/;"	v
RedisModuleEvent_Persistence	redismodule.h	/^    RedisModuleEvent_Persistence = {$/;"	v
RedisModuleEvent_ReplBackup	redismodule.h	/^    RedisModuleEvent_ReplBackup = {$/;"	v
RedisModuleEvent_ReplicaChange	redismodule.h	/^    RedisModuleEvent_ReplicaChange = {$/;"	v
RedisModuleEvent_ReplicationRoleChanged	redismodule.h	/^    RedisModuleEvent_ReplicationRoleChanged = {$/;"	v
RedisModuleEvent_Shutdown	redismodule.h	/^    RedisModuleEvent_Shutdown = {$/;"	v
RedisModuleEvent_SwapDB	redismodule.h	/^    RedisModuleEvent_SwapDB = {$/;"	v
RedisModuleFlushInfo	redismodule.h	/^typedef struct RedisModuleFlushInfo {$/;"	s
RedisModuleFlushInfo	redismodule.h	427;"	d
RedisModuleFlushInfoV1	redismodule.h	/^} RedisModuleFlushInfoV1;$/;"	t	typeref:struct:RedisModuleFlushInfo
RedisModuleForkDoneHandler	module.c	/^typedef void (*RedisModuleForkDoneHandler) (int exitcode, int bysignal, void *user_data);$/;"	t	file:
RedisModuleForkDoneHandler	redismodule.h	/^typedef void (*RedisModuleForkDoneHandler) (int exitcode, int bysignal, void *user_data);$/;"	t
RedisModuleForkInfo	module.c	/^static struct RedisModuleForkInfo {$/;"	s	file:
RedisModuleIO	redismodule.h	/^typedef struct RedisModuleIO RedisModuleIO;$/;"	t	typeref:struct:RedisModuleIO
RedisModuleIO	server.h	/^typedef struct RedisModuleIO {$/;"	s
RedisModuleIO	server.h	/^} RedisModuleIO;$/;"	t	typeref:struct:RedisModuleIO
RedisModuleInfoCtx	module.c	/^typedef struct RedisModuleInfoCtx {$/;"	s	file:
RedisModuleInfoCtx	module.c	/^} RedisModuleInfoCtx;$/;"	t	typeref:struct:RedisModuleInfoCtx	file:
RedisModuleInfoCtx	redismodule.h	/^typedef struct RedisModuleInfoCtx RedisModuleInfoCtx;$/;"	t	typeref:struct:RedisModuleInfoCtx
RedisModuleInfoFunc	module.c	/^typedef void (*RedisModuleInfoFunc)(RedisModuleInfoCtx *ctx, int for_crash_report);$/;"	t	file:
RedisModuleInfoFunc	redismodule.h	/^typedef void (*RedisModuleInfoFunc)(RedisModuleInfoCtx *ctx, int for_crash_report);$/;"	t
RedisModuleKey	module.c	/^struct RedisModuleKey {$/;"	s	file:
RedisModuleKey	module.c	/^typedef struct RedisModuleKey RedisModuleKey;$/;"	t	typeref:struct:RedisModuleKey	file:
RedisModuleKey	redismodule.h	/^typedef struct RedisModuleKey RedisModuleKey;$/;"	t	typeref:struct:RedisModuleKey
RedisModuleKeyspaceSubscriber	module.c	/^typedef struct RedisModuleKeyspaceSubscriber {$/;"	s	file:
RedisModuleKeyspaceSubscriber	module.c	/^} RedisModuleKeyspaceSubscriber;$/;"	t	typeref:struct:RedisModuleKeyspaceSubscriber	file:
RedisModuleLoadingProgress	redismodule.h	460;"	d
RedisModuleLoadingProgressInfo	redismodule.h	/^typedef struct RedisModuleLoadingProgressInfo {$/;"	s
RedisModuleLoadingProgressV1	redismodule.h	/^} RedisModuleLoadingProgressV1;$/;"	t	typeref:struct:RedisModuleLoadingProgressInfo
RedisModuleModuleChange	redismodule.h	/^typedef struct RedisModuleModuleChange {$/;"	s
RedisModuleModuleChange	redismodule.h	438;"	d
RedisModuleModuleChangeV1	redismodule.h	/^} RedisModuleModuleChangeV1;$/;"	t	typeref:struct:RedisModuleModuleChange
RedisModuleNotificationFunc	module.c	/^typedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);$/;"	t	file:
RedisModuleNotificationFunc	redismodule.h	/^typedef int (*RedisModuleNotificationFunc)(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);$/;"	t
RedisModulePoolAllocBlock	module.c	/^typedef struct RedisModulePoolAllocBlock {$/;"	s	file:
RedisModulePoolAllocBlock	module.c	/^} RedisModulePoolAllocBlock;$/;"	t	typeref:struct:RedisModulePoolAllocBlock	file:
RedisModuleReplicationInfo	redismodule.h	/^typedef struct RedisModuleReplicationInfo {$/;"	s
RedisModuleReplicationInfo	redismodule.h	416;"	d
RedisModuleReplicationInfoV1	redismodule.h	/^} RedisModuleReplicationInfoV1;$/;"	t	typeref:struct:RedisModuleReplicationInfo
RedisModuleScanCB	module.c	/^typedef void (*RedisModuleScanCB)(RedisModuleCtx *ctx, RedisModuleString *keyname, RedisModuleKey *key, void *privdata);$/;"	t	file:
RedisModuleScanCB	redismodule.h	/^typedef void (*RedisModuleScanCB)(RedisModuleCtx *ctx, RedisModuleString *keyname, RedisModuleKey *key, void *privdata);$/;"	t
RedisModuleScanCursor	module.c	/^typedef struct RedisModuleScanCursor{$/;"	s	file:
RedisModuleScanCursor	module.c	/^}RedisModuleScanCursor;$/;"	t	typeref:struct:RedisModuleScanCursor	file:
RedisModuleScanCursor	redismodule.h	/^typedef struct RedisModuleScanCursor RedisModuleScanCursor;$/;"	t	typeref:struct:RedisModuleScanCursor
RedisModuleScanKeyCB	module.c	/^typedef void (*RedisModuleScanKeyCB)(RedisModuleKey *key, RedisModuleString *field, RedisModuleString *value, void *privdata);$/;"	t	file:
RedisModuleScanKeyCB	redismodule.h	/^typedef void (*RedisModuleScanKeyCB)(RedisModuleKey *key, RedisModuleString *field, RedisModuleString *value, void *privdata);$/;"	t
RedisModuleServerInfoData	module.c	/^typedef struct RedisModuleServerInfoData {$/;"	s	file:
RedisModuleServerInfoData	module.c	/^} RedisModuleServerInfoData;$/;"	t	typeref:struct:RedisModuleServerInfoData	file:
RedisModuleServerInfoData	redismodule.h	/^typedef struct RedisModuleServerInfoData RedisModuleServerInfoData;$/;"	t	typeref:struct:RedisModuleServerInfoData
RedisModuleSharedAPI	module.c	/^struct RedisModuleSharedAPI {$/;"	s	file:
RedisModuleSharedAPI	module.c	/^typedef struct RedisModuleSharedAPI RedisModuleSharedAPI;$/;"	t	typeref:struct:RedisModuleSharedAPI	file:
RedisModuleStreamID	redismodule.h	/^typedef struct RedisModuleStreamID {$/;"	s
RedisModuleStreamID	redismodule.h	/^} RedisModuleStreamID;$/;"	t	typeref:struct:RedisModuleStreamID
RedisModuleString	redismodule.h	/^typedef struct RedisModuleString RedisModuleString;$/;"	t	typeref:struct:RedisModuleString
RedisModuleString	redismodule.h	1132;"	d
RedisModuleSwapDbInfo	redismodule.h	/^typedef struct RedisModuleSwapDbInfo {$/;"	s
RedisModuleSwapDbInfo	redismodule.h	471;"	d
RedisModuleSwapDbInfoV1	redismodule.h	/^} RedisModuleSwapDbInfoV1;$/;"	t	typeref:struct:RedisModuleSwapDbInfo
RedisModuleTimer	module.c	/^typedef struct RedisModuleTimer {$/;"	s	file:
RedisModuleTimer	module.c	/^} RedisModuleTimer;$/;"	t	typeref:struct:RedisModuleTimer	file:
RedisModuleTimerID	redismodule.h	/^typedef uint64_t RedisModuleTimerID;$/;"	t
RedisModuleTimerProc	module.c	/^typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);$/;"	t	file:
RedisModuleTimerProc	redismodule.h	/^typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);$/;"	t
RedisModuleType	redismodule.h	/^typedef struct RedisModuleType RedisModuleType;$/;"	t	typeref:struct:RedisModuleType
RedisModuleType	server.h	/^typedef struct RedisModuleType {$/;"	s
RedisModuleTypeAuxLoadFunc	redismodule.h	/^typedef int (*RedisModuleTypeAuxLoadFunc)(RedisModuleIO *rdb, int encver, int when);$/;"	t
RedisModuleTypeAuxSaveFunc	redismodule.h	/^typedef void (*RedisModuleTypeAuxSaveFunc)(RedisModuleIO *rdb, int when);$/;"	t
RedisModuleTypeCopyFunc	redismodule.h	/^typedef void *(*RedisModuleTypeCopyFunc)(RedisModuleString *fromkey, RedisModuleString *tokey, const void *value);$/;"	t
RedisModuleTypeDefragFunc	redismodule.h	/^typedef int (*RedisModuleTypeDefragFunc)(RedisModuleDefragCtx *ctx, RedisModuleString *key, void **value);$/;"	t
RedisModuleTypeDigestFunc	redismodule.h	/^typedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);$/;"	t
RedisModuleTypeFreeEffortFunc	redismodule.h	/^typedef size_t (*RedisModuleTypeFreeEffortFunc)(RedisModuleString *key, const void *value);$/;"	t
RedisModuleTypeFreeFunc	redismodule.h	/^typedef void (*RedisModuleTypeFreeFunc)(void *value);$/;"	t
RedisModuleTypeLoadFunc	redismodule.h	/^typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);$/;"	t
RedisModuleTypeMemUsageFunc	redismodule.h	/^typedef size_t (*RedisModuleTypeMemUsageFunc)(const void *value);$/;"	t
RedisModuleTypeMethods	redismodule.h	/^typedef struct RedisModuleTypeMethods {$/;"	s
RedisModuleTypeMethods	redismodule.h	/^} RedisModuleTypeMethods;$/;"	t	typeref:struct:RedisModuleTypeMethods
RedisModuleTypeRewriteFunc	redismodule.h	/^typedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);$/;"	t
RedisModuleTypeSaveFunc	redismodule.h	/^typedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);$/;"	t
RedisModuleTypeUnlinkFunc	redismodule.h	/^typedef void (*RedisModuleTypeUnlinkFunc)(RedisModuleString *key, const void *value);$/;"	t
RedisModuleUser	module.c	/^typedef struct RedisModuleUser {$/;"	s	file:
RedisModuleUser	module.c	/^} RedisModuleUser;$/;"	t	typeref:struct:RedisModuleUser	file:
RedisModuleUser	redismodule.h	/^typedef struct RedisModuleUser RedisModuleUser;$/;"	t	typeref:struct:RedisModuleUser
RedisModuleUserChangedFunc	redismodule.h	/^typedef void (*RedisModuleUserChangedFunc) (uint64_t client_id, void *privdata);$/;"	t
RedisModuleUserChangedFunc	server.h	/^typedef void (*RedisModuleUserChangedFunc) (uint64_t client_id, void *privdata);$/;"	t
RedisModule_Assert	redismodule.h	1124;"	d
RedisModule_EventListeners	module.c	/^list *RedisModule_EventListeners; \/* Global list of all the active events. *\/$/;"	v
RedisModule_Init	redismodule.h	/^static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {$/;"	f
RedisModule_IsAOFClient	redismodule.h	847;"	d
RedisModule_OnLoad	modules/helloacl.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/helloblock.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/hellocluster.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/hellodict.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/hellohook.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/hellotimer.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/hellotype.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/helloworld.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RedisModule_OnLoad	modules/testmodule.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
ResetCommand_RedisCommand	modules/helloacl.c	/^int ResetCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
RevokeCommand_RedisCommand	modules/helloacl.c	/^int RevokeCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
SANITIZE_DUMP_CLIENTS	server.h	401;"	d
SANITIZE_DUMP_NO	server.h	399;"	d
SANITIZE_DUMP_YES	server.h	400;"	d
SA_ONSTACK	debug.c	53;"	d	file:
SDS_HDR	sds.h	84;"	d
SDS_HDR_VAR	sds.h	83;"	d
SDS_LLSTR_SIZE	sds.c	484;"	d	file:
SDS_MAX_PREALLOC	sds.h	36;"	d
SDS_NOINIT	sds.c	/^const char *SDS_NOINIT = "SDS_NOINIT";$/;"	v
SDS_TYPE_16	sds.h	78;"	d
SDS_TYPE_32	sds.h	79;"	d
SDS_TYPE_5	sds.h	76;"	d
SDS_TYPE_5_LEN	sds.h	85;"	d
SDS_TYPE_64	sds.h	80;"	d
SDS_TYPE_8	sds.h	77;"	d
SDS_TYPE_BITS	sds.h	82;"	d
SDS_TYPE_MASK	sds.h	81;"	d
SEED	rand.c	63;"	d	file:
SENSITIVE_CONFIG	config.c	252;"	d	file:
SENTINEL_ASK_FORCED	sentinel.c	4317;"	d	file:
SENTINEL_ASK_PERIOD	sentinel.c	83;"	d	file:
SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES	sentinel.c	99;"	d	file:
SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG	sentinel.c	97;"	d	file:
SENTINEL_DEFAULT_DOWN_AFTER	sentinel.c	85;"	d	file:
SENTINEL_DEFAULT_FAILOVER_TIMEOUT	sentinel.c	93;"	d	file:
SENTINEL_DEFAULT_PARALLEL_SYNCS	sentinel.c	91;"	d	file:
SENTINEL_DEFAULT_RESOLVE_HOSTNAMES	sentinel.c	98;"	d	file:
SENTINEL_DEFAULT_SLAVE_PRIORITY	sentinel.c	89;"	d	file:
SENTINEL_ELECTION_TIMEOUT	sentinel.c	95;"	d	file:
SENTINEL_FAILOVER_STATE_NONE	sentinel.c	102;"	d	file:
SENTINEL_FAILOVER_STATE_RECONF_SLAVES	sentinel.c	107;"	d	file:
SENTINEL_FAILOVER_STATE_SELECT_SLAVE	sentinel.c	104;"	d	file:
SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE	sentinel.c	105;"	d	file:
SENTINEL_FAILOVER_STATE_UPDATE_CONFIG	sentinel.c	108;"	d	file:
SENTINEL_FAILOVER_STATE_WAIT_PROMOTION	sentinel.c	106;"	d	file:
SENTINEL_FAILOVER_STATE_WAIT_START	sentinel.c	103;"	d	file:
SENTINEL_GENERATE_EVENT	sentinel.c	117;"	d	file:
SENTINEL_HELLO_CHANNEL	sentinel.c	86;"	d	file:
SENTINEL_INFO_PERIOD	sentinel.c	81;"	d	file:
SENTINEL_ISQR_NOAUTH	sentinel.c	3499;"	d	file:
SENTINEL_ISQR_NOQUORUM	sentinel.c	3498;"	d	file:
SENTINEL_ISQR_OK	sentinel.c	3497;"	d	file:
SENTINEL_LEADER	sentinel.c	118;"	d	file:
SENTINEL_MASTER_LINK_STATUS_DOWN	sentinel.c	111;"	d	file:
SENTINEL_MASTER_LINK_STATUS_UP	sentinel.c	110;"	d	file:
SENTINEL_MAX_DESYNC	sentinel.c	96;"	d	file:
SENTINEL_MAX_PENDING_COMMANDS	sentinel.c	94;"	d	file:
SENTINEL_MIN_LINK_RECONNECT_PERIOD	sentinel.c	92;"	d	file:
SENTINEL_NO_FLAGS	sentinel.c	116;"	d	file:
SENTINEL_OBSERVER	sentinel.c	119;"	d	file:
SENTINEL_PING_PERIOD	sentinel.c	82;"	d	file:
SENTINEL_PUBLISH_PERIOD	sentinel.c	84;"	d	file:
SENTINEL_RESET_NO_SENTINELS	sentinel.c	1562;"	d	file:
SENTINEL_SCRIPT_MAX_ARGS	sentinel.c	778;"	d	file:
SENTINEL_SCRIPT_MAX_QUEUE	sentinel.c	124;"	d	file:
SENTINEL_SCRIPT_MAX_RETRY	sentinel.c	127;"	d	file:
SENTINEL_SCRIPT_MAX_RUNNING	sentinel.c	125;"	d	file:
SENTINEL_SCRIPT_MAX_RUNTIME	sentinel.c	126;"	d	file:
SENTINEL_SCRIPT_NONE	sentinel.c	122;"	d	file:
SENTINEL_SCRIPT_RETRY_DELAY	sentinel.c	128;"	d	file:
SENTINEL_SCRIPT_RUNNING	sentinel.c	123;"	d	file:
SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION	sentinel.c	132;"	d	file:
SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION	sentinel.c	133;"	d	file:
SENTINEL_SIMFAILURE_NONE	sentinel.c	131;"	d	file:
SENTINEL_SLAVE_RECONF_TIMEOUT	sentinel.c	90;"	d	file:
SENTINEL_TILT_PERIOD	sentinel.c	88;"	d	file:
SENTINEL_TILT_TRIGGER	sentinel.c	87;"	d	file:
SERVER_CHILD_NOERROR_RETVAL	server.h	131;"	d
SET3	rand.c	61;"	d	file:
SETLOW	rand.c	62;"	d	file:
SET_ERRNO	lzf_d.c	40;"	d	file:
SET_ERRNO	lzf_d.c	43;"	d	file:
SET_NUMERIC_TYPE	config.c	1939;"	d	file:
SET_OP_DIFF	server.h	405;"	d
SET_OP_DIFF	t_set.c	988;"	d	file:
SET_OP_INTER	server.h	406;"	d
SET_OP_INTER	t_set.c	989;"	d	file:
SET_OP_UNION	server.h	404;"	d
SET_OP_UNION	t_set.c	987;"	d	file:
SE_SYSTEMD	Makefile	/^	echo USE_SYSTEMD=$(USE_SYSTEMD) >> .make-settings$/;"	m
SHA1Final	sha1.c	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context)$/;"	f
SHA1HANDSOFF	sha1.c	22;"	d	file:
SHA1Init	sha1.c	/^void SHA1Init(SHA1_CTX* context)$/;"	f
SHA1Transform	sha1.c	/^void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])$/;"	f
SHA1Update	sha1.c	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)$/;"	f
SHA1_CTX	sha1.h	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon57
SHA1_H	sha1.h	2;"	d
SHA256_BLOCK_SIZE	sha256.h	17;"	d
SHA256_CTX	sha256.h	/^} SHA256_CTX;$/;"	t	typeref:struct:__anon58
SHA256_H	sha256.h	10;"	d
SHOBJ_CFLAGS	modules/Makefile	/^	SHOBJ_CFLAGS ?= -W -Wall -dynamic -fno-common -g -ggdb -std=c99 -O2$/;"	m
SHOBJ_CFLAGS	modules/Makefile	/^	SHOBJ_CFLAGS ?= -W -Wall -fno-common -g -ggdb -std=c99 -O2$/;"	m
SHOBJ_LDFLAGS	modules/Makefile	/^	SHOBJ_LDFLAGS ?= -bundle -undefined dynamic_lookup$/;"	m
SHOBJ_LDFLAGS	modules/Makefile	/^	SHOBJ_LDFLAGS ?= -shared$/;"	m
SHOULD_SIGNAL_MODIFIED_KEYS	module.c	380;"	d	file:
SHUTDOWN_NOFLAGS	server.h	436;"	d
SHUTDOWN_NOSAVE	server.h	439;"	d
SHUTDOWN_SAVE	server.h	437;"	d
SIG0	sha256.c	28;"	d	file:
SIG1	sha256.c	29;"	d	file:
SIPROUND	siphash.c	98;"	d	file:
SIZE_SAFETY_LIMIT	quicklist.c	53;"	d	file:
SLAVE_CAPA_EOF	server.h	349;"	d
SLAVE_CAPA_NONE	server.h	348;"	d
SLAVE_CAPA_PSYNC2	server.h	350;"	d
SLAVE_STATE_ONLINE	server.h	345;"	d
SLAVE_STATE_SEND_BULK	server.h	344;"	d
SLAVE_STATE_WAIT_BGSAVE_END	server.h	343;"	d
SLAVE_STATE_WAIT_BGSAVE_START	server.h	342;"	d
SLC_NOCREAT	stream.h	101;"	d
SLC_NONE	stream.h	100;"	d
SLC_NOREFRESH	stream.h	102;"	d
SLOWLOG_ENTRY_MAX_ARGC	slowlog.h	33;"	d
SLOWLOG_ENTRY_MAX_STRING	slowlog.h	34;"	d
SORT_ASC	geo.c	499;"	d	file:
SORT_DESC	geo.c	500;"	d	file:
SORT_NONE	geo.c	498;"	d	file:
SORT_OP_GET	server.h	362;"	d
SPARKLINE_FILL	sparkline.h	47;"	d
SPARKLINE_LOG_SCALE	sparkline.h	48;"	d
SPARKLINE_NO_FLAGS	sparkline.h	46;"	d
SPOP_MOVE_STRATEGY_MUL	t_set.c	452;"	d	file:
SPT	setproctitle.c	/^} SPT;$/;"	v	typeref:struct:__anon56	file:
SPT_MAXTITLE	setproctitle.c	272;"	d	file:
SPT_MIN	setproctitle.c	75;"	d	file:
SRANDMEMBER_SUB_STRATEGY_MUL	t_set.c	654;"	d	file:
SRCCOLOR	Makefile	/^SRCCOLOR="\\033[33m"$/;"	m
SRI_FAILOVER_IN_PROGRESS	sentinel.c	71;"	d	file:
SRI_FORCE_FAILOVER	sentinel.c	77;"	d	file:
SRI_MASTER	sentinel.c	64;"	d	file:
SRI_MASTER_DOWN	sentinel.c	69;"	d	file:
SRI_O_DOWN	sentinel.c	68;"	d	file:
SRI_PROMOTED	sentinel.c	73;"	d	file:
SRI_RECONF_DONE	sentinel.c	76;"	d	file:
SRI_RECONF_INPROG	sentinel.c	75;"	d	file:
SRI_RECONF_SENT	sentinel.c	74;"	d	file:
SRI_SCRIPT_KILL_SENT	sentinel.c	78;"	d	file:
SRI_SENTINEL	sentinel.c	66;"	d	file:
SRI_SLAVE	sentinel.c	65;"	d	file:
SRI_S_DOWN	sentinel.c	67;"	d	file:
STANDALONE	lzfP.h	40;"	d
STATS_METRIC_COMMAND	server.h	140;"	d
STATS_METRIC_COUNT	server.h	143;"	d
STATS_METRIC_NET_INPUT	server.h	141;"	d
STATS_METRIC_NET_OUTPUT	server.h	142;"	d
STATS_METRIC_SAMPLES	server.h	139;"	d
STD	Makefile	/^STD=-pedantic -DREDIS_STATIC=''$/;"	m
STREAMID_STATIC_VECTOR_LEN	t_stream.c	44;"	d	file:
STREAM_H	stream.h	2;"	d
STREAM_ITEM_FLAG_DELETED	t_stream.c	38;"	d	file:
STREAM_ITEM_FLAG_NONE	t_stream.c	37;"	d	file:
STREAM_ITEM_FLAG_SAMEFIELDS	t_stream.c	39;"	d	file:
STREAM_LISTPACK_MAX_PRE_ALLOCATE	t_stream.c	48;"	d	file:
STREAM_RWR_HISTORY	t_stream.c	1470;"	d	file:
STREAM_RWR_NOACK	t_stream.c	1467;"	d	file:
STREAM_RWR_RAWENTRIES	t_stream.c	1468;"	d	file:
STRICT_ALIGN	lzfP.h	179;"	d
STRICT_ALIGN	lzfP.h	180;"	d
STRICT_ALIGN	lzfP.h	83;"	d
STRICT_ALIGN	lzfP.h	85;"	d
SUPERVISED_AUTODETECT	server.h	373;"	d
SUPERVISED_NONE	server.h	372;"	d
SUPERVISED_SYSTEMD	server.h	374;"	d
SUPERVISED_UPSTART	server.h	375;"	d
SWAPINIT	pqsort.c	65;"	d	file:
SYNCIO__RESOLUTION	syncio.c	43;"	d	file:
ScanCBData	module.c	/^} ScanCBData;$/;"	t	typeref:struct:__anon32	file:
ScanKeyCBData	module.c	/^} ScanKeyCBData;$/;"	t	typeref:struct:__anon33	file:
SentReplyOnKeyMiss	db.c	/^static void SentReplyOnKeyMiss(client *c, robj *reply){$/;"	f	file:
String	redis-trib.rb	/^class String$/;"	c
T	modules/testmodule.c	363;"	d	file:
TD	Makefile	/^	echo STD=$(STD) >> .make-settings$/;"	m
TEST	quicklist.c	1536;"	d	file:
TEST_DESC	quicklist.c	1537;"	d	file:
THPDisable	latency.c	/^int THPDisable(void) {$/;"	f
THPGetAnonHugePagesSize	latency.c	/^int THPGetAnonHugePagesSize(void) {$/;"	f
THPIsEnabled	latency.c	/^int THPIsEnabled(void) {$/;"	f
TIMEOUT_TIME	modules/helloacl.c	95;"	d	file:
TLSCONN_DEBUG	tls.c	373;"	d	file:
TLSCONN_DEBUG	tls.c	376;"	d	file:
TLS_CLIENT_AUTH_NO	server.h	394;"	d
TLS_CLIENT_AUTH_OPTIONAL	server.h	396;"	d
TLS_CLIENT_AUTH_YES	server.h	395;"	d
TLS_CONN_FLAG_FD_SET	tls.c	403;"	d	file:
TLS_CONN_FLAG_READ_WANT_WRITE	tls.c	401;"	d	file:
TLS_CONN_FLAG_WRITE_WANT_READ	tls.c	402;"	d	file:
TRIM_STRATEGY_MAXLEN	t_stream.c	663;"	d	file:
TRIM_STRATEGY_MINID	t_stream.c	664;"	d	file:
TRIM_STRATEGY_NONE	t_stream.c	662;"	d	file:
TerminateModuleForkChild	module.c	/^int TerminateModuleForkChild(int child_pid, int wait) {$/;"	f
TestAssertIntegerReply	modules/testmodule.c	/^int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, long long expected) {$/;"	f
TestAssertStringReply	modules/testmodule.c	/^int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len) {$/;"	f
TestCall	modules/testmodule.c	/^int TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestCtxFlags	modules/testmodule.c	/^int TestCtxFlags(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestIt	modules/testmodule.c	/^int TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestMatchReply	modules/testmodule.c	/^int TestMatchReply(RedisModuleCallReply *reply, char *str) {$/;"	f
TestNotifications	modules/testmodule.c	/^int TestNotifications(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestStringAppend	modules/testmodule.c	/^int TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestStringAppendAM	modules/testmodule.c	/^int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestStringPrintf	modules/testmodule.c	/^int TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TestUnlink	modules/testmodule.c	/^int TestUnlink(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
TimerCommand_RedisCommand	modules/hellotimer.c	/^int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
Timers	module.c	/^static rax *Timers;     \/* The radix tree of all the timers sorted by expire. *\/$/;"	v	file:
TrackingChannelName	tracking.c	/^robj *TrackingChannelName;$/;"	v
TrackingTable	tracking.c	/^rax *TrackingTable = NULL;$/;"	v
TrackingTableTotalItems	tracking.c	/^uint64_t TrackingTableTotalItems = 0; \/* Total number of IDs stored across$/;"	v
U32TO8_LE	siphash.c	68;"	d	file:
U64TO8_LE	siphash.c	74;"	d	file:
U8TO64_LE	siphash.c	79;"	d	file:
U8TO64_LE	siphash.c	81;"	d	file:
U8TO64_LE_NOCASE	siphash.c	88;"	d	file:
UILD_TLS	Makefile	/^	echo BUILD_TLS=$(BUILD_TLS) >> .make-settings$/;"	m
ULONG_ONEZERO	memtest.c	52;"	d	file:
ULONG_ONEZERO	memtest.c	55;"	d	file:
ULONG_ZEROONE	memtest.c	53;"	d	file:
ULONG_ZEROONE	memtest.c	56;"	d	file:
ULTRA_FAST	lzfP.h	75;"	d
UM	mt19937-64.c	63;"	d	file:
UNALIGNED_LE_CPU	siphash.c	63;"	d	file:
UNIT_MILLISECONDS	server.h	433;"	d
UNIT_SECONDS	server.h	432;"	d
UNUSED	crc64.c	129;"	d	file:
UNUSED	endianconv.c	107;"	d	file:
UNUSED	intset.c	394;"	d	file:
UNUSED	quicklist.c	1541;"	d	file:
UNUSED	redis-benchmark.c	64;"	d	file:
UNUSED	redis-cli.c	67;"	d	file:
UNUSED	sds.c	1225;"	d	file:
UNUSED	server.h	378;"	d
UNUSED	sha1.c	203;"	d	file:
UNUSED	util.c	948;"	d	file:
UNUSED	zipmap.c	475;"	d	file:
UNUSED	zmalloc.c	682;"	d	file:
USER_COMMAND_BITS_COUNT	server.h	801;"	d
USER_FLAG_ALLCHANNELS	server.h	815;"	d
USER_FLAG_ALLCOMMANDS	server.h	808;"	d
USER_FLAG_ALLKEYS	server.h	807;"	d
USER_FLAG_DISABLED	server.h	806;"	d
USER_FLAG_ENABLED	server.h	805;"	d
USER_FLAG_NOPASS	server.h	809;"	d
USER_FLAG_SANITIZE_PAYLOAD	server.h	817;"	d
USER_FLAG_SANITIZE_PAYLOAD_SKIP	server.h	819;"	d
USE_ALIGNED_ACCESS	config.h	233;"	d
USE_CRYPTO_LOCKS	tls.c	105;"	d	file:
USE_JEMALLOC	Makefile	/^USE_JEMALLOC=no$/;"	m
USE_SETCPUAFFINITY	config.h	262;"	d
USE_SETPROCTITLE	config.h	126;"	d
USE_SETPROCTITLE	config.h	134;"	d
Users	acl.c	/^rax *Users; \/* Table mapping usernames to user structures. *\/$/;"	v
UsersToLoad	acl.c	/^list *UsersToLoad;  \/* This is a list of users found in the configuration file$/;"	v
VERY_FAST	lzfP.h	185;"	d
VERY_FAST	lzfP.h	64;"	d
WANT_READ	tls.c	/^    WANT_READ = 1,$/;"	e	enum:__anon70	file:
WANT_WRITE	tls.c	/^    WANT_WRITE$/;"	e	enum:__anon70	file:
WARN	Makefile	/^WARN=-Wall -W -Wno-missing-field-initializers$/;"	m
WORD	sha256.h	/^typedef uint32_t WORD;  \/\/ 32-bit word$/;"	t
WantIOType	tls.c	/^} WantIOType;$/;"	t	typeref:enum:__anon70	file:
X0	rand.c	54;"	d	file:
X1	rand.c	55;"	d	file:
X2	rand.c	56;"	d	file:
XREAD_BLOCKED_DEFAULT_COUNT	t_stream.c	1925;"	d	file:
ZADD_IN_GT	server.h	2137;"	d
ZADD_IN_INCR	server.h	2134;"	d
ZADD_IN_LT	server.h	2138;"	d
ZADD_IN_NONE	server.h	2133;"	d
ZADD_IN_NX	server.h	2135;"	d
ZADD_IN_XX	server.h	2136;"	d
ZADD_OUT_ADDED	server.h	2143;"	d
ZADD_OUT_NAN	server.h	2142;"	d
ZADD_OUT_NOP	server.h	2141;"	d
ZADD_OUT_UPDATED	server.h	2144;"	d
ZIPLIST_BYTES	ziplist.c	232;"	d	file:
ZIPLIST_END_SIZE	ziplist.c	247;"	d	file:
ZIPLIST_ENTRY_END	ziplist.c	258;"	d	file:
ZIPLIST_ENTRY_HEAD	ziplist.c	250;"	d	file:
ZIPLIST_ENTRY_TAIL	ziplist.c	254;"	d	file:
ZIPLIST_ENTRY_ZERO	ziplist.c	293;"	d	file:
ZIPLIST_HEAD	ziplist.h	34;"	d
ZIPLIST_HEADER_SIZE	ziplist.c	244;"	d	file:
ZIPLIST_INCR_LENGTH	ziplist.c	265;"	d	file:
ZIPLIST_LENGTH	ziplist.c	239;"	d	file:
ZIPLIST_TAIL	ziplist.h	35;"	d
ZIPLIST_TAIL_OFFSET	ziplist.c	235;"	d	file:
ZIPMAP_BIGLEN	zipmap.c	83;"	d	file:
ZIPMAP_END	zipmap.c	84;"	d	file:
ZIPMAP_LEN_BYTES	zipmap.c	93;"	d	file:
ZIPMAP_VALUE_MAX_FREE	zipmap.c	88;"	d	file:
ZIP_ASSERT_ENCODING	ziplist.c	326;"	d	file:
ZIP_BIG_PREVLEN	ziplist.c	196;"	d	file:
ZIP_DECODE_LENGTH	ziplist.c	398;"	d	file:
ZIP_DECODE_PREVLEN	ziplist.c	476;"	d	file:
ZIP_DECODE_PREVLENSIZE	ziplist.c	461;"	d	file:
ZIP_ENCODING_SIZE_INVALID	ziplist.c	307;"	d	file:
ZIP_END	ziplist.c	195;"	d	file:
ZIP_ENTRY_ENCODING	ziplist.c	302;"	d	file:
ZIP_INT_16B	ziplist.c	209;"	d	file:
ZIP_INT_24B	ziplist.c	212;"	d	file:
ZIP_INT_32B	ziplist.c	210;"	d	file:
ZIP_INT_64B	ziplist.c	211;"	d	file:
ZIP_INT_8B	ziplist.c	213;"	d	file:
ZIP_INT_IMM_MASK	ziplist.c	217;"	d	file:
ZIP_INT_IMM_MAX	ziplist.c	220;"	d	file:
ZIP_INT_IMM_MIN	ziplist.c	219;"	d	file:
ZIP_INT_MASK	ziplist.c	205;"	d	file:
ZIP_IS_STR	ziplist.c	227;"	d	file:
ZIP_STR_06B	ziplist.c	206;"	d	file:
ZIP_STR_14B	ziplist.c	207;"	d	file:
ZIP_STR_32B	ziplist.c	208;"	d	file:
ZIP_STR_MASK	ziplist.c	204;"	d	file:
ZMALLOC_LIB	zmalloc.h	39;"	d
ZMALLOC_LIB	zmalloc.h	49;"	d
ZMALLOC_LIB	zmalloc.h	73;"	d
ZRANDMEMBER_RANDOM_SAMPLE_LIMIT	t_zset.c	3983;"	d	file:
ZRANDMEMBER_SUB_STRATEGY_MUL	t_zset.c	3978;"	d	file:
ZRANGE_AUTO	t_zset.c	/^    ZRANGE_AUTO = 0,$/;"	e	enum:__anon60	file:
ZRANGE_CONSUMER_TYPE_CLIENT	t_zset.c	/^    ZRANGE_CONSUMER_TYPE_CLIENT = 0,$/;"	e	enum:__anon69	file:
ZRANGE_CONSUMER_TYPE_INTERNAL	t_zset.c	/^    ZRANGE_CONSUMER_TYPE_INTERNAL$/;"	e	enum:__anon69	file:
ZRANGE_DIRECTION_AUTO	t_zset.c	/^    ZRANGE_DIRECTION_AUTO = 0,$/;"	e	enum:__anon68	file:
ZRANGE_DIRECTION_FORWARD	t_zset.c	/^    ZRANGE_DIRECTION_FORWARD,$/;"	e	enum:__anon68	file:
ZRANGE_DIRECTION_REVERSE	t_zset.c	/^    ZRANGE_DIRECTION_REVERSE$/;"	e	enum:__anon68	file:
ZRANGE_LEX	t_zset.c	/^    ZRANGE_LEX,$/;"	e	enum:__anon60	file:
ZRANGE_RANK	t_zset.c	/^    ZRANGE_RANK,$/;"	e	enum:__anon60	file:
ZRANGE_SCORE	t_zset.c	/^    ZRANGE_SCORE,$/;"	e	enum:__anon60	file:
ZSET_MAX	server.h	359;"	d
ZSET_MIN	server.h	358;"	d
ZSKIPLIST_MAXLEVEL	server.h	380;"	d
ZSKIPLIST_P	server.h	381;"	d
_ALL_SOURCE	fmacros.h	41;"	d
_BSD_SOURCE	fmacros.h	33;"	d
_CRC16_TABLE_H__	crc16_slottable.h	2;"	d
_DEFAULT_SOURCE	fmacros.h	37;"	d
_FILE_OFFSET_BITS	fmacros.h	59;"	d
_GNU_SOURCE	fmacros.h	36;"	d
_GNU_SOURCE	setcpuaffinity.c	27;"	d	file:
_GNU_SOURCE	setproctitle.c	29;"	d	file:
_LARGEFILE_SOURCE	fmacros.h	58;"	d
_POSIX_C_SOURCE	fmacros.h	55;"	d
_REDISMODULE_CTX_FLAGS_NEXT	redismodule.h	145;"	d
_REDISMODULE_EVENT_NEXT	redismodule.h	242;"	d
_REDISMODULE_EVENT_REPLROLECHANGED_NEXT	redismodule.h	340;"	d
_REDISMODULE_NOTIFY_NEXT	redismodule.h	168;"	d
_REDISMODULE_SUBEVENT_CLIENT_CHANGE_NEXT	redismodule.h	328;"	d
_REDISMODULE_SUBEVENT_CRON_LOOP_NEXT	redismodule.h	364;"	d
_REDISMODULE_SUBEVENT_FLUSHDB_NEXT	redismodule.h	344;"	d
_REDISMODULE_SUBEVENT_FORK_CHILD_NEXT	redismodule.h	361;"	d
_REDISMODULE_SUBEVENT_LOADING_NEXT	redismodule.h	324;"	d
_REDISMODULE_SUBEVENT_LOADING_PROGRESS_NEXT	redismodule.h	352;"	d
_REDISMODULE_SUBEVENT_MASTER_NEXT	redismodule.h	332;"	d
_REDISMODULE_SUBEVENT_MODULE_NEXT	redismodule.h	348;"	d
_REDISMODULE_SUBEVENT_PERSISTENCE_NEXT	redismodule.h	317;"	d
_REDISMODULE_SUBEVENT_REPLICA_CHANGE_NEXT	redismodule.h	336;"	d
_REDISMODULE_SUBEVENT_REPL_BACKUP_NEXT	redismodule.h	357;"	d
_REDISMODULE_SUBEVENT_SHUTDOWN_NEXT	redismodule.h	363;"	d
_REDISMODULE_SUBEVENT_SWAPDB_NEXT	redismodule.h	365;"	d
_REDIS_FMACRO_H	fmacros.h	31;"	d
_XOPEN_SOURCE	fmacros.h	45;"	d
_XOPEN_SOURCE	fmacros.h	51;"	d
_ZIPLIST_H	ziplist.h	32;"	d
_ZIPMAP_H	zipmap.h	36;"	d
__ADLIST_H__	adlist.h	32;"	d
__AE_H__	ae.h	34;"	d
__ATOMIC_VAR_H	atomicvar.h	56;"	d
__BIO_H	bio.h	31;"	d
__CLICOMMON_H	cli_common.h	2;"	d
__CLUSTER_H	cluster.h	2;"	d
__CONFIG_H	config.h	31;"	d
__DICT_H	dict.h	37;"	d
__ENDIANCONV_H	endianconv.h	34;"	d
__GEO_H__	geo.h	2;"	d
__INTSET_H	intset.h	32;"	d
__LATENCY_H	latency.h	35;"	d
__LISTPACK_H	listpack.h	36;"	d
__LOLWUT_H	lolwut.h	39;"	d
__MONOTONIC_H	monotonic.h	2;"	d
__MT19937_64_H	mt19937-64.h	57;"	d
__PQSORT_H	pqsort.h	34;"	d
__QUICKLIST_H__	quicklist.h	34;"	d
__RDB_H	rdb.h	31;"	d
__REDIS_ASSERT_H__	redisassert.h	39;"	d
__REDIS_CONNECTION_H	connection.h	32;"	d
__REDIS_CONNHELPERS_H	connhelpers.h	32;"	d
__REDIS_H	server.h	31;"	d
__REDIS_HELP_H	help.h	4;"	d
__REDIS_RIO_H	rio.h	33;"	d
__REDIS_UTIL_H	util.h	31;"	d
__SDS_ALLOC_H__	sdsalloc.h	40;"	d
__SDS_H	sds.h	34;"	d
__SLOWLOG_H__	slowlog.h	31;"	d
__SPARKLINE_H	sparkline.h	31;"	d
__TESTHELP_H	testhelp.h	40;"	d
__ZMALLOC_H	zmalloc.h	32;"	d
__arm64__	config.h	224;"	d
__arm__	config.h	221;"	d
__cntvct	monotonic.c	/^static inline uint64_t __cntvct() {$/;"	f	file:
__failed_tests	testhelp.h	/^int __failed_tests = 0;$/;"	v
__quicklistCompress	quicklist.c	/^REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,$/;"	f
__quicklistCompressNode	quicklist.c	/^REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {$/;"	f
__quicklistDecompressNode	quicklist.c	/^REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {$/;"	f
__quicklistDelNode	quicklist.c	/^REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,$/;"	f
__quicklistInsertNode	quicklist.c	/^REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,$/;"	f
__sparc__	config.h	229;"	d
__str	zmalloc.h	36;"	d
__test_num	testhelp.h	/^int __test_num = 0;$/;"	v
__xstr	zmalloc.h	35;"	d
__ziplistCascadeUpdate	ziplist.c	/^unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {$/;"	f
__ziplistDelete	ziplist.c	/^unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {$/;"	f
__ziplistInsert	ziplist.c	/^unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f
_addReplyProtoToList	networking.c	/^void _addReplyProtoToList(client *c, const char *s, size_t len) {$/;"	f
_addReplyToBuffer	networking.c	/^int _addReplyToBuffer(client *c, const char *s, size_t len) {$/;"	f
_anetTcpServer	anet.c	/^static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)$/;"	f	file:
_buf	t_zset.c	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	struct:__anon67	file:
_client	redis-benchmark.c	/^typedef struct _client {$/;"	s	file:
_crc64	crc64.c	/^uint64_t _crc64(uint_fast64_t crc, const void *in_data, const uint64_t len) {$/;"	f
_dictClear	dict.c	/^int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {$/;"	f
_dictExpand	dict.c	/^int _dictExpand(dict *d, unsigned long size, int* malloc_failed)$/;"	f
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *d)$/;"	f	file:
_dictGetStatsHt	dict.c	/^size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {$/;"	f
_dictInit	dict.c	/^int _dictInit(dict *d, dictType *type,$/;"	f
_dictKeyIndex	dict.c	/^static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing)$/;"	f	file:
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size)$/;"	f	file:
_dictRehashStep	dict.c	/^static void _dictRehashStep(dict *d) {$/;"	f	file:
_dictReset	dict.c	/^static void _dictReset(dictht *ht)$/;"	f	file:
_hashZiplistEntryValidation	t_hash.c	/^static int _hashZiplistEntryValidation(unsigned char *p, void *userdata) {$/;"	f	file:
_intsetGet	intset.c	/^static int64_t _intsetGet(intset *is, int pos) {$/;"	f	file:
_intsetGetEncoded	intset.c	/^static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {$/;"	f	file:
_intsetSet	intset.c	/^static void _intsetSet(intset *is, int pos, int64_t value) {$/;"	f	file:
_intsetValueEncoding	intset.c	/^static uint8_t _intsetValueEncoding(int64_t v) {$/;"	f	file:
_iterset	t_zset.c	/^        union _iterset {$/;"	u	union:__anon61::__anon62	file:
_iterzset	t_zset.c	/^        union _iterzset {$/;"	u	union:__anon61::__anon62	file:
_itrprintr	quicklist.c	/^static int _itrprintr(quicklist *ql, int print, int forward) {$/;"	f	file:
_pqsort	pqsort.c	/^_pqsort(void *a, size_t n, size_t es,$/;"	f	file:
_ql_verify	quicklist.c	/^static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,$/;"	f	file:
_quicklistBookmarkDelete	quicklist.c	/^void _quicklistBookmarkDelete(quicklist *ql, quicklistBookmark *bm) {$/;"	f
_quicklistBookmarkFindByName	quicklist.c	/^quicklistBookmark *_quicklistBookmarkFindByName(quicklist *ql, const char *name) {$/;"	f
_quicklistBookmarkFindByNode	quicklist.c	/^quicklistBookmark *_quicklistBookmarkFindByNode(quicklist *ql, quicklistNode *node) {$/;"	f
_quicklistInsert	quicklist.c	/^REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,$/;"	f
_quicklistInsertNodeAfter	quicklist.c	/^REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,$/;"	f
_quicklistInsertNodeBefore	quicklist.c	/^REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,$/;"	f
_quicklistMergeNodes	quicklist.c	/^REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,$/;"	f
_quicklistNodeAllowInsert	quicklist.c	/^REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,$/;"	f
_quicklistNodeAllowMerge	quicklist.c	/^REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,$/;"	f
_quicklistNodeSizeMeetsOptimizationRequirement	quicklist.c	/^_quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,$/;"	f
_quicklistSaver	quicklist.c	/^REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {$/;"	f
_quicklistSplitNode	quicklist.c	/^REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,$/;"	f
_quicklistZiplistMerge	quicklist.c	/^REDIS_STATIC quicklistNode *_quicklistZiplistMerge(quicklist *quicklist,$/;"	f
_redisSortObject	server.h	/^typedef struct _redisSortObject {$/;"	s
_redisSortOperation	server.h	/^typedef struct _redisSortOperation {$/;"	s
_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_rio	rio.h	/^struct _rio {$/;"	s
_sdsnewlen	sds.c	/^sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {$/;"	f
_serverAssert	debug.c	/^void _serverAssert(const char *estr, const char *file, int line) {$/;"	f
_serverAssert	redis-benchmark.c	/^void _serverAssert(const char *estr, const char *file, int line) {$/;"	f
_serverAssert	redis-cli.c	/^void _serverAssert(const char *estr, const char *file, int line) {$/;"	f
_serverAssertPrintClientInfo	debug.c	/^void _serverAssertPrintClientInfo(const client *c) {$/;"	f
_serverAssertPrintObject	debug.c	/^void _serverAssertPrintObject(const robj *o) {$/;"	f
_serverAssertWithInfo	debug.c	/^void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {$/;"	f
_serverLog	server.c	/^void _serverLog(int level, const char *fmt, ...) {$/;"	f
_serverPanic	debug.c	/^void _serverPanic(const char *file, int line, const char *msg, ...) {$/;"	f
_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_zsetZiplistValidateIntegrity	t_zset.c	/^static int _zsetZiplistValidateIntegrity(unsigned char *p, void *userdata) {$/;"	f	file:
a	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
abortFailover	replication.c	/^void abortFailover(const char *err) {$/;"	f
about	cluster.h	/^        clusterMsgDataFail about;$/;"	m	struct:clusterMsgData::__anon8
accept	connection.h	/^    int (*accept)(struct connection *conn, ConnectionCallbackFunc accept_handler);$/;"	m	struct:ConnectionType
acceptCommonHandler	networking.c	/^static void acceptCommonHandler(connection *conn, int flags, char *ip) {$/;"	f	file:
acceptTLSHandler	networking.c	/^void acceptTLSHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
acceptTcpHandler	networking.c	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
acceptUnixHandler	networking.c	/^void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
aclCommand	acl.c	/^void aclCommand(client *c) {$/;"	f
acl_filename	server.h	/^    char *acl_filename;           \/* ACL Users file. NULL if not configured. *\/$/;"	m	struct:redisServer
acl_pubsub_default	server.h	/^    int acl_pubsub_default;      \/* Default ACL pub\/sub channels flag *\/$/;"	m	struct:redisServer
acl_pubsub_default_enum	config.c	/^configEnum acl_pubsub_default_enum[] = {$/;"	v
acllog_max_len	server.h	/^    unsigned long acllog_max_len; \/* Maximum length of the ACL LOG list. *\/$/;"	m	struct:redisServer
act_ping_time	sentinel.c	/^    mstime_t act_ping_time;   \/* Time at which the last pending ping (no pong$/;"	m	struct:instanceLink	file:
active	module.c	/^    int active;$/;"	m	struct:RedisModuleKeyspaceSubscriber	file:
active	scripting.c	/^    int active; \/* Are we debugging EVAL right now? *\/$/;"	m	struct:ldbState	file:
activeDefragAlloc	defrag.c	/^void *activeDefragAlloc(void *ptr) {$/;"	f
activeDefragAlloc	defrag.c	/^void* activeDefragAlloc(void *ptr) {$/;"	f
activeDefragCycle	defrag.c	/^void activeDefragCycle(void) {$/;"	f
activeDefragList	defrag.c	/^long activeDefragList(list *l, int val_type) {$/;"	f
activeDefragQuickListNode	defrag.c	/^long activeDefragQuickListNode(quicklist *ql, quicklistNode **node_ref) {$/;"	f
activeDefragQuickListNodes	defrag.c	/^long activeDefragQuickListNodes(quicklist *ql) {$/;"	f
activeDefragSds	defrag.c	/^sds activeDefragSds(sds sdsptr) {$/;"	f
activeDefragSdsDict	defrag.c	/^long activeDefragSdsDict(dict* d, int val_type) {$/;"	f
activeDefragSdsListAndDict	defrag.c	/^long activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {$/;"	f
activeDefragStringOb	defrag.c	/^robj *activeDefragStringOb(robj *ob, long *defragged) {$/;"	f
activeDefragStringOb	defrag.c	/^robj *activeDefragStringOb(robj* ob, long *defragged) {$/;"	f
activeDefragZsetEntry	defrag.c	/^long activeDefragZsetEntry(zset *zs, dictEntry *de) {$/;"	f
activeExpireCycle	expire.c	/^void activeExpireCycle(int type) {$/;"	f
activeExpireCycleTryExpire	expire.c	/^int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {$/;"	f
active_defrag_cycle_max	server.h	/^    int active_defrag_cycle_max;       \/* maximal effort for defrag in CPU percentage *\/$/;"	m	struct:redisServer
active_defrag_cycle_min	server.h	/^    int active_defrag_cycle_min;       \/* minimal effort for defrag in CPU percentage *\/$/;"	m	struct:redisServer
active_defrag_enabled	server.h	/^    int active_defrag_enabled;$/;"	m	struct:redisServer
active_defrag_ignore_bytes	server.h	/^    size_t active_defrag_ignore_bytes; \/* minimum amount of fragmentation waste to start active defrag *\/$/;"	m	struct:redisServer
active_defrag_max_scan_fields	server.h	/^    unsigned long active_defrag_max_scan_fields; \/* maximum number of fields of set\/hash\/zset\/list to process from within the main dict scan *\/$/;"	m	struct:redisServer
active_defrag_running	server.h	/^    int active_defrag_running;  \/* Active defragmentation running (holds current scan aggressiveness) *\/$/;"	m	struct:redisServer
active_defrag_threshold_lower	server.h	/^    int active_defrag_threshold_lower; \/* minimum percentage of fragmentation to start active defrag *\/$/;"	m	struct:redisServer
active_defrag_threshold_upper	server.h	/^    int active_defrag_threshold_upper; \/* maximum percentage of fragmentation at which we use maximum effort *\/$/;"	m	struct:redisServer
active_expire_effort	server.h	/^    int active_expire_effort;       \/* From 1 (default) to 10, active effort. *\/$/;"	m	struct:redisServer
active_expire_enabled	server.h	/^    int active_expire_enabled;      \/* Can be disabled for testing purposes. *\/$/;"	m	struct:redisServer
activerehashing	server.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	struct:redisServer
addACLLogEntry	acl.c	/^void addACLLogEntry(client *c, int reason, int argpos, sds username) {$/;"	f
addClientToTimeoutTable	timeout.c	/^void addClientToTimeoutTable(client *c) {$/;"	f
addClusterNode	redis-benchmark.c	/^static clusterNode **addClusterNode(clusterNode *node) {$/;"	f	file:
addHashFieldToReply	t_hash.c	/^static void addHashFieldToReply(client *c, robj *o, sds field) {$/;"	f	file:
addHashIteratorCursorToReply	t_hash.c	/^static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {$/;"	f	file:
addListRangeReply	t_list.c	/^void addListRangeReply(client *c, robj *o, long start, long end, int reverse) {$/;"	f
addNodeReplyForClusterSlot	cluster.c	/^void addNodeReplyForClusterSlot(client *c, clusterNode *node, int start_slot, int end_slot) {$/;"	f
addReply	networking.c	/^void addReply(client *c, robj *obj) {$/;"	f
addReplyAggregateLen	networking.c	/^void addReplyAggregateLen(client *c, long length, int prefix) {$/;"	f
addReplyArrayLen	networking.c	/^void addReplyArrayLen(client *c, long length) {$/;"	f
addReplyAttributeLen	networking.c	/^void addReplyAttributeLen(client *c, long length) {$/;"	f
addReplyBool	networking.c	/^void addReplyBool(client *c, int b) {$/;"	f
addReplyBulk	networking.c	/^void addReplyBulk(client *c, robj *obj) {$/;"	f
addReplyBulkCBuffer	networking.c	/^void addReplyBulkCBuffer(client *c, const void *p, size_t len) {$/;"	f
addReplyBulkCString	networking.c	/^void addReplyBulkCString(client *c, const char *s) {$/;"	f
addReplyBulkLen	networking.c	/^void addReplyBulkLen(client *c, robj *obj) {$/;"	f
addReplyBulkLongLong	networking.c	/^void addReplyBulkLongLong(client *c, long long ll) {$/;"	f
addReplyBulkSds	networking.c	/^void addReplyBulkSds(client *c, sds s)  {$/;"	f
addReplyCommand	server.c	/^void addReplyCommand(client *c, struct redisCommand *cmd) {$/;"	f
addReplyCommandCategories	acl.c	/^void addReplyCommandCategories(client *c, struct redisCommand *cmd) {$/;"	f
addReplyCommandFlag	server.c	/^int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {$/;"	f
addReplyDeferredLen	networking.c	/^void *addReplyDeferredLen(client *c) {$/;"	f
addReplyDictOfRedisInstances	sentinel.c	/^void addReplyDictOfRedisInstances(client *c, dict *instances) {$/;"	f
addReplyDouble	networking.c	/^void addReplyDouble(client *c, double d) {$/;"	f
addReplyDoubleDistance	geo.c	/^void addReplyDoubleDistance(client *c, double d) {$/;"	f
addReplyError	networking.c	/^void addReplyError(client *c, const char *err) {$/;"	f
addReplyErrorFormat	networking.c	/^void addReplyErrorFormat(client *c, const char *fmt, ...) {$/;"	f
addReplyErrorLength	networking.c	/^void addReplyErrorLength(client *c, const char *s, size_t len) {$/;"	f
addReplyErrorObject	networking.c	/^void addReplyErrorObject(client *c, robj *err) {$/;"	f
addReplyErrorSds	networking.c	/^void addReplyErrorSds(client *c, sds err) {$/;"	f
addReplyGopherItem	gopher.c	/^void addReplyGopherItem(client *c, const char *type, const char *descr,$/;"	f
addReplyHelp	networking.c	/^void addReplyHelp(client *c, const char **help) {$/;"	f
addReplyHumanLongDouble	networking.c	/^void addReplyHumanLongDouble(client *c, long double d) {$/;"	f
addReplyLoadedModules	module.c	/^void addReplyLoadedModules(client *c) {$/;"	f
addReplyLongLong	networking.c	/^void addReplyLongLong(client *c, long long ll) {$/;"	f
addReplyLongLongWithPrefix	networking.c	/^void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {$/;"	f
addReplyMapLen	networking.c	/^void addReplyMapLen(client *c, long length) {$/;"	f
addReplyNull	networking.c	/^void addReplyNull(client *c) {$/;"	f
addReplyNullArray	networking.c	/^void addReplyNullArray(client *c) {$/;"	f
addReplyProto	networking.c	/^void addReplyProto(client *c, const char *s, size_t len) {$/;"	f
addReplyPubsubMessage	pubsub.c	/^void addReplyPubsubMessage(client *c, robj *channel, robj *msg) {$/;"	f
addReplyPubsubPatMessage	pubsub.c	/^void addReplyPubsubPatMessage(client *c, robj *pat, robj *channel, robj *msg) {$/;"	f
addReplyPubsubPatSubscribed	pubsub.c	/^void addReplyPubsubPatSubscribed(client *c, robj *pattern) {$/;"	f
addReplyPubsubPatUnsubscribed	pubsub.c	/^void addReplyPubsubPatUnsubscribed(client *c, robj *pattern) {$/;"	f
addReplyPubsubSubscribed	pubsub.c	/^void addReplyPubsubSubscribed(client *c, robj *channel) {$/;"	f
addReplyPubsubUnsubscribed	pubsub.c	/^void addReplyPubsubUnsubscribed(client *c, robj *channel) {$/;"	f
addReplyPushLen	networking.c	/^void addReplyPushLen(client *c, long length) {$/;"	f
addReplyReplicationBacklog	replication.c	/^long long addReplyReplicationBacklog(client *c, long long offset) {$/;"	f
addReplySds	networking.c	/^void addReplySds(client *c, sds s) {$/;"	f
addReplySentinelRedisInstance	sentinel.c	/^void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {$/;"	f
addReplySetLen	networking.c	/^void addReplySetLen(client *c, long length) {$/;"	f
addReplyStatus	networking.c	/^void addReplyStatus(client *c, const char *status) {$/;"	f
addReplyStatusFormat	networking.c	/^void addReplyStatusFormat(client *c, const char *fmt, ...) {$/;"	f
addReplyStatusLength	networking.c	/^void addReplyStatusLength(client *c, const char *s, size_t len) {$/;"	f
addReplyStreamID	t_stream.c	/^void addReplyStreamID(client *c, streamID *id) {$/;"	f
addReplySubcommandSyntaxError	networking.c	/^void addReplySubcommandSyntaxError(client *c) {$/;"	f
addReplyVerbatim	networking.c	/^void addReplyVerbatim(client *c, const char *s, size_t len, const char *ext) {$/;"	f
addr	redismodule.h	/^    char addr[46];          \/* IPv4 or IPv6 address. *\/$/;"	m	struct:RedisModuleClientInfo
addr	sentinel.c	/^    sentinelAddr *addr; \/* Master host. *\/$/;"	m	struct:sentinelRedisInstance	file:
adjustOpenFilesLimit	server.c	/^void adjustOpenFilesLimit(void) {$/;"	f
aeApiAddEvent	ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_evport.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAssociate	ae_evport.c	/^static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {$/;"	f	file:
aeApiCreate	ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_evport.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	ae_evport.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_evport.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiLookupPending	ae_evport.c	/^static int aeApiLookupPending(aeApiState *state, int fd) {$/;"	f	file:
aeApiName	ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_evport.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_evport.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiResize	ae_epoll.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	ae_evport.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	ae_kqueue.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	ae_select.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiState	ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_evport.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_evport.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	ae.c	/^aeEventLoop *aeCreateEventLoop(int setsize) {$/;"	f
aeCreateFileEvent	ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateTimeEvent	ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeDeleteEventLoop	ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetFileEvents	ae.c	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {$/;"	f
aeGetSetSize	ae.c	/^int aeGetSetSize(aeEventLoop *eventLoop) {$/;"	f
aeMain	ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeResizeSetSize	ae.c	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {$/;"	f
aeSetAfterSleepProc	ae.c	/^void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {$/;"	f
aeSetBeforeSleepProc	ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f
aeSetDontWait	ae.c	/^void aeSetDontWait(aeEventLoop *eventLoop, int noWait) {$/;"	f
aeStop	ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeTimer	module.c	/^long long aeTimer = -1; \/* Main event loop (ae.c) timer identifier. *\/$/;"	v
aeWait	ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
ae_handler	connection.h	/^    void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);$/;"	m	struct:ConnectionType
afterErrorReply	networking.c	/^void afterErrorReply(client *c, const char *s, size_t len) {$/;"	f
afterPropagateExec	multi.c	/^void afterPropagateExec() {$/;"	f
afterSleep	server.c	/^void afterSleep(struct aeEventLoop *eventLoop) {$/;"	f
aftersleep	ae.h	/^    aeBeforeSleepProc *aftersleep;$/;"	m	struct:aeEventLoop
alias	config.c	/^    const char *alias; \/* An alias that can also be used for this config *\/$/;"	m	struct:standardConfig	file:
allPersistenceDisabled	server.c	/^int allPersistenceDisabled(void) {$/;"	f
all_time_high	latency.h	/^    uint32_t all_time_high; \/* Absolute max observed since latest reset. *\/$/;"	m	struct:latencyStats
alloc	redis-cli.c	/^    clusterManagerNode **alloc; \/* Pointer to the allocated memory *\/$/;"	m	struct:clusterManagerNodeArray	file:
alloc	sds.h	/^    uint16_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr16
alloc	sds.h	/^    uint32_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr32
alloc	sds.h	/^    uint64_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr64
alloc	sds.h	/^    uint8_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr8
allocator_active	server.h	/^    size_t allocator_active;$/;"	m	struct:malloc_stats
allocator_allocated	server.h	/^    size_t allocator_allocated;$/;"	m	struct:malloc_stats
allocator_frag	server.h	/^    float allocator_frag;$/;"	m	struct:redisMemOverhead
allocator_frag_bytes	server.h	/^    ssize_t allocator_frag_bytes;$/;"	m	struct:redisMemOverhead
allocator_resident	server.h	/^    size_t allocator_resident;$/;"	m	struct:malloc_stats
allocator_rss	server.h	/^    float allocator_rss;$/;"	m	struct:redisMemOverhead
allocator_rss_bytes	server.h	/^    ssize_t allocator_rss_bytes;$/;"	m	struct:redisMemOverhead
allowed_commands	server.h	/^    uint64_t allowed_commands[USER_COMMAND_BITS_COUNT\/64];$/;"	m	struct:__anon45
allowed_subcommands	server.h	/^    sds **allowed_subcommands;$/;"	m	struct:__anon45
already_expired	redis-check-rdb.c	/^    unsigned long already_expired;  \/* Number of keys already expired. *\/$/;"	m	struct:__anon34	file:
alsoPropagate	server.c	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f
also_propagate	server.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	struct:redisServer
always_show_logo	server.h	/^    int always_show_logo;       \/* Show logo even for non-stdout logging. *\/$/;"	m	struct:redisServer
amqueue	module.c	/^    struct AutoMemEntry *amqueue;   \/* Auto memory queue of objects to free. *\/$/;"	m	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::AutoMemEntry	file:
amqueue_len	module.c	/^    int amqueue_len;                \/* Number of slots in amqueue. *\/$/;"	m	struct:RedisModuleCtx	file:
amqueue_used	module.c	/^    int amqueue_used;               \/* Number of used slots in amqueue. *\/$/;"	m	struct:RedisModuleCtx	file:
analyzeLatencyForEvent	latency.c	/^void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {$/;"	f
anetBlock	anet.c	/^int anetBlock(char *err, int fd) {$/;"	f
anetCloexec	anet.c	/^int anetCloexec(int fd) {$/;"	f
anetCreateSocket	anet.c	/^static int anetCreateSocket(char *err, int domain) {$/;"	f	file:
anetDisableTcpNoDelay	anet.c	/^int anetDisableTcpNoDelay(char *err, int fd)$/;"	f
anetEnableTcpNoDelay	anet.c	/^int anetEnableTcpNoDelay(char *err, int fd)$/;"	f
anetFdToString	anet.c	/^int anetFdToString(int fd, char *ip, size_t ip_len, int *port, int fd_to_str_type) {$/;"	f
anetFormatAddr	anet.c	/^int anetFormatAddr(char *buf, size_t buf_len, char *ip, int port) {$/;"	f
anetFormatFdAddr	anet.c	/^int anetFormatFdAddr(int fd, char *buf, size_t buf_len, int fd_to_str_type) {$/;"	f
anetGenericAccept	anet.c	/^static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {$/;"	f	file:
anetKeepAlive	anet.c	/^int anetKeepAlive(char *err, int fd, int interval)$/;"	f
anetListen	anet.c	/^static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {$/;"	f	file:
anetNonBlock	anet.c	/^int anetNonBlock(char *err, int fd) {$/;"	f
anetRecvTimeout	anet.c	/^int anetRecvTimeout(char *err, int fd, long long ms) {$/;"	f
anetResolve	anet.c	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,$/;"	f
anetSendTimeout	anet.c	/^int anetSendTimeout(char *err, int fd, long long ms) {$/;"	f
anetSetBlock	anet.c	/^int anetSetBlock(char *err, int fd, int non_block) {$/;"	f
anetSetError	anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:
anetSetReuseAddr	anet.c	/^static int anetSetReuseAddr(char *err, int fd) {$/;"	f	file:
anetSetTcpNoDelay	anet.c	/^static int anetSetTcpNoDelay(char *err, int fd, int val)$/;"	f	file:
anetTcp6Server	anet.c	/^int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)$/;"	f
anetTcpAccept	anet.c	/^int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {$/;"	f
anetTcpGenericConnect	anet.c	/^static int anetTcpGenericConnect(char *err, const char *addr, int port,$/;"	f	file:
anetTcpNonBlockBestEffortBindConnect	anet.c	/^int anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port,$/;"	f
anetTcpNonBlockConnect	anet.c	/^int anetTcpNonBlockConnect(char *err, const char *addr, int port)$/;"	f
anetTcpServer	anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr, int backlog)$/;"	f
anetUnixAccept	anet.c	/^int anetUnixAccept(char *err, int s) {$/;"	f
anetUnixGenericConnect	anet.c	/^int anetUnixGenericConnect(char *err, const char *path, int flags)$/;"	f
anetUnixServer	anet.c	/^int anetUnixServer(char *err, char *path, mode_t perm, int backlog)$/;"	f
anetV6Only	anet.c	/^static int anetV6Only(char *err, int s) {$/;"	f	file:
announceSentinelAddr	sentinel.c	/^const char *announceSentinelAddr(const sentinelAddr *a) {$/;"	f
announceSentinelAddrAndPort	sentinel.c	/^sds announceSentinelAddrAndPort(const sentinelAddr *a) {$/;"	f
announce_hostnames	sentinel.c	/^    int announce_hostnames;      \/* Announce hostnames instead of IPs when we have them. *\/$/;"	m	struct:sentinelState	file:
announce_ip	sentinel.c	/^    char *announce_ip;  \/* IP addr that is gossiped to other sentinels if$/;"	m	struct:sentinelState	file:
announce_port	sentinel.c	/^    int announce_port;  \/* Port that is gossiped to other sentinels if$/;"	m	struct:sentinelState	file:
anyOtherSlaveWaitRdb	networking.c	/^int anyOtherSlaveWaitRdb(client *except_me) {$/;"	f
aofChildPipeReadable	aof.c	/^void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
aofChildWriteDiffData	aof.c	/^void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
aofClosePipes	aof.c	/^void aofClosePipes(void) {$/;"	f
aofCreatePipes	aof.c	/^int aofCreatePipes(void) {$/;"	f
aofFsyncInProgress	aof.c	/^int aofFsyncInProgress(void) {$/;"	f
aofReadDiffFromParent	aof.c	/^ssize_t aofReadDiffFromParent(void) {$/;"	f
aofRemoveTempFile	aof.c	/^void aofRemoveTempFile(pid_t childpid) {$/;"	f
aofRewriteBufferAppend	aof.c	/^void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {$/;"	f
aofRewriteBufferReset	aof.c	/^void aofRewriteBufferReset(void) {$/;"	f
aofRewriteBufferSize	aof.c	/^unsigned long aofRewriteBufferSize(void) {$/;"	f
aofRewriteBufferWrite	aof.c	/^ssize_t aofRewriteBufferWrite(int fd) {$/;"	f
aofUpdateCurrentSize	aof.c	/^void aofUpdateCurrentSize(void) {$/;"	f
aofWrite	aof.c	/^ssize_t aofWrite(int fd, const char *buf, size_t len) {$/;"	f
aof_background_fsync	aof.c	/^void aof_background_fsync(int fd) {$/;"	f
aof_bio_fsync_errno	server.h	/^    redisAtomic int aof_bio_fsync_errno;  \/* Errno of AOF fsync in bio job. *\/$/;"	m	struct:redisServer
aof_bio_fsync_status	server.h	/^    redisAtomic int aof_bio_fsync_status; \/* Status of AOF fsync in bio job. *\/$/;"	m	struct:redisServer
aof_buf	server.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	struct:redisServer
aof_buffer	server.h	/^    size_t aof_buffer;$/;"	m	struct:redisMemOverhead
aof_child_diff	server.h	/^    sds aof_child_diff;             \/* AOF diff accumulator child side. *\/$/;"	m	struct:redisServer
aof_current_size	server.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	struct:redisServer
aof_delayed_fsync	server.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	struct:redisServer
aof_enabled	server.h	/^    int aof_enabled;                \/* AOF configuration *\/$/;"	m	struct:redisServer
aof_fd	server.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	struct:redisServer
aof_filename	server.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	struct:redisServer
aof_flush_postponed_start	server.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	struct:redisServer
aof_flush_sleep	server.h	/^    int aof_flush_sleep;            \/* Micros to sleep before flush. (used by tests) *\/$/;"	m	struct:redisServer
aof_fsync	server.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	struct:redisServer
aof_fsync_enum	config.c	/^configEnum aof_fsync_enum[] = {$/;"	v
aof_fsync_offset	server.h	/^    off_t aof_fsync_offset;         \/* AOF offset which is already synced to disk. *\/$/;"	m	struct:redisServer
aof_last_fsync	server.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	struct:redisServer
aof_last_write_errno	server.h	/^    int aof_last_write_errno;       \/* Valid if aof write\/fsync status is ERR *\/$/;"	m	struct:redisServer
aof_last_write_status	server.h	/^    int aof_last_write_status;      \/* C_OK or C_ERR *\/$/;"	m	struct:redisServer
aof_lastbgrewrite_status	server.h	/^    int aof_lastbgrewrite_status;   \/* C_OK or C_ERR *\/$/;"	m	struct:redisServer
aof_load_truncated	server.h	/^    int aof_load_truncated;         \/* Don't stop on unexpected AOF EOF. *\/$/;"	m	struct:redisServer
aof_no_fsync_on_rewrite	server.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	struct:redisServer
aof_pipe_read_ack_from_child	server.h	/^    int aof_pipe_read_ack_from_child;$/;"	m	struct:redisServer
aof_pipe_read_ack_from_parent	server.h	/^    int aof_pipe_read_ack_from_parent;$/;"	m	struct:redisServer
aof_pipe_read_data_from_parent	server.h	/^    int aof_pipe_read_data_from_parent;$/;"	m	struct:redisServer
aof_pipe_write_ack_to_child	server.h	/^    int aof_pipe_write_ack_to_child;$/;"	m	struct:redisServer
aof_pipe_write_ack_to_parent	server.h	/^    int aof_pipe_write_ack_to_parent;$/;"	m	struct:redisServer
aof_pipe_write_data_to_child	server.h	/^    int aof_pipe_write_data_to_child;$/;"	m	struct:redisServer
aof_rewrite	redismodule.h	/^    RedisModuleTypeRewriteFunc aof_rewrite;$/;"	m	struct:RedisModuleTypeMethods
aof_rewrite	server.h	/^    moduleTypeRewriteFunc aof_rewrite;$/;"	m	struct:RedisModuleType
aof_rewrite_base_size	server.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	struct:redisServer
aof_rewrite_buf_blocks	server.h	/^    list *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	struct:redisServer
aof_rewrite_cpulist	server.h	/^    char *aof_rewrite_cpulist; \/* cpu affinity list of aof rewrite process. *\/$/;"	m	struct:redisServer
aof_rewrite_incremental_fsync	server.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while aof rewriting? *\/$/;"	m	struct:redisServer
aof_rewrite_min_size	server.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	struct:redisServer
aof_rewrite_perc	server.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	struct:redisServer
aof_rewrite_scheduled	server.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	struct:redisServer
aof_rewrite_time_last	server.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	struct:redisServer
aof_rewrite_time_start	server.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	struct:redisServer
aof_selected_db	server.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	struct:redisServer
aof_state	server.h	/^    int aof_state;                  \/* AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	struct:redisServer
aof_stop_sending_diff	server.h	/^    int aof_stop_sending_diff;     \/* If true stop sending accumulated diffs$/;"	m	struct:redisServer
aof_use_rdb_preamble	server.h	/^    int aof_use_rdb_preamble;       \/* Use RDB preamble on AOF rewrites. *\/$/;"	m	struct:redisServer
aofrwblock	aof.c	/^typedef struct aofrwblock {$/;"	s	file:
aofrwblock	aof.c	/^} aofrwblock;$/;"	t	typeref:struct:aofrwblock	file:
apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
apiver	module.c	/^    int apiver;     \/* Module API version as requested during initialization.*\/$/;"	m	struct:RedisModule	file:
appendCommand	t_string.c	/^void appendCommand(client *c) {$/;"	f
appendServerSaveParams	config.c	/^void appendServerSaveParams(time_t seconds, int changes) {$/;"	f
appendonly	redis-benchmark.c	/^    sds appendonly;$/;"	m	struct:redisConfig	file:
approx_trim	t_stream.c	/^    int approx_trim; \/* If 1 only delete whole radix tree nodes, so$/;"	m	struct:__anon59	file:
arch_bits	server.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	struct:redisServer
areClientsPaused	networking.c	/^int areClientsPaused(void) {$/;"	f
area	geohash_helper.h	/^    GeoHashArea area;$/;"	m	struct:__anon27
arg0	setproctitle.c	/^	const char *arg0;$/;"	m	struct:__anon56	file:
argc	module.c	/^    int argc;$/;"	m	struct:RedisModuleCommandFilterCtx	file:
argc	redis-cli.c	/^    int argc;$/;"	m	struct:__anon35	file:
argc	redis-cli.c	/^    int argc;$/;"	m	struct:clusterManagerCommand	file:
argc	server.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
argc	server.h	/^    int argc;               \/* Num of arguments of current command. *\/$/;"	m	struct:client
argc	server.h	/^    int argc;$/;"	m	struct:moduleLoadQueueEntry
argc	server.h	/^    int argc;$/;"	m	struct:multiCmd
argc	server.h	/^    int argc;$/;"	m	struct:sentinelLoadQueueEntry
argc	slowlog.h	/^    int argc;$/;"	m	struct:slowlogEntry
args	redis-cli.c	/^    char *args;$/;"	m	struct:clusterManagerCommandDef	file:
argv	module.c	/^    RedisModuleString **argv;$/;"	m	struct:RedisModuleCommandFilterCtx	file:
argv	redis-cli.c	/^    char **argv;$/;"	m	struct:clusterManagerCommand	file:
argv	redis-cli.c	/^    sds *argv;$/;"	m	struct:__anon35	file:
argv	sentinel.c	/^    char **argv;            \/* Arguments to call the script. *\/$/;"	m	struct:sentinelScriptJob	file:
argv	server.h	/^    robj **argv;            \/* Arguments of current command. *\/$/;"	m	struct:client
argv	server.h	/^    robj **argv;$/;"	m	struct:moduleLoadQueueEntry
argv	server.h	/^    robj **argv;$/;"	m	struct:multiCmd
argv	server.h	/^    robj **argv;$/;"	m	struct:redisOp
argv	server.h	/^    sds *argv;$/;"	m	struct:sentinelLoadQueueEntry
argv	slowlog.h	/^    robj **argv;$/;"	m	struct:slowlogEntry
argv_len_sum	server.h	/^    size_t argv_len_sum;    \/* Sum of lengths of objects in argv list. *\/$/;"	m	struct:client
arity	redis-cli.c	/^    int arity;$/;"	m	struct:clusterManagerCommandDef	file:
arity	server.h	/^    int arity;$/;"	m	struct:redisCommand
array	geo.h	/^    struct geoPoint *array;$/;"	m	struct:geoArray	typeref:struct:geoArray::geoPoint
array	module.c	/^        struct RedisModuleCallReply *array; \/* Array of sub-reply elements. *\/$/;"	m	union:RedisModuleCallReply::__anon31	typeref:struct:RedisModuleCallReply::__anon31::RedisModuleCallReply	file:
ascii_logo	asciilogo.h	/^const char *ascii_logo =$/;"	v
askPassword	redis-cli.c	/^static sds askPassword(const char *msg) {$/;"	f	file:
askingCommand	cluster.c	/^void askingCommand(client *c) {$/;"	f
askpass	redis-cli.c	/^    int askpass;$/;"	m	struct:config	file:
assert	redisassert.h	43;"	d
asyncCloseClientOnOutputBufferLimitReached	networking.c	/^void asyncCloseClientOnOutputBufferLimitReached(client *c) {$/;"	f
atomicDecr	atomicvar.h	117;"	d
atomicDecr	atomicvar.h	136;"	d
atomicDecr	atomicvar.h	96;"	d
atomicGet	atomicvar.h	118;"	d
atomicGet	atomicvar.h	137;"	d
atomicGet	atomicvar.h	97;"	d
atomicGetIncr	atomicvar.h	114;"	d
atomicGetIncr	atomicvar.h	133;"	d
atomicGetIncr	atomicvar.h	93;"	d
atomicGetWithSync	atomicvar.h	101;"	d
atomicGetWithSync	atomicvar.h	122;"	d
atomicGetWithSync	atomicvar.h	144;"	d
atomicIncr	atomicvar.h	113;"	d
atomicIncr	atomicvar.h	132;"	d
atomicIncr	atomicvar.h	92;"	d
atomicSet	atomicvar.h	100;"	d
atomicSet	atomicvar.h	121;"	d
atomicSet	atomicvar.h	140;"	d
atomicSetWithSync	atomicvar.h	104;"	d
atomicSetWithSync	atomicvar.h	125;"	d
atomicSetWithSync	atomicvar.h	148;"	d
attempted_compress	quicklist.h	/^    unsigned int attempted_compress : 1; \/* node can't compress; too small *\/$/;"	m	struct:quicklistNode
auth	redis-benchmark.c	/^    char *auth;$/;"	m	struct:config	file:
auth	redis-cli.c	/^    char *auth;$/;"	m	struct:config	file:
authCommand	acl.c	/^void authCommand(client *c) {$/;"	f
auth_callback	server.h	/^    RedisModuleUserChangedFunc auth_callback; \/* Module callback to execute$/;"	m	struct:client
auth_callback_privdata	server.h	/^    void *auth_callback_privdata; \/* Private data that is passed when the auth$/;"	m	struct:client
auth_module	server.h	/^    void *auth_module;      \/* The module that owns the callback, which is used$/;"	m	struct:client
auth_pass	sentinel.c	/^    char *auth_pass;    \/* Password to use for AUTH against master & replica. *\/$/;"	m	struct:sentinelRedisInstance	file:
auth_user	sentinel.c	/^    char *auth_user;    \/* Username for ACLs AUTH against master & replica. *\/$/;"	m	struct:sentinelRedisInstance	file:
authenticateClientWithUser	module.c	/^static int authenticateClientWithUser(RedisModuleCtx *ctx, user *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {$/;"	f	file:
authenticated	server.h	/^    int authenticated;      \/* Needed when the default user requires auth. *\/$/;"	m	struct:client
autoMemoryAdd	module.c	/^void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {$/;"	f
autoMemoryCollect	module.c	/^void autoMemoryCollect(RedisModuleCtx *ctx) {$/;"	f
autoMemoryFreed	module.c	/^int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {$/;"	f
autosync	rio.h	/^            off_t autosync; \/* fsync after 'autosync' bytes written. *\/$/;"	m	struct:_rio::__anon37::__anon39
aux_load	redismodule.h	/^    RedisModuleTypeAuxLoadFunc aux_load;$/;"	m	struct:RedisModuleTypeMethods
aux_load	server.h	/^    moduleTypeAuxLoadFunc aux_load;$/;"	m	struct:RedisModuleType
aux_save	redismodule.h	/^    RedisModuleTypeAuxSaveFunc aux_save;$/;"	m	struct:RedisModuleTypeMethods
aux_save	server.h	/^    moduleTypeAuxSaveFunc aux_save;$/;"	m	struct:RedisModuleType
aux_save_triggers	redismodule.h	/^    int aux_save_triggers;$/;"	m	struct:RedisModuleTypeMethods
aux_save_triggers	server.h	/^    int aux_save_triggers;$/;"	m	struct:RedisModuleType
avg	latency.h	/^    uint32_t avg;           \/* Average of current samples. *\/$/;"	m	struct:latencyStats
avg_ttl	server.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	struct:redisDb
backgroundRewriteDoneHandler	aof.c	/^void backgroundRewriteDoneHandler(int exitcode, int bysignal) {$/;"	f
backgroundSaveDoneHandler	rdb.c	/^void backgroundSaveDoneHandler(int exitcode, int bysignal) {$/;"	f
backgroundSaveDoneHandlerDisk	rdb.c	/^static void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {$/;"	f	file:
backgroundSaveDoneHandlerSocket	rdb.c	/^static void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {$/;"	f	file:
background_duration	module.c	/^    uint64_t background_duration; \/* Current command background time duration.$/;"	m	struct:RedisModuleBlockedClient	file:
background_timer	module.c	/^    monotime background_timer; \/* Timer tracking the start of background work *\/$/;"	m	struct:RedisModuleBlockedClient	file:
backupDb	db.c	/^dbBackup *backupDb(void) {$/;"	f
backup_dir	redis-cli.c	/^    char *backup_dir;$/;"	m	struct:clusterManagerCommand	file:
backward	server.h	/^    struct zskiplistNode *backward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode
balance	redis-cli.c	/^    int balance;    \/* Used by rebalance *\/$/;"	m	struct:clusterManagerNode	file:
base	setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon56	file:
bcastState	tracking.c	/^typedef struct bcastState {$/;"	s	file:
bcastState	tracking.c	/^} bcastState;$/;"	t	typeref:struct:bcastState	file:
beforePropagateMulti	multi.c	/^void beforePropagateMulti() {$/;"	f
beforeSleep	server.c	/^void beforeSleep(struct aeEventLoop *eventLoop) {$/;"	f
beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
beginResultEmission	t_zset.c	/^    zrangeResultBeginFunction            beginResultEmission;$/;"	m	struct:zrange_result_handler	file:
benchmark	redis-benchmark.c	/^static void benchmark(char *title, char *cmd, int len) {$/;"	f	file:
benchmarkThread	redis-benchmark.c	/^typedef struct benchmarkThread {$/;"	s	file:
benchmarkThread	redis-benchmark.c	/^} benchmarkThread;$/;"	t	typeref:struct:benchmarkThread	file:
benchmarkVersion	redis-benchmark.c	/^static sds benchmarkVersion(void) {$/;"	f	file:
bg_unlink	replication.c	/^int bg_unlink(const char *filename) {$/;"	f
bgrewriteaofCommand	aof.c	/^void bgrewriteaofCommand(client *c) {$/;"	f
bgsaveCommand	rdb.c	/^void bgsaveCommand(client *c) {$/;"	f
bgsave_cpulist	server.h	/^    char *bgsave_cpulist; \/* cpu affinity list of bgsave process. *\/$/;"	m	struct:redisServer
bgsaveerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
biggest	redis-cli.c	/^    unsigned long long biggest;$/;"	m	struct:__anon36	file:
biggest_key	redis-cli.c	/^    sds biggest_key;$/;"	m	struct:__anon36	file:
bigkeys	redis-cli.c	/^    int bigkeys;$/;"	m	struct:config	file:
bindaddr	server.h	/^    char *bindaddr[CONFIG_BINDADDR_MAX]; \/* Addresses we should bind to *\/$/;"	m	struct:redisServer
bindaddr_count	server.h	/^    int bindaddr_count;         \/* Number of addresses in server.bindaddr[] *\/$/;"	m	struct:redisServer
bioCreateCloseJob	bio.c	/^void bioCreateCloseJob(int fd) {$/;"	f
bioCreateFsyncJob	bio.c	/^void bioCreateFsyncJob(int fd) {$/;"	f
bioCreateLazyFreeJob	bio.c	/^void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) {$/;"	f
bioInit	bio.c	/^void bioInit(void) {$/;"	f
bioKillThreads	bio.c	/^void bioKillThreads(void) {$/;"	f
bioPendingJobsOfType	bio.c	/^unsigned long long bioPendingJobsOfType(int type) {$/;"	f
bioProcessBackgroundJobs	bio.c	/^void *bioProcessBackgroundJobs(void *arg) {$/;"	f
bioSubmitJob	bio.c	/^void bioSubmitJob(int type, struct bio_job *job) {$/;"	f
bioWaitStepOfType	bio.c	/^unsigned long long bioWaitStepOfType(int type) {$/;"	f
bio_cpulist	server.h	/^    char *bio_cpulist; \/* cpu affinity list of bio thread. *\/$/;"	m	struct:redisServer
bio_job	bio.c	/^struct bio_job {$/;"	s	file:
bio_jobs	bio.c	/^static list *bio_jobs[BIO_NUM_OPS];$/;"	v	file:
bio_mutex	bio.c	/^static pthread_mutex_t bio_mutex[BIO_NUM_OPS];$/;"	v	file:
bio_newjob_cond	bio.c	/^static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];$/;"	v	file:
bio_pending	bio.c	/^static unsigned long long bio_pending[BIO_NUM_OPS];$/;"	v	file:
bio_step_cond	bio.c	/^static pthread_cond_t bio_step_cond[BIO_NUM_OPS];$/;"	v	file:
bio_threads	bio.c	/^static pthread_t bio_threads[BIO_NUM_OPS];$/;"	v	file:
bitcountCommand	bitops.c	/^void bitcountCommand(client *c) {$/;"	f
bitfieldCommand	bitops.c	/^void bitfieldCommand(client *c) {$/;"	f
bitfieldGeneric	bitops.c	/^void bitfieldGeneric(client *c, int flags) {$/;"	f
bitfieldOp	bitops.c	/^struct bitfieldOp {$/;"	s	file:
bitfieldroCommand	bitops.c	/^void bitfieldroCommand(client *c) {$/;"	f
bitlen	sha256.h	/^	unsigned long long bitlen;$/;"	m	struct:__anon58
bitmapClearBit	cluster.c	/^void bitmapClearBit(unsigned char *bitmap, int pos) {$/;"	f
bitmapSetBit	cluster.c	/^void bitmapSetBit(unsigned char *bitmap, int pos) {$/;"	f
bitmapTestBit	cluster.c	/^int bitmapTestBit(unsigned char *bitmap, int pos) {$/;"	f
bitopCommand	bitops.c	/^void bitopCommand(client *c) {$/;"	f
bitposCommand	bitops.c	/^void bitposCommand(client *c) {$/;"	f
bits	bitops.c	/^    int bits;           \/* Integer bitfield bits width. *\/$/;"	m	struct:bitfieldOp	file:
bits	geohash.h	/^    uint64_t bits;$/;"	m	struct:__anon20
bkinfo	blocked.c	/^typedef struct bkinfo {$/;"	s	file:
bkinfo	blocked.c	/^} bkinfo;$/;"	t	typeref:struct:bkinfo	file:
blk	sha1.c	43;"	d	file:
blk0	sha1.c	36;"	d	file:
blk0	sha1.c	39;"	d	file:
blmove	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
blmoveCommand	t_list.c	/^void blmoveCommand(client *c) {$/;"	f
blmoveGenericCommand	t_list.c	/^void blmoveGenericCommand(client *c, int wherefrom, int whereto, mstime_t timeout) {$/;"	f
blockClient	blocked.c	/^void blockClient(client *c, int btype) {$/;"	f
blockForKeys	blocked.c	/^void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, robj *target, struct listPos *listpos, streamID *ids) {$/;"	f
blocked_client	module.c	/^    struct RedisModuleBlockedClient *blocked_client; \/* Blocked client for$/;"	m	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModuleBlockedClient	file:
blocked_clients	module.c	/^    int blocked_clients;         \/* Count of RedisModuleBlockedClient in this module. *\/$/;"	m	struct:RedisModule	file:
blocked_clients	server.h	/^    unsigned int blocked_clients;   \/* # of clients executing a blocking cmd.*\/$/;"	m	struct:redisServer
blocked_clients_by_type	server.h	/^    unsigned int blocked_clients_by_type[BLOCKED_NUM];$/;"	m	struct:redisServer
blocked_last_cron	server.h	/^    long long blocked_last_cron; \/* Indicate the mstime of the last time we did cron jobs from a blocking operation *\/$/;"	m	struct:redisServer
blocked_on_keys	module.c	/^    int blocked_on_keys;    \/* If blocked via RM_BlockClientOnKeys(). *\/$/;"	m	struct:RedisModuleBlockedClient	file:
blocked_privdata	module.c	/^    void *blocked_privdata;         \/* Privdata set when unblocking a client. *\/$/;"	m	struct:RedisModuleCtx	file:
blocked_ready_key	module.c	/^    RedisModuleString *blocked_ready_key; \/* Key ready when the reply callback$/;"	m	struct:RedisModuleCtx	file:
blockingGenericZpopCommand	t_zset.c	/^void blockingGenericZpopCommand(client *c, int where) {$/;"	f
blockingOperationEnds	server.c	/^void blockingOperationEnds() {$/;"	f
blockingOperationStarts	server.c	/^void blockingOperationStarts() {$/;"	f
blockingPopGenericCommand	t_list.c	/^void blockingPopGenericCommand(client *c, int where) {$/;"	f
blockingState	server.h	/^typedef struct blockingState {$/;"	s
blockingState	server.h	/^} blockingState;$/;"	t	typeref:struct:blockingState
blocking_connect	connection.h	/^    int (*blocking_connect)(struct connection *conn, const char *addr, int port, long long timeout);$/;"	m	struct:ConnectionType
blocking_keys	server.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP)*\/$/;"	m	struct:redisDb
blocking_op_nesting	server.h	/^    size_t blocking_op_nesting; \/* Nesting level of blocking operation, used to reset blocked_last_cron. *\/$/;"	m	struct:redisServer
blpopCommand	t_list.c	/^void blpopCommand(client *c) {$/;"	f
bookmark_count	quicklist.h	/^    unsigned int bookmark_count: QL_BM_BITS;$/;"	m	struct:quicklist
bookmarks	quicklist.h	/^    quicklistBookmark bookmarks[];$/;"	m	struct:quicklist
boolConfigData	config.c	/^typedef struct boolConfigData {$/;"	s	file:
boolConfigData	config.c	/^} boolConfigData;$/;"	t	typeref:struct:boolConfigData	file:
bounds	geohash.h	/^    double bounds[4]; \/* bounds[0]: min_lon, bounds[1]: min_lat$/;"	m	struct:__anon24
bp	scripting.c	/^    int bp[LDB_BREAKPOINTS_MAX]; \/* An array of breakpoints line numbers. *\/$/;"	m	struct:ldbState	file:
bpcount	scripting.c	/^    int bpcount; \/* Number of valid entries inside bp. *\/$/;"	m	struct:ldbState	file:
bpop	server.h	/^    blockingState bpop;     \/* blocking state *\/$/;"	m	struct:client
brpopCommand	t_list.c	/^void brpopCommand(client *c) {$/;"	f
brpoplpushCommand	t_list.c	/^void brpoplpushCommand(client *c) {$/;"	f
btype	server.h	/^    int btype;              \/* Type of blocking op if CLIENT_BLOCKED. *\/$/;"	m	struct:client
buckets	geo.h	/^    size_t buckets;$/;"	m	struct:geoArray
buf	aof.c	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	struct:aofrwblock	file:
buf	rio.h	/^            sds buf;      \/* buffered data *\/$/;"	m	struct:_rio::__anon37::__anon40
buf	rio.h	/^            sds buf;$/;"	m	struct:_rio::__anon37::__anon41
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr16
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr32
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr5
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr64
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr8
buf	server.h	/^    char buf[PROTO_REPLY_CHUNK_BYTES];$/;"	m	struct:client
buf	server.h	/^    char buf[];$/;"	m	struct:clientReplyBlock
buffer	rio.h	/^        } buffer;$/;"	m	union:_rio::__anon37	typeref:struct:_rio::__anon37::__anon38
buffer	sha1.h	/^    unsigned char buffer[64];$/;"	m	struct:__anon57
buffered	rio.h	/^            off_t buffered; \/* Bytes written since last fsync. *\/$/;"	m	struct:_rio::__anon37::__anon39
bufpos	server.h	/^    int bufpos;$/;"	m	struct:client
bugReportEnd	debug.c	/^void bugReportEnd(int killViaSignal, int sig) {$/;"	f
bugReportStart	debug.c	/^void bugReportStart(void) {$/;"	f
bug_report_start	debug.c	/^static int bug_report_start = 0; \/* True if bug report header was already logged. *\/$/;"	v	file:
bug_report_start_mutex	debug.c	/^static pthread_mutex_t bug_report_start_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
bulk_data	cluster.h	/^    unsigned char bulk_data[3]; \/* 3 bytes just as placeholder. *\/$/;"	m	struct:__anon6
bulk_data	cluster.h	/^    unsigned char bulk_data[8]; \/* 8 bytes just as placeholder. *\/$/;"	m	struct:__anon4
bulkhdr	server.h	/^    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  \/* "$<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct
bulklen	server.h	/^    long bulklen;           \/* Length of bulk argument in multi bulk request. *\/$/;"	m	struct:client
busykeyerr	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
bytes	server.h	/^    size_t bytes;       \/* Bytes read \/ written so far. *\/$/;"	m	struct:RedisModuleIO
bytesToHuman	redis-cli.c	/^void bytesToHuman(char *s, long long n) {$/;"	f
bytesToHuman	server.c	/^void bytesToHuman(char *s, unsigned long long n) {$/;"	f
bytes_per_key	server.h	/^    size_t bytes_per_key;$/;"	m	struct:redisMemOverhead
bzpopmaxCommand	t_zset.c	/^void bzpopmaxCommand(client *c) {$/;"	f
bzpopminCommand	t_zset.c	/^void bzpopminCommand(client *c) {$/;"	f
c	defrag.c	/^    streamConsumer *c;$/;"	m	struct:__anon17	file:
c	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
c	tls.c	/^    connection c;$/;"	m	struct:tls_connection	file:
ca_cert_dir	server.h	/^    char *ca_cert_dir;$/;"	m	struct:redisTLSContextConfig
ca_cert_file	server.h	/^    char *ca_cert_file;$/;"	m	struct:redisTLSContextConfig
cacert	cli_common.h	/^    char *cacert;$/;"	m	struct:cliSSLconfig
cacertdir	cli_common.h	/^    char *cacertdir;$/;"	m	struct:cliSSLconfig
cached	evict.c	/^    sds cached;                 \/* Cached SDS object for key name. *\/$/;"	m	struct:evictionPoolEntry	file:
cached_master	server.h	/^    client *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	struct:redisServer
call	server.c	/^void call(client *c, int flags) {$/;"	f
callHandler	connhelpers.h	/^static inline int callHandler(connection *conn, ConnectionCallbackFunc handler) {$/;"	f
callback	module.c	/^    RedisModuleClusterMessageReceiver callback;$/;"	m	struct:moduleClusterReceiver	file:
callback	module.c	/^    RedisModuleCommandFilterFunc callback;$/;"	m	struct:RedisModuleCommandFilter	file:
callback	module.c	/^    RedisModuleEventCallback callback;$/;"	m	struct:RedisModuleEventListener	file:
callback	module.c	/^    RedisModuleTimerProc callback;      \/* The callback to invoke on expire. *\/$/;"	m	struct:RedisModuleTimer	file:
calloc	zmalloc.c	71;"	d	file:
calloc	zmalloc.c	76;"	d	file:
calls	server.h	/^    long long microseconds, calls, rejected_calls, failed_calls;$/;"	m	struct:redisCommand
canFeedReplicaReplBuffer	replication.c	/^int canFeedReplicaReplBuffer(client *replica) {$/;"	f
cancelReplicationHandshake	replication.c	/^int cancelReplicationHandshake(int reconnect) {$/;"	f
cant_failover_reason	cluster.h	/^    int cant_failover_reason;   \/* Why a slave is currently not able to$/;"	m	struct:clusterState
card	hyperloglog.c	/^    uint8_t card[8];    \/* Cached cardinality, little endian. *\/$/;"	m	struct:hllhdr	file:
catAppendOnlyExpireAtCommand	aof.c	/^sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {$/;"	f
catAppendOnlyGenericCommand	aof.c	/^sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {$/;"	f
catClientInfoString	networking.c	/^sds catClientInfoString(sds s, client *client) {$/;"	f
cbuf	scripting.c	/^    sds cbuf;   \/* Debugger client command buffer. *\/$/;"	m	struct:ldbState	file:
cc	sentinel.c	/^    redisAsyncContext *cc; \/* Hiredis context for commands. *\/$/;"	m	struct:instanceLink	file:
cc_conn_time	sentinel.c	/^    mstime_t cc_conn_time; \/* cc connection time. *\/$/;"	m	struct:instanceLink	file:
cert	cli_common.h	/^    char *cert;$/;"	m	struct:cliSSLconfig
cert_file	server.h	/^    char *cert_file;                \/* Server side and optionally client side cert file name *\/$/;"	m	struct:redisTLSContextConfig
cfd	server.h	/^    socketFds cfd;              \/* Cluster bus listening socket *\/$/;"	m	struct:redisServer
cg	defrag.c	/^    streamCG *cg;$/;"	m	struct:__anon17	file:
cgroups	stream.h	/^    rax *cgroups;           \/* Consumer groups dictionary: name -> streamCG *\/$/;"	m	struct:stream
changeBindAddr	server.c	/^int changeBindAddr(sds *addrlist, int addrlist_len) {$/;"	f
changeListenPort	server.c	/^int changeListenPort(int port, socketFds *sfd, aeFileProc *accept_handler) {$/;"	f
changeReplicationId	replication.c	/^void changeReplicationId(void) {$/;"	f
changes	server.h	/^    int changes;$/;"	m	struct:saveparam
channel_len	cluster.h	/^    uint32_t channel_len;$/;"	m	struct:__anon4
channels	server.h	/^    list *channels;  \/* A list of allowed Pub\/Sub channel patterns. If this$/;"	m	struct:__anon45
character	redis-cli.c	/^    int character;   \/* Associated character in visualization. *\/$/;"	m	struct:distsamples	file:
charset	sparkline.c	/^static char charset[] = "_-`";$/;"	v	file:
charset_fill	sparkline.c	/^static char charset_fill[] = "_o#";$/;"	v	file:
charset_len	sparkline.c	/^static int charset_len = sizeof(charset)-1;$/;"	v	file:
checkAlreadyExpired	expire.c	/^int checkAlreadyExpired(long long when) {$/;"	f
checkBlockedClientTimeout	timeout.c	/^int checkBlockedClientTimeout(client *c, mstime_t now) {$/;"	f
checkChildrenDone	server.c	/^void checkChildrenDone(void) {$/;"	f
checkClientOutputBufferLimits	networking.c	/^int checkClientOutputBufferLimits(client *c) {$/;"	f
checkClientPauseTimeoutAndReturnIfPaused	networking.c	/^int checkClientPauseTimeoutAndReturnIfPaused(void) {$/;"	f
checkConsistency	intset.c	/^static void checkConsistency(intset *is) {$/;"	f	file:
checkForSentinelMode	server.c	/^int checkForSentinelMode(int argc, char **argv) {$/;"	f
checkIgnoreWarning	server.c	/^int checkIgnoreWarning(const char *warning) {$/;"	f
checkPrefixCollisionsOrReply	tracking.c	/^int checkPrefixCollisionsOrReply(client *c, robj **prefixes, size_t numprefix) {$/;"	f
checkSignedBitfieldOverflow	bitops.c	/^int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {$/;"	f
checkStringLength	t_string.c	/^static int checkStringLength(client *c, long long size) {$/;"	f	file:
checkTcpBacklogSettings	server.c	/^void checkTcpBacklogSettings(void) {$/;"	f
checkType	object.c	/^int checkType(client *c, robj *o, int type) {$/;"	f
checkUnsignedBitfieldOverflow	bitops.c	/^int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {$/;"	f
childInfoType	server.h	/^typedef enum childInfoType {$/;"	g
childInfoType	server.h	/^} childInfoType;$/;"	t	typeref:enum:childInfoType
child_info_data	childinfo.c	/^} child_info_data;$/;"	t	typeref:struct:__anon1	file:
child_info_nread	server.h	/^    int child_info_nread;           \/* Num of bytes of the last read from pipe *\/$/;"	m	struct:redisServer
child_info_pipe	server.h	/^    int child_info_pipe[2];         \/* Pipe used to write the child_info_data. *\/$/;"	m	struct:redisServer
child_pid	server.h	/^    pid_t child_pid;            \/* PID of current child *\/$/;"	m	struct:redisServer
child_type	server.h	/^    int child_type;             \/* Type of current child *\/$/;"	m	struct:redisServer
children	scripting.c	/^    list *children; \/* All forked debugging sessions pids. *\/$/;"	m	struct:ldbState	file:
cinfo	acl.c	/^    sds cinfo;          \/* Client info (last client if updated). *\/$/;"	m	struct:ACLLogEntry	file:
ciphers	cli_common.h	/^    char* ciphers;$/;"	m	struct:cliSSLconfig
ciphers	server.h	/^    char *ciphers;$/;"	m	struct:redisTLSContextConfig
ciphersuites	cli_common.h	/^    char* ciphersuites;$/;"	m	struct:cliSSLconfig
ciphersuites	server.h	/^    char *ciphersuites;$/;"	m	struct:redisTLSContextConfig
cksum	rio.h	/^    uint64_t cksum, flags;$/;"	m	struct:_rio
clearFailoverState	replication.c	/^void clearFailoverState() {$/;"	f
clearNodeFailureIfNeeded	cluster.c	/^void clearNodeFailureIfNeeded(clusterNode *node) {$/;"	f
clearReplicationId2	replication.c	/^void clearReplicationId2(void) {$/;"	f
cliAuth	redis-cli.c	/^static int cliAuth(redisContext *ctx, char *user, char *auth) {$/;"	f	file:
cliConnect	redis-cli.c	/^static int cliConnect(int flags) {$/;"	f	file:
cliFormatInvalidateTTY	redis-cli.c	/^static sds cliFormatInvalidateTTY(redisReply *r) {$/;"	f	file:
cliFormatReply	redis-cli.c	/^static sds cliFormatReply(redisReply *reply, int mode, int verbatim) {$/;"	f	file:
cliFormatReplyCSV	redis-cli.c	/^static sds cliFormatReplyCSV(redisReply *r) {$/;"	f	file:
cliFormatReplyRaw	redis-cli.c	/^static sds cliFormatReplyRaw(redisReply *r) {$/;"	f	file:
cliFormatReplyTTY	redis-cli.c	/^static sds cliFormatReplyTTY(redisReply *r, char *prefix) {$/;"	f	file:
cliInitHelp	redis-cli.c	/^static void cliInitHelp(void) {$/;"	f	file:
cliIntegrateHelp	redis-cli.c	/^static void cliIntegrateHelp(void) {$/;"	f	file:
cliLoadPreferences	redis-cli.c	/^void cliLoadPreferences(void) {$/;"	f
cliOutputCommandHelp	redis-cli.c	/^static void cliOutputCommandHelp(struct commandHelp *help, int group) {$/;"	f	file:
cliOutputGenericHelp	redis-cli.c	/^static void cliOutputGenericHelp(void) {$/;"	f	file:
cliOutputHelp	redis-cli.c	/^static void cliOutputHelp(int argc, char **argv) {$/;"	f	file:
cliPrintContextError	redis-cli.c	/^static void cliPrintContextError(void) {$/;"	f	file:
cliPushHandler	redis-cli.c	/^static void cliPushHandler(void *privdata, void *reply) {$/;"	f	file:
cliReadReply	redis-cli.c	/^static int cliReadReply(int output_raw_strings) {$/;"	f	file:
cliRefreshPrompt	redis-cli.c	/^static void cliRefreshPrompt(void) {$/;"	f	file:
cliSSLconfig	cli_common.h	/^typedef struct cliSSLconfig {$/;"	s
cliSSLconfig	cli_common.h	/^} cliSSLconfig;$/;"	t	typeref:struct:cliSSLconfig
cliSecureConnection	cli_common.c	/^int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err) {$/;"	f
cliSecureInit	cli_common.c	/^int cliSecureInit()$/;"	f
cliSelect	redis-cli.c	/^static int cliSelect(void) {$/;"	f	file:
cliSendCommand	redis-cli.c	/^static int cliSendCommand(int argc, char **argv, long repeat) {$/;"	f	file:
cliSetPreferences	redis-cli.c	/^void cliSetPreferences(char **argv, int argc, int interactive) {$/;"	f
cliSplitArgs	redis-cli.c	/^static sds *cliSplitArgs(char *line, int *argc) {$/;"	f	file:
cliSwitchProto	redis-cli.c	/^static int cliSwitchProto(void) {$/;"	f	file:
cliVersion	redis-cli.c	/^static sds cliVersion(void) {$/;"	f	file:
cliWriteConn	cli_common.c	/^ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len)$/;"	f
client	module.c	/^    client *client;                 \/* Client calling a command. *\/$/;"	m	struct:RedisModuleCtx	file:
client	module.c	/^    client *client;  \/* Pointer to the blocked client. or NULL if the client$/;"	m	struct:RedisModuleBlockedClient	file:
client	redis-benchmark.c	/^} *client;$/;"	t	typeref:struct:_client	file:
client	server.h	/^typedef struct client {$/;"	s
client	server.h	/^} client;$/;"	t	typeref:struct:client
client	t_zset.c	/^    client                              *client;$/;"	m	struct:zrange_result_handler	file:
clientAcceptHandler	networking.c	/^void clientAcceptHandler(connection *conn) {$/;"	f
clientBufferLimitsConfig	server.h	/^typedef struct clientBufferLimitsConfig {$/;"	s
clientBufferLimitsConfig	server.h	/^} clientBufferLimitsConfig;$/;"	t	typeref:struct:clientBufferLimitsConfig
clientBufferLimitsDefaults	config.c	/^clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {$/;"	v
clientChangeCallback	modules/hellohook.c	/^void clientChangeCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)$/;"	f
clientCommand	networking.c	/^void clientCommand(client *c) {$/;"	f
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
clientDone	redis-benchmark.c	/^static void clientDone(client c) {$/;"	f	file:
clientHasPendingReplies	networking.c	/^int clientHasPendingReplies(client *c) {$/;"	f
clientInstallWriteHandler	networking.c	/^void clientInstallWriteHandler(client *c) {$/;"	f
clientReplyBlock	server.h	/^typedef struct clientReplyBlock {$/;"	s
clientReplyBlock	server.h	/^} clientReplyBlock;$/;"	t	typeref:struct:clientReplyBlock
clientSetDefaultAuth	networking.c	/^static void clientSetDefaultAuth(client *c) {$/;"	f	file:
clientSetNameOrReply	networking.c	/^int clientSetNameOrReply(client *c, robj *name) {$/;"	f
clientSubscriptionsCount	pubsub.c	/^int clientSubscriptionsCount(client *c) {$/;"	f
client_cert_file	server.h	/^    char *client_cert_file;         \/* Certificate to use as a client; if none, use cert_file *\/$/;"	m	struct:redisTLSContextConfig
client_cron_last_memory_type	server.h	/^    int      client_cron_last_memory_type;$/;"	m	struct:client
client_cron_last_memory_usage	server.h	/^    uint64_t client_cron_last_memory_usage;$/;"	m	struct:client
client_key_file	server.h	/^    char *client_key_file;          \/* Private key filename for client_cert_file *\/$/;"	m	struct:redisTLSContextConfig
client_key_file_pass	server.h	/^    char *client_key_file_pass;     \/* Optional password for client_key_file *\/$/;"	m	struct:redisTLSContextConfig
client_list_node	server.h	/^    listNode *client_list_node; \/* list node in client list *\/$/;"	m	struct:client
client_max_querybuf_len	server.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	struct:redisServer
client_obuf_limits	server.h	/^    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];$/;"	m	struct:redisServer
client_pause_end_time	server.h	/^    mstime_t client_pause_end_time;    \/* Time when we undo clients_paused *\/$/;"	m	struct:redisServer
client_pause_in_transaction	server.h	/^    int client_pause_in_transaction; \/* Was a client pause executed during this Exec? *\/$/;"	m	struct:redisServer
client_pause_type	server.h	/^    pause_type client_pause_type;      \/* True if clients are currently paused *\/$/;"	m	struct:redisServer
client_reconfig_script	sentinel.c	/^    char *client_reconfig_script;$/;"	m	struct:sentinelRedisInstance	file:
client_tracking_prefixes	server.h	/^    rax *client_tracking_prefixes; \/* A dictionary of prefixes we are already$/;"	m	struct:client
client_tracking_redirection	server.h	/^    uint64_t client_tracking_redirection;$/;"	m	struct:client
clients	redis-benchmark.c	/^    list *clients;$/;"	m	struct:config	file:
clients	server.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	struct:redisServer
clients	tracking.c	/^    rax *clients;   \/* Clients subscribed to the notification events for this$/;"	m	struct:bcastState	file:
clientsCron	server.c	/^void clientsCron(void) {$/;"	f
clientsCronHandleTimeout	timeout.c	/^int clientsCronHandleTimeout(client *c, mstime_t now_ms) {$/;"	f
clientsCronResizeQueryBuffer	server.c	/^int clientsCronResizeQueryBuffer(client *c) {$/;"	f
clientsCronTrackClientsMemUsage	server.c	/^int clientsCronTrackClientsMemUsage(client *c) {$/;"	f
clientsCronTrackExpansiveClients	server.c	/^int clientsCronTrackExpansiveClients(client *c, int time_idx) {$/;"	f
clients_index	server.h	/^    rax *clients_index;         \/* Active clients dictionary by client ID. *\/$/;"	m	struct:redisServer
clients_normal	server.h	/^    size_t clients_normal;$/;"	m	struct:redisMemOverhead
clients_pending_read	server.h	/^    list *clients_pending_read;  \/* Client has pending read socket buffers. *\/$/;"	m	struct:redisServer
clients_pending_write	server.h	/^    list *clients_pending_write; \/* There is to write or install handler. *\/$/;"	m	struct:redisServer
clients_slaves	server.h	/^    size_t clients_slaves;$/;"	m	struct:redisMemOverhead
clients_timeout_table	server.h	/^    rax *clients_timeout_table; \/* Radix tree for blocked clients timeouts. *\/$/;"	m	struct:redisServer
clients_to_close	server.h	/^    list *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	struct:redisServer
clients_waiting_acks	server.h	/^    list *clients_waiting_acks;         \/* Clients waiting in WAIT command. *\/$/;"	m	struct:redisServer
close	connection.h	/^    void (*close)(struct connection *conn);$/;"	m	struct:ConnectionType
closeChildInfoPipe	childinfo.c	/^void closeChildInfoPipe(void) {$/;"	f
closeChildUnusedResourceAfterFork	server.c	/^void closeChildUnusedResourceAfterFork() {$/;"	f
closeDirectLogFiledes	debug.c	/^void closeDirectLogFiledes(int fd) {$/;"	f
closeListeningSockets	server.c	/^void closeListeningSockets(int unlink_unix_socket) {$/;"	f
closeSocketListeners	server.c	/^void closeSocketListeners(socketFds *sfd) {$/;"	f
cluster	server.h	/^    struct clusterState *cluster;  \/* State of the cluster *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::clusterState
clusterAcceptHandler	cluster.c	/^void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
clusterAddNode	cluster.c	/^void clusterAddNode(clusterNode *node) {$/;"	f
clusterAddSlot	cluster.c	/^int clusterAddSlot(clusterNode *n, int slot) {$/;"	f
clusterBeforeSleep	cluster.c	/^void clusterBeforeSleep(void) {$/;"	f
clusterBlacklistAddNode	cluster.c	/^void clusterBlacklistAddNode(clusterNode *node) {$/;"	f
clusterBlacklistCleanup	cluster.c	/^void clusterBlacklistCleanup(void) {$/;"	f
clusterBlacklistExists	cluster.c	/^int clusterBlacklistExists(char *nodeid) {$/;"	f
clusterBroadcastMessage	cluster.c	/^void clusterBroadcastMessage(void *buf, size_t len) {$/;"	f
clusterBroadcastPong	cluster.c	/^void clusterBroadcastPong(int target) {$/;"	f
clusterBuildMessageHdr	cluster.c	/^void clusterBuildMessageHdr(clusterMsg *hdr, int type) {$/;"	f
clusterBumpConfigEpochWithoutConsensus	cluster.c	/^int clusterBumpConfigEpochWithoutConsensus(void) {$/;"	f
clusterCloseAllSlots	cluster.c	/^void clusterCloseAllSlots(void) {$/;"	f
clusterCommand	cluster.c	/^void clusterCommand(client *c) {$/;"	f
clusterConnAcceptHandler	cluster.c	/^static void clusterConnAcceptHandler(connection *conn) {$/;"	f	file:
clusterCountNonFailingSlaves	cluster.c	/^int clusterCountNonFailingSlaves(clusterNode *n) {$/;"	f
clusterCron	cluster.c	/^void clusterCron(void) {$/;"	f
clusterDelNode	cluster.c	/^void clusterDelNode(clusterNode *delnode) {$/;"	f
clusterDelNodeSlots	cluster.c	/^int clusterDelNodeSlots(clusterNode *node) {$/;"	f
clusterDelSlot	cluster.c	/^int clusterDelSlot(int slot) {$/;"	f
clusterDoBeforeSleep	cluster.c	/^void clusterDoBeforeSleep(int flags) {$/;"	f
clusterFailoverReplaceYourMaster	cluster.c	/^void clusterFailoverReplaceYourMaster(void) {$/;"	f
clusterGenNodeDescription	cluster.c	/^sds clusterGenNodeDescription(clusterNode *node, int use_pport) {$/;"	f
clusterGenNodesDescription	cluster.c	/^sds clusterGenNodesDescription(int filter, int use_pport) {$/;"	f
clusterGenNodesSlotsInfo	cluster.c	/^void clusterGenNodesSlotsInfo(int filter) {$/;"	f
clusterGetMaxEpoch	cluster.c	/^uint64_t clusterGetMaxEpoch(void) {$/;"	f
clusterGetMessageTypeString	cluster.c	/^const char *clusterGetMessageTypeString(int type) {$/;"	f
clusterGetSlaveRank	cluster.c	/^int clusterGetSlaveRank(void) {$/;"	f
clusterHandleConfigEpochCollision	cluster.c	/^void clusterHandleConfigEpochCollision(clusterNode *sender) {$/;"	f
clusterHandleManualFailover	cluster.c	/^void clusterHandleManualFailover(void) {$/;"	f
clusterHandleSlaveFailover	cluster.c	/^void clusterHandleSlaveFailover(void) {$/;"	f
clusterHandleSlaveMigration	cluster.c	/^void clusterHandleSlaveMigration(int max_slaves) {$/;"	f
clusterHandshakeInProgress	cluster.c	/^int clusterHandshakeInProgress(char *ip, int port, int cport) {$/;"	f
clusterInit	cluster.c	/^void clusterInit(void) {$/;"	f
clusterLink	cluster.h	/^typedef struct clusterLink {$/;"	s
clusterLink	cluster.h	/^} clusterLink;$/;"	t	typeref:struct:clusterLink
clusterLinkConnectHandler	cluster.c	/^void clusterLinkConnectHandler(connection *conn) {$/;"	f
clusterLoadConfig	cluster.c	/^int clusterLoadConfig(char *filename) {$/;"	f
clusterLockConfig	cluster.c	/^int clusterLockConfig(char *filename) {$/;"	f
clusterLogCantFailover	cluster.c	/^void clusterLogCantFailover(int reason) {$/;"	f
clusterLookupNode	cluster.c	/^clusterNode *clusterLookupNode(const char *name) {$/;"	f
clusterManager	redis-cli.c	/^static struct clusterManager {$/;"	s	file:
clusterManagerAddSlot	redis-cli.c	/^static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {$/;"	f	file:
clusterManagerAddSlots	redis-cli.c	/^static int clusterManagerAddSlots(clusterManagerNode *node, char**err)$/;"	f	file:
clusterManagerBumpEpoch	redis-cli.c	/^static int clusterManagerBumpEpoch(clusterManagerNode *node) {$/;"	f	file:
clusterManagerCheckCluster	redis-cli.c	/^static int clusterManagerCheckCluster(int quiet) {$/;"	f	file:
clusterManagerCheckRedisReply	redis-cli.c	/^static int clusterManagerCheckRedisReply(clusterManagerNode *n,$/;"	f	file:
clusterManagerClearSlotStatus	redis-cli.c	/^static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {$/;"	f	file:
clusterManagerCommand	redis-cli.c	/^typedef struct clusterManagerCommand {$/;"	s	file:
clusterManagerCommand	redis-cli.c	/^} clusterManagerCommand;$/;"	t	typeref:struct:clusterManagerCommand	file:
clusterManagerCommandAddNode	redis-cli.c	/^static int clusterManagerCommandAddNode(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandBackup	redis-cli.c	/^static int clusterManagerCommandBackup(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandCall	redis-cli.c	/^static int clusterManagerCommandCall(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandCheck	redis-cli.c	/^static int clusterManagerCommandCheck(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandCreate	redis-cli.c	/^static int clusterManagerCommandCreate(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandDef	redis-cli.c	/^typedef struct clusterManagerCommandDef {$/;"	s	file:
clusterManagerCommandDef	redis-cli.c	/^} clusterManagerCommandDef;$/;"	t	typeref:struct:clusterManagerCommandDef	file:
clusterManagerCommandDeleteNode	redis-cli.c	/^static int clusterManagerCommandDeleteNode(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandFix	redis-cli.c	/^static int clusterManagerCommandFix(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandHelp	redis-cli.c	/^static int clusterManagerCommandHelp(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandImport	redis-cli.c	/^static int clusterManagerCommandImport(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandInfo	redis-cli.c	/^static int clusterManagerCommandInfo(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandProc	redis-cli.c	/^typedef int clusterManagerCommandProc(int argc, char **argv);$/;"	t	file:
clusterManagerCommandRebalance	redis-cli.c	/^static int clusterManagerCommandRebalance(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandReshard	redis-cli.c	/^static int clusterManagerCommandReshard(int argc, char **argv) {$/;"	f	file:
clusterManagerCommandSetTimeout	redis-cli.c	/^static int clusterManagerCommandSetTimeout(int argc, char **argv) {$/;"	f	file:
clusterManagerCommands	redis-cli.c	/^clusterManagerCommandDef clusterManagerCommands[] = {$/;"	v
clusterManagerCompareKeysValues	redis-cli.c	/^static int clusterManagerCompareKeysValues(clusterManagerNode *n1,$/;"	f	file:
clusterManagerCompareNodeBalance	redis-cli.c	/^int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {$/;"	f
clusterManagerComputeReshardTable	redis-cli.c	/^static list *clusterManagerComputeReshardTable(list *sources, int numslots) {$/;"	f	file:
clusterManagerCountKeysInSlot	redis-cli.c	/^static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,$/;"	f	file:
clusterManagerDelSlot	redis-cli.c	/^static int clusterManagerDelSlot(clusterManagerNode *node, int slot,$/;"	f	file:
clusterManagerDictType	redis-cli.c	/^static dictType clusterManagerDictType = {$/;"	v	file:
clusterManagerExecTransaction	redis-cli.c	/^static int clusterManagerExecTransaction(clusterManagerNode *node,$/;"	f	file:
clusterManagerFixMultipleSlotOwners	redis-cli.c	/^static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {$/;"	f	file:
clusterManagerFixOpenSlot	redis-cli.c	/^static int clusterManagerFixOpenSlot(int slot) {$/;"	f	file:
clusterManagerFixSlotsCoverage	redis-cli.c	/^static int clusterManagerFixSlotsCoverage(char *all_slots) {$/;"	f	file:
clusterManagerFlushNodeConfig	redis-cli.c	/^static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {$/;"	f	file:
clusterManagerGetAntiAffinityScore	redis-cli.c	/^static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,$/;"	f	file:
clusterManagerGetConfigSignature	redis-cli.c	/^static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {$/;"	f	file:
clusterManagerGetCoveredSlots	redis-cli.c	/^static int clusterManagerGetCoveredSlots(char *all_slots) {$/;"	f	file:
clusterManagerGetDisconnectedLinks	redis-cli.c	/^static list *clusterManagerGetDisconnectedLinks(clusterManagerNode *node) {$/;"	f	file:
clusterManagerGetLinkStatus	redis-cli.c	/^static dict *clusterManagerGetLinkStatus(void) {$/;"	f	file:
clusterManagerGetNodeRDBFilename	redis-cli.c	/^static sds clusterManagerGetNodeRDBFilename(clusterManagerNode *node) {$/;"	f	file:
clusterManagerGetNodeRedisInfo	redis-cli.c	/^static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,$/;"	f	file:
clusterManagerGetNodeWithMostKeysInSlot	redis-cli.c	/^static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,$/;"	f	file:
clusterManagerGetSlotOwner	redis-cli.c	/^static clusterManagerNode *clusterManagerGetSlotOwner(clusterManagerNode *n,$/;"	f	file:
clusterManagerIsConfigConsistent	redis-cli.c	/^static int clusterManagerIsConfigConsistent(void) {$/;"	f	file:
clusterManagerKeyHashSlot	redis-cli.c	/^static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {$/;"	f	file:
clusterManagerLink	redis-cli.c	/^typedef struct clusterManagerLink {$/;"	s	file:
clusterManagerLink	redis-cli.c	/^} clusterManagerLink;$/;"	t	typeref:struct:clusterManagerLink	file:
clusterManagerLinkDictType	redis-cli.c	/^static dictType clusterManagerLinkDictType = {$/;"	v	file:
clusterManagerLoadInfoFromNode	redis-cli.c	/^static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {$/;"	f	file:
clusterManagerLog	redis-cli.c	/^static void clusterManagerLog(int level, const char* fmt, ...) {$/;"	f	file:
clusterManagerLogErr	redis-cli.c	104;"	d	file:
clusterManagerLogInfo	redis-cli.c	101;"	d	file:
clusterManagerLogOk	redis-cli.c	110;"	d	file:
clusterManagerLogWarn	redis-cli.c	107;"	d	file:
clusterManagerMigrateKeysInReply	redis-cli.c	/^static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,$/;"	f	file:
clusterManagerMigrateKeysInSlot	redis-cli.c	/^static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,$/;"	f	file:
clusterManagerMode	redis-cli.c	/^static void clusterManagerMode(clusterManagerCommandProc *proc) {$/;"	f	file:
clusterManagerMoveSlot	redis-cli.c	/^static int clusterManagerMoveSlot(clusterManagerNode *source,$/;"	f	file:
clusterManagerNewNode	redis-cli.c	/^static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {$/;"	f	file:
clusterManagerNode	redis-cli.c	/^typedef struct clusterManagerNode {$/;"	s	file:
clusterManagerNode	redis-cli.c	/^} clusterManagerNode;$/;"	t	typeref:struct:clusterManagerNode	file:
clusterManagerNodeArray	redis-cli.c	/^typedef struct clusterManagerNodeArray {$/;"	s	file:
clusterManagerNodeArray	redis-cli.c	/^} clusterManagerNodeArray;$/;"	t	typeref:struct:clusterManagerNodeArray	file:
clusterManagerNodeArrayAdd	redis-cli.c	/^static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,$/;"	f	file:
clusterManagerNodeArrayInit	redis-cli.c	/^static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,$/;"	f	file:
clusterManagerNodeArrayReset	redis-cli.c	/^static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {$/;"	f	file:
clusterManagerNodeArrayShift	redis-cli.c	/^static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,$/;"	f	file:
clusterManagerNodeByAbbreviatedName	redis-cli.c	/^static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)$/;"	f	file:
clusterManagerNodeByName	redis-cli.c	/^static clusterManagerNode *clusterManagerNodeByName(const char *name) {$/;"	f	file:
clusterManagerNodeConnect	redis-cli.c	/^static int clusterManagerNodeConnect(clusterManagerNode *node) {$/;"	f	file:
clusterManagerNodeFlagString	redis-cli.c	/^static sds clusterManagerNodeFlagString(clusterManagerNode *node) {$/;"	f	file:
clusterManagerNodeGetJSON	redis-cli.c	/^static sds clusterManagerNodeGetJSON(clusterManagerNode *node,$/;"	f	file:
clusterManagerNodeInfo	redis-cli.c	/^static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {$/;"	f	file:
clusterManagerNodeIsCluster	redis-cli.c	/^static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {$/;"	f	file:
clusterManagerNodeIsEmpty	redis-cli.c	/^static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {$/;"	f	file:
clusterManagerNodeLoadInfo	redis-cli.c	/^static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,$/;"	f	file:
clusterManagerNodeMasterRandom	redis-cli.c	/^static clusterManagerNode *clusterManagerNodeMasterRandom() {$/;"	f	file:
clusterManagerNodeResetSlots	redis-cli.c	/^static void clusterManagerNodeResetSlots(clusterManagerNode *node) {$/;"	f	file:
clusterManagerNodeSlotsString	redis-cli.c	/^static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {$/;"	f	file:
clusterManagerNodeWithLeastReplicas	redis-cli.c	/^static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {$/;"	f	file:
clusterManagerOnError	redis-cli.c	/^static void clusterManagerOnError(sds err) {$/;"	f	file:
clusterManagerOnReplyError	redis-cli.c	/^typedef int (*clusterManagerOnReplyError)(redisReply *reply,$/;"	t	file:
clusterManagerOnSetOwnerErr	redis-cli.c	/^static int clusterManagerOnSetOwnerErr(redisReply *reply,$/;"	f	file:
clusterManagerOptimizeAntiAffinity	redis-cli.c	/^static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,$/;"	f	file:
clusterManagerOptionDef	redis-cli.c	/^typedef struct clusterManagerOptionDef {$/;"	s	file:
clusterManagerOptionDef	redis-cli.c	/^} clusterManagerOptionDef;$/;"	t	typeref:struct:clusterManagerOptionDef	file:
clusterManagerOptions	redis-cli.c	/^clusterManagerOptionDef clusterManagerOptions[] = {$/;"	v
clusterManagerPrintNotClusterNodeError	redis-cli.c	/^static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,$/;"	f	file:
clusterManagerPrintNotEmptyNodeError	redis-cli.c	/^static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,$/;"	f	file:
clusterManagerPrintSlotsList	redis-cli.c	/^static void clusterManagerPrintSlotsList(list *slots) {$/;"	f	file:
clusterManagerReleaseReshardTable	redis-cli.c	/^static void clusterManagerReleaseReshardTable(list *table) {$/;"	f	file:
clusterManagerRemoveNodeFromList	redis-cli.c	/^static void clusterManagerRemoveNodeFromList(list *nodelist,$/;"	f	file:
clusterManagerReshardTableItem	redis-cli.c	/^typedef struct clusterManagerReshardTableItem {$/;"	s	file:
clusterManagerReshardTableItem	redis-cli.c	/^} clusterManagerReshardTableItem;$/;"	t	typeref:struct:clusterManagerReshardTableItem	file:
clusterManagerSetSlot	redis-cli.c	/^static int clusterManagerSetSlot(clusterManagerNode *node1,$/;"	f	file:
clusterManagerSetSlotOwner	redis-cli.c	/^static int clusterManagerSetSlotOwner(clusterManagerNode *owner,$/;"	f	file:
clusterManagerShowClusterInfo	redis-cli.c	/^static void clusterManagerShowClusterInfo(void) {$/;"	f	file:
clusterManagerShowNodes	redis-cli.c	/^static void clusterManagerShowNodes(void) {$/;"	f	file:
clusterManagerShowReshardTable	redis-cli.c	/^static void clusterManagerShowReshardTable(list *table) {$/;"	f	file:
clusterManagerSlotCompare	redis-cli.c	/^int clusterManagerSlotCompare(const void *slot1, const void *slot2) {$/;"	f
clusterManagerSlotCountCompareDesc	redis-cli.c	/^int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {$/;"	f
clusterManagerStartTransaction	redis-cli.c	/^static int clusterManagerStartTransaction(clusterManagerNode *node) {$/;"	f	file:
clusterManagerUncoveredSlots	redis-cli.c	/^dict *clusterManagerUncoveredSlots = NULL;$/;"	v
clusterManagerWaitForClusterJoin	redis-cli.c	/^static void clusterManagerWaitForClusterJoin(void) {$/;"	f	file:
clusterMastersHaveSlaves	cluster.c	/^int clusterMastersHaveSlaves(void) {$/;"	f
clusterMsg	cluster.h	/^} clusterMsg;$/;"	t	typeref:struct:__anon12
clusterMsgData	cluster.h	/^union clusterMsgData {$/;"	u
clusterMsgDataFail	cluster.h	/^} clusterMsgDataFail;$/;"	t	typeref:struct:__anon3
clusterMsgDataGossip	cluster.h	/^} clusterMsgDataGossip;$/;"	t	typeref:struct:__anon2
clusterMsgDataPublish	cluster.h	/^} clusterMsgDataPublish;$/;"	t	typeref:struct:__anon4
clusterMsgDataUpdate	cluster.h	/^} clusterMsgDataUpdate;$/;"	t	typeref:struct:__anon5
clusterMsgModule	cluster.h	/^} clusterMsgModule;$/;"	t	typeref:struct:__anon6
clusterNode	cluster.h	/^typedef struct clusterNode {$/;"	s
clusterNode	cluster.h	/^} clusterNode;$/;"	t	typeref:struct:clusterNode
clusterNode	redis-benchmark.c	/^typedef struct clusterNode {$/;"	s	file:
clusterNode	redis-benchmark.c	/^} clusterNode;$/;"	t	typeref:struct:clusterNode	file:
clusterNodeAddFailureReport	cluster.c	/^int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {$/;"	f
clusterNodeAddSlave	cluster.c	/^int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {$/;"	f
clusterNodeCleanupFailureReports	cluster.c	/^void clusterNodeCleanupFailureReports(clusterNode *node) {$/;"	f
clusterNodeClearSlotBit	cluster.c	/^int clusterNodeClearSlotBit(clusterNode *n, int slot) {$/;"	f
clusterNodeDelFailureReport	cluster.c	/^int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {$/;"	f
clusterNodeFailReport	cluster.h	/^typedef struct clusterNodeFailReport {$/;"	s
clusterNodeFailReport	cluster.h	/^} clusterNodeFailReport;$/;"	t	typeref:struct:clusterNodeFailReport
clusterNodeFailureReportsCount	cluster.c	/^int clusterNodeFailureReportsCount(clusterNode *node) {$/;"	f
clusterNodeForResharding	redis-cli.c	/^static clusterManagerNode *clusterNodeForResharding(char *id,$/;"	f	file:
clusterNodeGetSlotBit	cluster.c	/^int clusterNodeGetSlotBit(clusterNode *n, int slot) {$/;"	f
clusterNodeIsInGossipSection	cluster.c	/^int clusterNodeIsInGossipSection(clusterMsg *hdr, int count, clusterNode *n) {$/;"	f
clusterNodeRemoveSlave	cluster.c	/^int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {$/;"	f
clusterNodeSetSlotBit	cluster.c	/^int clusterNodeSetSlotBit(clusterNode *n, int slot) {$/;"	f
clusterNodesBlackListDictType	server.c	/^dictType clusterNodesBlackListDictType = {$/;"	v
clusterNodesDictType	server.c	/^dictType clusterNodesDictType = {$/;"	v
clusterProcessGossipSection	cluster.c	/^void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {$/;"	f
clusterProcessPacket	cluster.c	/^int clusterProcessPacket(clusterLink *link) {$/;"	f
clusterPropagatePublish	cluster.c	/^void clusterPropagatePublish(robj *channel, robj *message) {$/;"	f
clusterReadHandler	cluster.c	/^void clusterReadHandler(connection *conn) {$/;"	f
clusterReceivers	module.c	/^static moduleClusterReceiver *clusterReceivers[UINT8_MAX];$/;"	v	file:
clusterRedirectBlockedClientIfNeeded	cluster.c	/^int clusterRedirectBlockedClientIfNeeded(client *c) {$/;"	f
clusterRedirectClient	cluster.c	/^void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {$/;"	f
clusterRenameNode	cluster.c	/^void clusterRenameNode(clusterNode *node, char *newname) {$/;"	f
clusterReplyMultiBulkSlots	cluster.c	/^void clusterReplyMultiBulkSlots(client * c) {$/;"	f
clusterRequestFailoverAuth	cluster.c	/^void clusterRequestFailoverAuth(void) {$/;"	f
clusterReset	cluster.c	/^void clusterReset(int hard) {$/;"	f
clusterSaveConfig	cluster.c	/^int clusterSaveConfig(int do_fsync) {$/;"	f
clusterSaveConfigOrDie	cluster.c	/^void clusterSaveConfigOrDie(int do_fsync) {$/;"	f
clusterSendFail	cluster.c	/^void clusterSendFail(char *nodename) {$/;"	f
clusterSendFailoverAuth	cluster.c	/^void clusterSendFailoverAuth(clusterNode *node) {$/;"	f
clusterSendFailoverAuthIfNeeded	cluster.c	/^void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {$/;"	f
clusterSendMFStart	cluster.c	/^void clusterSendMFStart(clusterNode *node) {$/;"	f
clusterSendMessage	cluster.c	/^void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {$/;"	f
clusterSendModule	cluster.c	/^void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,$/;"	f
clusterSendModuleMessageToTarget	cluster.c	/^int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len) {$/;"	f
clusterSendPing	cluster.c	/^void clusterSendPing(clusterLink *link, int type) {$/;"	f
clusterSendPublish	cluster.c	/^void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {$/;"	f
clusterSendUpdate	cluster.c	/^void clusterSendUpdate(clusterLink *link, clusterNode *node) {$/;"	f
clusterSetGossipEntry	cluster.c	/^void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {$/;"	f
clusterSetMaster	cluster.c	/^void clusterSetMaster(clusterNode *n) {$/;"	f
clusterSetNodeAsMaster	cluster.c	/^void clusterSetNodeAsMaster(clusterNode *n) {$/;"	f
clusterStartHandshake	cluster.c	/^int clusterStartHandshake(char *ip, int port, int cport) {$/;"	f
clusterState	cluster.h	/^typedef struct clusterState {$/;"	s
clusterState	cluster.h	/^} clusterState;$/;"	t	typeref:struct:clusterState
clusterUpdateMyselfFlags	cluster.c	/^void clusterUpdateMyselfFlags(void) {$/;"	f
clusterUpdateSlotsConfigWith	cluster.c	/^void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {$/;"	f
clusterUpdateState	cluster.c	/^void clusterUpdateState(void) {$/;"	f
clusterWriteHandler	cluster.c	/^void clusterWriteHandler(connection *conn) {$/;"	f
cluster_allow_reads_when_down	server.h	/^    int cluster_allow_reads_when_down; \/* Are reads allowed when the cluster$/;"	m	struct:redisServer
cluster_allow_replica_migration	server.h	/^    int cluster_allow_replica_migration; \/* Automatic replica migrations to orphaned masters and from empty masters *\/$/;"	m	struct:redisServer
cluster_announce_bus_port	server.h	/^    int cluster_announce_bus_port; \/* bus port to announce on cluster bus. *\/$/;"	m	struct:redisServer
cluster_announce_ip	server.h	/^    char *cluster_announce_ip;  \/* IP address to announce on cluster bus. *\/$/;"	m	struct:redisServer
cluster_announce_port	server.h	/^    int cluster_announce_port;     \/* base port to announce on cluster bus. *\/$/;"	m	struct:redisServer
cluster_announce_tls_port	server.h	/^    int cluster_announce_tls_port; \/* TLS port to announce on cluster bus. *\/$/;"	m	struct:redisServer
cluster_config_file_lock_fd	server.h	/^    int cluster_config_file_lock_fd;   \/* cluster config fd, will be flock *\/$/;"	m	struct:redisServer
cluster_configfile	server.h	/^    char *cluster_configfile; \/* Cluster auto-generated config file name. *\/$/;"	m	struct:redisServer
cluster_enabled	server.h	/^    int cluster_enabled;      \/* Is cluster enabled? *\/$/;"	m	struct:redisServer
cluster_manager	redis-cli.c	/^} cluster_manager;$/;"	v	typeref:struct:clusterManager	file:
cluster_manager_command	redis-cli.c	/^    clusterManagerCommand cluster_manager_command;$/;"	m	struct:config	file:
cluster_migration_barrier	server.h	/^    int cluster_migration_barrier; \/* Cluster replicas migration barrier. *\/$/;"	m	struct:redisServer
cluster_mode	redis-benchmark.c	/^    int cluster_mode;$/;"	m	struct:config	file:
cluster_mode	redis-cli.c	/^    int cluster_mode;$/;"	m	struct:config	file:
cluster_module_flags	server.h	/^    int cluster_module_flags;      \/* Set of flags that Redis modules are able$/;"	m	struct:redisServer
cluster_node	redis-benchmark.c	/^    struct clusterNode *cluster_node;$/;"	m	struct:_client	typeref:struct:_client::clusterNode	file:
cluster_node_count	redis-benchmark.c	/^    int cluster_node_count;$/;"	m	struct:config	file:
cluster_node_timeout	server.h	/^    mstime_t cluster_node_timeout; \/* Cluster node timeout. *\/$/;"	m	struct:redisServer
cluster_nodes	redis-benchmark.c	/^    struct clusterNode **cluster_nodes;$/;"	m	struct:config	typeref:struct:config::clusterNode	file:
cluster_reissue_command	redis-cli.c	/^    int cluster_reissue_command;$/;"	m	struct:config	file:
cluster_require_full_coverage	server.h	/^    int cluster_require_full_coverage; \/* If true, put the cluster down if$/;"	m	struct:redisServer
cluster_slave_no_failover	server.h	/^    int cluster_slave_no_failover;  \/* Prevent slave from starting a failover$/;"	m	struct:redisServer
cluster_slave_validity_factor	server.h	/^    int cluster_slave_validity_factor; \/* Slave max data age for failover. *\/$/;"	m	struct:redisServer
cmd	server.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	struct:client	typeref:struct:client::redisCommand
cmd	server.h	/^    struct redisCommand *cmd;$/;"	m	struct:multiCmd	typeref:struct:multiCmd::redisCommand
cmd	server.h	/^    struct redisCommand *cmd;$/;"	m	struct:redisOp	typeref:struct:redisOp::redisCommand
cmdHasMovableKeys	server.c	/^static int cmdHasMovableKeys(struct redisCommand *cmd) {$/;"	f	file:
cmd_GET	modules/hellodict.c	/^int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
cmd_KEYRANGE	modules/hellodict.c	/^int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
cmd_SET	modules/hellodict.c	/^int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f
cmd_delim	redis-cli.c	/^    sds cmd_delim;$/;"	m	struct:config	file:
cmd_flags	server.h	/^    int cmd_flags;          \/* The accumulated command flags OR-ed together.$/;"	m	struct:multiState
cmd_inv_flags	server.h	/^    int cmd_inv_flags;      \/* Same as cmd_flags, OR-ing the ~flags. so that it$/;"	m	struct:multiState
cmpobj	server.h	/^        robj *cmpobj;$/;"	m	union:_redisSortObject::__anon49
cname	slowlog.h	/^    sds cname;          \/* Client name. *\/$/;"	m	struct:slowlogEntry
cntfrq_hz	monotonic.c	/^static inline uint32_t cntfrq_hz() {$/;"	f	file:
collateStringObjects	object.c	/^int collateStringObjects(robj *a, robj *b) {$/;"	f
colon	server.h	/^    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],$/;"	m	struct:sharedObjectsStruct
color	lolwut6.c	/^    int color;      \/* Color of the skyscraper. *\/$/;"	m	struct:skyscraper	file:
colorized	redis-trib.rb	/^def colorized(str, color)$/;"	f
commandCommand	server.c	/^void commandCommand(client *c) {$/;"	f
commandFlagsFromString	module.c	/^int64_t commandFlagsFromString(char *s) {$/;"	f
commandGroups	help.h	/^static char *commandGroups[] = {$/;"	v
commandHelp	help.h	/^struct commandHelp {$/;"	s
commandHelp	help.h	/^} commandHelp[] = {$/;"	v	typeref:struct:commandHelp
commandId	acl.c	/^static rax *commandId = NULL; \/* Command name to id mapping *\/$/;"	v	file:
commandProcessed	networking.c	/^void commandProcessed(client *c) {$/;"	f
commandTableDictType	server.c	/^dictType commandTableDictType = {$/;"	v
command_example	redis-trib.rb	/^def command_example(cmd, args, opts)$/;"	f
commands	server.h	/^    dict *commands;             \/* Command table *\/$/;"	m	struct:redisServer
commands	server.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	struct:multiState
compareCallback	dict.c	/^int compareCallback(void *privdata, const void *key1, const void *key2) {$/;"	f
compareHelper	ziplist.c	/^static int compareHelper(unsigned char *zl, char ch, size_t len, int index) {$/;"	f	file:
compareSlavesForPromotion	sentinel.c	/^int compareSlavesForPromotion(const void *a, const void *b) {$/;"	f
compareStringObjects	object.c	/^int compareStringObjects(robj *a, robj *b) {$/;"	f
compareStringObjectsWithFlags	object.c	/^int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {$/;"	f
completionCallback	redis-cli.c	/^static void completionCallback(const char *buf, linenoiseCompletions *lc) {$/;"	f	file:
compress	quicklist.h	/^    unsigned int compress : QL_COMP_BITS; \/* depth of end nodes not to compress;0=off *\/$/;"	m	struct:quicklist
compressed	quicklist.h	/^    char compressed[];$/;"	m	struct:quicklistLZF
computeDatasetDigest	debug.c	/^void computeDatasetDigest(unsigned char *final) {$/;"	f
computeDefragCycles	defrag.c	/^void computeDefragCycles() {$/;"	f
compute_something_fast	redis-cli.c	/^unsigned long compute_something_fast(void) {$/;"	f
cone	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
config	config.c	/^    char **config; \/* Pointer to the server config this value is stored in. *\/$/;"	m	struct:stringConfigData	file:
config	config.c	/^    int *config; \/* The pointer to the server config this value is stored in *\/$/;"	m	struct:boolConfigData	file:
config	config.c	/^    int *config; \/* The pointer to the server config this value is stored in *\/$/;"	m	struct:enumConfigData	file:
config	config.c	/^    sds *config; \/* Pointer to the server config this value is stored in. *\/$/;"	m	struct:sdsConfigData	file:
config	config.c	/^    } config; \/* The pointer to the numeric config this value is stored in *\/$/;"	m	struct:numericConfigData	typeref:union:numericConfigData::__anon14	file:
config	redis-benchmark.c	/^static struct config {$/;"	s	file:
config	redis-benchmark.c	/^} config;$/;"	v	typeref:struct:config	file:
config	redis-cli.c	/^static struct config {$/;"	s	file:
config	redis-cli.c	/^} config;$/;"	v	typeref:struct:config	file:
configCommand	config.c	/^void configCommand(client *c) {$/;"	f
configEnum	config.c	/^typedef struct configEnum {$/;"	s	file:
configEnum	config.c	/^} configEnum;$/;"	t	typeref:struct:configEnum	file:
configEnumGetName	config.c	/^const char *configEnumGetName(configEnum *ce, int val) {$/;"	f
configEnumGetNameOrUnknown	config.c	/^const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {$/;"	f
configEnumGetValue	config.c	/^int configEnumGetValue(configEnum *ce, char *name) {$/;"	f
configEpoch	cluster.h	/^    uint64_t configEpoch;   \/* The config epoch if it's a master, or the last$/;"	m	struct:__anon12
configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Config epoch of the specified instance. *\/$/;"	m	struct:__anon5
configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Last configEpoch observed for this node *\/$/;"	m	struct:clusterNode
configOOMScoreAdjValuesDefaults	config.c	/^int configOOMScoreAdjValuesDefaults[CONFIG_OOM_COUNT] = { 0, 200, 800 };$/;"	v
configSetCommand	config.c	/^void configSetCommand(client *c) {$/;"	f
config_epoch	sentinel.c	/^    uint64_t config_epoch;  \/* Configuration epoch. *\/$/;"	m	struct:sentinelRedisInstance	file:
config_get_bool_field	config.c	903;"	d	file:
config_get_numerical_field	config.c	911;"	d	file:
config_get_string_field	config.c	895;"	d	file:
config_hz	server.h	/^    int config_hz;              \/* Configured HZ value. May be different than$/;"	m	struct:redisServer
config_set_bool_field	config.c	685;"	d	file:
config_set_else	config.c	711;"	d	file:
config_set_memory_field	config.c	698;"	d	file:
config_set_numerical_field	config.c	691;"	d	file:
config_set_special_field	config.c	704;"	d	file:
config_set_special_field_with_alias	config.c	707;"	d	file:
configfile	server.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	struct:redisServer
configs	config.c	/^standardConfig configs[] = {$/;"	v
configs	config.c	/^standardConfig configs[];$/;"	v
confirmWithYes	redis-cli.c	/^static int confirmWithYes(char *msg, int ignore_force) {$/;"	f	file:
conn	cluster.c	/^    connection *conn;$/;"	m	struct:migrateCachedSocket	file:
conn	cluster.h	/^    connection *conn;           \/* Connection to remote node *\/$/;"	m	struct:clusterLink
conn	rio.h	/^            connection *conn;   \/* Connection *\/$/;"	m	struct:_rio::__anon37::__anon40
conn	rio.h	/^        } conn;$/;"	m	union:_rio::__anon37	typeref:struct:_rio::__anon37::__anon40
conn	scripting.c	/^    connection *conn; \/* Connection of the debugging client. *\/$/;"	m	struct:ldbState	file:
conn	server.h	/^    connection *conn;$/;"	m	struct:client
connAccept	connection.h	/^static inline int connAccept(connection *conn, ConnectionCallbackFunc accept_handler) {$/;"	f
connBlock	connection.c	/^int connBlock(connection *conn) {$/;"	f
connBlockingConnect	connection.h	/^static inline int connBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {$/;"	f
connClose	connection.h	/^static inline void connClose(connection *conn) {$/;"	f
connConnect	connection.h	/^static inline int connConnect(connection *conn, const char *addr, int port, const char *src_addr,$/;"	f
connCreateAcceptedSocket	connection.c	/^connection *connCreateAcceptedSocket(int fd) {$/;"	f
connCreateAcceptedTLS	tls.c	/^connection *connCreateAcceptedTLS(int fd, int require_auth) {$/;"	f
connCreateSocket	connection.c	/^connection *connCreateSocket() {$/;"	f
connCreateTLS	tls.c	/^connection *connCreateTLS(void) { $/;"	f
connCreateTLS	tls.c	/^connection *connCreateTLS(void) {$/;"	f
connDecrRefs	connhelpers.h	/^static inline void connDecrRefs(connection *conn) {$/;"	f
connDisableTcpNoDelay	connection.c	/^int connDisableTcpNoDelay(connection *conn) {$/;"	f
connEnableTcpNoDelay	connection.c	/^int connEnableTcpNoDelay(connection *conn) {$/;"	f
connFormatFdAddr	connection.c	/^int connFormatFdAddr(connection *conn, char *buf, size_t buf_len, int fd_to_str_type) {$/;"	f
connGetInfo	connection.c	/^const char *connGetInfo(connection *conn, char *buf, size_t buf_len) {$/;"	f
connGetLastError	connection.h	/^static inline const char *connGetLastError(connection *conn) {$/;"	f
connGetPrivateData	connection.c	/^void *connGetPrivateData(connection *conn) {$/;"	f
connGetSocketError	connection.c	/^int connGetSocketError(connection *conn) {$/;"	f
connGetState	connection.c	/^int connGetState(connection *conn) {$/;"	f
connGetType	connection.h	/^static inline int connGetType(connection *conn) {$/;"	f
connHasReadHandler	connection.c	/^int connHasReadHandler(connection *conn) {$/;"	f
connHasRefs	connhelpers.h	/^static inline int connHasRefs(connection *conn) {$/;"	f
connHasWriteHandler	connection.c	/^int connHasWriteHandler(connection *conn) {$/;"	f
connIncrRefs	connhelpers.h	/^static inline void connIncrRefs(connection *conn) {$/;"	f
connKeepAlive	connection.c	/^int connKeepAlive(connection *conn, int interval) {$/;"	f
connNonBlock	connection.c	/^int connNonBlock(connection *conn) {$/;"	f
connPeerToString	connection.c	/^int connPeerToString(connection *conn, char *ip, size_t ip_len, int *port) {$/;"	f
connRead	connection.h	/^static inline int connRead(connection *conn, void *buf, size_t buf_len) {$/;"	f
connRecvTimeout	connection.c	/^int connRecvTimeout(connection *conn, long long ms) {$/;"	f
connSendTimeout	connection.c	/^int connSendTimeout(connection *conn, long long ms) {$/;"	f
connSetPrivateData	connection.c	/^void connSetPrivateData(connection *conn, void *data) {$/;"	f
connSetReadHandler	connection.h	/^static inline int connSetReadHandler(connection *conn, ConnectionCallbackFunc func) {$/;"	f
connSetWriteHandler	connection.h	/^static inline int connSetWriteHandler(connection *conn, ConnectionCallbackFunc func) {$/;"	f
connSetWriteHandlerWithBarrier	connection.h	/^static inline int connSetWriteHandlerWithBarrier(connection *conn, ConnectionCallbackFunc func, int barrier) {$/;"	f
connSockName	connection.c	/^int connSockName(connection *conn, char *ip, size_t ip_len, int *port) {$/;"	f
connSocketAccept	connection.c	/^static int connSocketAccept(connection *conn, ConnectionCallbackFunc accept_handler) {$/;"	f	file:
connSocketBlockingConnect	connection.c	/^static int connSocketBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {$/;"	f	file:
connSocketClose	connection.c	/^static void connSocketClose(connection *conn) {$/;"	f	file:
connSocketConnect	connection.c	/^static int connSocketConnect(connection *conn, const char *addr, int port, const char *src_addr,$/;"	f	file:
connSocketEventHandler	connection.c	/^static void connSocketEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask)$/;"	f	file:
connSocketGetLastError	connection.c	/^static const char *connSocketGetLastError(connection *conn) {$/;"	f	file:
connSocketGetType	connection.c	/^static int connSocketGetType(connection *conn) {$/;"	f	file:
connSocketRead	connection.c	/^static int connSocketRead(connection *conn, void *buf, size_t buf_len) {$/;"	f	file:
connSocketSetReadHandler	connection.c	/^static int connSocketSetReadHandler(connection *conn, ConnectionCallbackFunc func) {$/;"	f	file:
connSocketSetWriteHandler	connection.c	/^static int connSocketSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {$/;"	f	file:
connSocketSyncRead	connection.c	/^static ssize_t connSocketSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {$/;"	f	file:
connSocketSyncReadLine	connection.c	/^static ssize_t connSocketSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {$/;"	f	file:
connSocketSyncWrite	connection.c	/^static ssize_t connSocketSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {$/;"	f	file:
connSocketWrite	connection.c	/^static int connSocketWrite(connection *conn, const void *data, size_t data_len) {$/;"	f	file:
connSyncRead	connection.h	/^static inline ssize_t connSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {$/;"	f
connSyncReadLine	connection.h	/^static inline ssize_t connSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {$/;"	f
connSyncWrite	connection.h	/^static inline ssize_t connSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {$/;"	f
connTLSAccept	tls.c	/^static int connTLSAccept(connection *_conn, ConnectionCallbackFunc accept_handler) {$/;"	f	file:
connTLSBlockingConnect	tls.c	/^static int connTLSBlockingConnect(connection *conn_, const char *addr, int port, long long timeout) {$/;"	f	file:
connTLSClose	tls.c	/^static void connTLSClose(connection *conn_) {$/;"	f	file:
connTLSConnect	tls.c	/^static int connTLSConnect(connection *conn_, const char *addr, int port, const char *src_addr, ConnectionCallbackFunc connect_handler) {$/;"	f	file:
connTLSGetLastError	tls.c	/^static const char *connTLSGetLastError(connection *conn_) {$/;"	f	file:
connTLSGetPeerCert	tls.c	/^sds connTLSGetPeerCert(connection *conn_) {$/;"	f
connTLSGetType	tls.c	/^static int connTLSGetType(connection *conn_) {$/;"	f	file:
connTLSRead	tls.c	/^static int connTLSRead(connection *conn_, void *buf, size_t buf_len) {$/;"	f	file:
connTLSSetReadHandler	tls.c	/^int connTLSSetReadHandler(connection *conn, ConnectionCallbackFunc func) {$/;"	f
connTLSSetWriteHandler	tls.c	/^int connTLSSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {$/;"	f
connTLSSyncRead	tls.c	/^static ssize_t connTLSSyncRead(connection *conn_, char *ptr, ssize_t size, long long timeout) {$/;"	f	file:
connTLSSyncReadLine	tls.c	/^static ssize_t connTLSSyncReadLine(connection *conn_, char *ptr, ssize_t size, long long timeout) {$/;"	f	file:
connTLSSyncWrite	tls.c	/^static ssize_t connTLSSyncWrite(connection *conn_, char *ptr, ssize_t size, long long timeout) {$/;"	f	file:
connTLSWrite	tls.c	/^static int connTLSWrite(connection *conn_, const void *data, size_t data_len) {$/;"	f	file:
connWrite	connection.h	/^static inline int connWrite(connection *conn, const void *data, size_t data_len) {$/;"	f
conn_handler	connection.h	/^    ConnectionCallbackFunc conn_handler;$/;"	m	struct:connection
connect	connection.h	/^    int (*connect)(struct connection *conn, const char *addr, int port, const char *source_addr, ConnectionCallbackFunc connect_handler);$/;"	m	struct:ConnectionType
connectWithMaster	replication.c	/^int connectWithMaster(void) {$/;"	f
connected	redis-cli.c	/^    int connected;$/;"	m	struct:clusterManagerLink	file:
connection	connection.h	/^struct connection {$/;"	s
connection	connection.h	/^typedef struct connection connection;$/;"	t	typeref:struct:connection
consumeNewline	redis-check-aof.c	/^int consumeNewline(char *buf) {$/;"	f
consumer	stream.h	/^    streamConsumer *consumer;   \/* The consumer this message was delivered to$/;"	m	struct:streamNACK
consumers	stream.h	/^    rax *consumers;         \/* A radix tree representing the consumers by name$/;"	m	struct:streamCG
container	quicklist.h	/^    unsigned int container : 2;  \/* NONE==1 or ZIPLIST==2 *\/$/;"	m	struct:quicklistNode
contents	intset.h	/^    int8_t contents[];$/;"	m	struct:intset
context	acl.c	/^    int context;        \/* Toplevel, Lua or MULTI\/EXEC? ACL_LOG_CTX_*. *\/$/;"	m	struct:ACLLogEntry	file:
context	redis-benchmark.c	/^    redisContext *context;$/;"	m	struct:_client	file:
context	redis-cli.c	/^    redisContext *context;$/;"	m	struct:clusterManagerNode	file:
context	redis-cli.c	/^static redisContext *context;$/;"	v	file:
context	sentinel.c	/^    redisAsyncContext *context;$/;"	m	struct:redisAeEvents	file:
conversion	geohash.h	/^    double conversion; \/* km: 1000 *\/$/;"	m	struct:__anon24
convert_empty_to_null	config.c	/^    int convert_empty_to_null; \/* Boolean indicating if empty SDS strings should$/;"	m	struct:sdsConfigData	file:
convert_empty_to_null	config.c	/^    int convert_empty_to_null; \/* Boolean indicating if empty strings should$/;"	m	struct:stringConfigData	file:
copy	redismodule.h	/^    RedisModuleTypeCopyFunc copy;$/;"	m	struct:RedisModuleTypeMethods
copy	server.h	/^    moduleTypeCopyFunc copy;$/;"	m	struct:RedisModuleType
copyClientOutputBuffer	networking.c	/^void copyClientOutputBuffer(client *dst, client *src) {$/;"	f
copyCommand	db.c	/^void copyCommand(client *c) {$/;"	f
count	acl.c	/^    uint64_t count;     \/* Number of times this happened recently. *\/$/;"	m	struct:ACLLogEntry	file:
count	cluster.h	/^    uint16_t count;     \/* Only used for some kind of messages. *\/$/;"	m	struct:__anon12
count	quicklist.h	/^    unsigned int count : 16;     \/* count of items in ziplist *\/$/;"	m	struct:quicklistNode
count	quicklist.h	/^    unsigned long count;        \/* total count of all entries in all ziplists *\/$/;"	m	struct:quicklist
count	redis-cli.c	/^    int count;                  \/* Non-NULL nodes count *\/$/;"	m	struct:clusterManagerNodeArray	file:
count	redis-cli.c	/^    long long count; \/* Number of samples in this interval. *\/$/;"	m	struct:distsamples	file:
count	redis-cli.c	/^    unsigned long long count;$/;"	m	struct:__anon36	file:
count	server.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	struct:multiState
count	server.h	/^    int count;$/;"	m	struct:socketFds
count	server.h	/^    long long count;$/;"	m	struct:redisError
count	sha1.h	/^    uint32_t count[2];$/;"	m	struct:__anon57
countKeysInSlot	db.c	/^unsigned int countKeysInSlot(unsigned int hashslot) {$/;"	f
cow	childinfo.c	/^    size_t cow;$/;"	m	struct:__anon1	file:
cow_updated	childinfo.c	/^    monotime cow_updated;$/;"	m	struct:__anon1	file:
cport	cluster.h	/^    int cport;                  \/* Latest known cluster port of this node. *\/$/;"	m	struct:clusterNode
cport	cluster.h	/^    uint16_t cport;             \/* cluster port last time it was seen *\/$/;"	m	struct:__anon2
cport	cluster.h	/^    uint16_t cport;      \/* Sender TCP cluster bus port *\/$/;"	m	struct:__anon12
crashlog_enabled	server.h	/^    int crashlog_enabled;           \/* Enable signal handler for crashlog.$/;"	m	struct:redisServer
crc16	crc16.c	/^uint16_t crc16(const char *buf, int len) {$/;"	f
crc16_slot_table	crc16_slottable.h	/^const char *crc16_slot_table[] = {$/;"	v
crc16tab	crc16.c	/^static const uint16_t crc16tab[256]= {$/;"	v	file:
crc64	crc64.c	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {$/;"	f
crc64Test	crc64.c	/^int crc64Test(int argc, char *argv[], int accurate) {$/;"	f
crc64_init	crc64.c	/^void crc64_init(void) {$/;"	f
crc64_table	crc64.c	/^static uint64_t crc64_table[8][256] = {{0}};$/;"	v	file:
crc_reflect	crc64.c	/^static inline uint_fast64_t crc_reflect(uint_fast64_t data, size_t data_len) {$/;"	f	file:
crcfn16	crcspeed.h	/^typedef uint16_t (*crcfn16)(uint16_t, const void *, const uint64_t);$/;"	t
crcfn64	crcspeed.h	/^typedef uint64_t (*crcfn64)(uint64_t, const void *, const uint64_t);$/;"	t
crcspeed16big	crcspeed.c	/^uint16_t crcspeed16big(uint16_t big_table[8][256], uint16_t crc_in, void *buf,$/;"	f
crcspeed16big_init	crcspeed.c	/^void crcspeed16big_init(crcfn16 fn, uint16_t big_table[8][256]) {$/;"	f
crcspeed16little	crcspeed.c	/^uint16_t crcspeed16little(uint16_t little_table[8][256], uint16_t crc,$/;"	f
crcspeed16little_init	crcspeed.c	/^void crcspeed16little_init(crcfn16 crcfn, uint16_t table[8][256]) {$/;"	f
crcspeed16native	crcspeed.c	/^uint16_t crcspeed16native(uint16_t table[8][256], uint16_t crc, void *buf,$/;"	f
crcspeed16native_init	crcspeed.c	/^void crcspeed16native_init(crcfn16 fn, uint16_t table[8][256]) {$/;"	f
crcspeed64big	crcspeed.c	/^uint64_t crcspeed64big(uint64_t big_table[8][256], uint64_t crc, void *buf,$/;"	f
crcspeed64big_init	crcspeed.c	/^void crcspeed64big_init(crcfn64 fn, uint64_t big_table[8][256]) {$/;"	f
crcspeed64little	crcspeed.c	/^uint64_t crcspeed64little(uint64_t little_table[8][256], uint64_t crc,$/;"	f
crcspeed64little_init	crcspeed.c	/^void crcspeed64little_init(crcfn64 crcfn, uint64_t table[8][256]) {$/;"	f
crcspeed64native	crcspeed.c	/^uint64_t crcspeed64native(uint64_t table[8][256], uint64_t crc, void *buf,$/;"	f
crcspeed64native_init	crcspeed.c	/^void crcspeed64native_init(crcfn64 fn, uint64_t table[8][256]) {$/;"	f
createAOFClient	aof.c	/^struct client *createAOFClient(void) {$/;"	f
createBenchmarkThread	redis-benchmark.c	/^static benchmarkThread *createBenchmarkThread(int index) {$/;"	f	file:
createBoolConfig	config.c	1784;"	d	file:
createClient	networking.c	/^client *createClient(connection *conn) {$/;"	f
createClient	redis-benchmark.c	/^static client createClient(char *cmd, size_t len, client from, int thread_id) {$/;"	f	file:
createClusterLink	cluster.c	/^clusterLink *createClusterLink(clusterNode *node) {$/;"	f
createClusterManagerCommand	redis-cli.c	/^static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {$/;"	f	file:
createClusterNode	cluster.c	/^clusterNode *createClusterNode(char *nodename, int flags) {$/;"	f
createClusterNode	redis-benchmark.c	/^static clusterNode *createClusterNode(char *ip, int port) {$/;"	f	file:
createDumpPayload	cluster.c	/^void createDumpPayload(rio *payload, robj *o, robj *key) {$/;"	f
createEmbeddedStringObject	object.c	/^robj *createEmbeddedStringObject(const char *ptr, size_t len) {$/;"	f
createEnumConfig	config.c	1925;"	d	file:
createHLLObject	hyperloglog.c	/^robj *createHLLObject(void) {$/;"	f
createHashObject	object.c	/^robj *createHashObject(void) {$/;"	f
createHelloTypeObject	modules/hellotype.c	/^struct HelloTypeObject *createHelloTypeObject(void) {$/;"	f
createInstanceLink	sentinel.c	/^instanceLink *createInstanceLink(void) {$/;"	f
createIntConfig	config.c	2090;"	d	file:
createIntList	ziplist.c	/^static unsigned char *createIntList() {$/;"	f	file:
createIntsetObject	object.c	/^robj *createIntsetObject(void) {$/;"	f
createLatencyReport	latency.c	/^sds createLatencyReport(void) {$/;"	f
createList	ziplist.c	/^static unsigned char *createList() {$/;"	f	file:
createLongConfig	config.c	2104;"	d	file:
createLongLongConfig	config.c	2118;"	d	file:
createMissingClients	redis-benchmark.c	/^static void createMissingClients(client c) {$/;"	f	file:
createModuleObject	object.c	/^robj *createModuleObject(moduleType *mt, void *value) {$/;"	f
createObject	object.c	/^robj *createObject(int type, void *ptr) {$/;"	f
createObjectFromStreamID	t_stream.c	/^robj *createObjectFromStreamID(streamID *id) {$/;"	f
createOffTConfig	config.c	2153;"	d	file:
createPidFile	server.c	/^void createPidFile(void) {$/;"	f
createQuicklistObject	object.c	/^robj *createQuicklistObject(void) {$/;"	f
createRawStringObject	object.c	/^robj *createRawStringObject(const char *ptr, size_t len) {$/;"	f
createReplicationBacklog	replication.c	/^void createReplicationBacklog(void) {$/;"	f
createSDSConfig	config.c	1869;"	d	file:
createSSLContext	tls.c	/^static SSL_CTX *createSSLContext(redisTLSContextConfig *ctx_config, int protocols, int client) {$/;"	f	file:
createSSizeTConfig	config.c	2139;"	d	file:
createSentinelAddr	sentinel.c	/^sentinelAddr *createSentinelAddr(char *hostname, int port) {$/;"	f
createSentinelRedisInstance	sentinel.c	/^sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {$/;"	f
createSet	intset.c	/^static intset *createSet(int bits, int size) {$/;"	f	file:
createSetObject	object.c	/^robj *createSetObject(void) {$/;"	f
createSharedObjects	server.c	/^void createSharedObjects(void) {$/;"	f
createSizeTConfig	config.c	2132;"	d	file:
createSocketAcceptHandler	server.c	/^int createSocketAcceptHandler(socketFds *sfd, aeFileProc *accept_handler) {$/;"	f
createSortOperation	sort.c	/^redisSortOperation *createSortOperation(int type, robj *pattern) {$/;"	f
createSparklineSequence	sparkline.c	/^struct sequence *createSparklineSequence(void) {$/;"	f
createStreamObject	object.c	/^robj *createStreamObject(void) {$/;"	f
createStringConfig	config.c	1857;"	d	file:
createStringObject	object.c	/^robj *createStringObject(const char *ptr, size_t len) {$/;"	f
createStringObjectFromLongDouble	object.c	/^robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {$/;"	f
createStringObjectFromLongLong	object.c	/^robj *createStringObjectFromLongLong(long long value) {$/;"	f
createStringObjectFromLongLongForValue	object.c	/^robj *createStringObjectFromLongLongForValue(long long value) {$/;"	f
createStringObjectFromLongLongWithOptions	object.c	/^robj *createStringObjectFromLongLongWithOptions(long long value, int valueobj) {$/;"	f
createTLSConnection	tls.c	/^static connection *createTLSConnection(int client_side) {$/;"	f	file:
createTimeTConfig	config.c	2146;"	d	file:
createUIntConfig	config.c	2097;"	d	file:
createULongConfig	config.c	2111;"	d	file:
createULongLongConfig	config.c	2125;"	d	file:
createZiplistObject	object.c	/^robj *createZiplistObject(void) {$/;"	f
createZsetObject	object.c	/^robj *createZsetObject(void) {$/;"	f
createZsetZiplistObject	object.c	/^robj *createZsetZiplistObject(void) {$/;"	f
createconsumer	server.h	/^    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,$/;"	m	struct:sharedObjectsStruct
crlf	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
cronUpdateMemoryStats	server.c	/^void cronUpdateMemoryStats() {$/;"	f
cron_malloc_stats	server.h	/^    struct malloc_stats cron_malloc_stats; \/* sampled in serverCron(). *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::malloc_stats
cronloops	server.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	struct:redisServer
csv	redis-benchmark.c	/^    int csv;$/;"	m	struct:config	file:
ctime	acl.c	/^    mstime_t ctime;     \/* Milliseconds time of last update to this entry. *\/$/;"	m	struct:ACLLogEntry	file:
ctime	cluster.h	/^    mstime_t ctime;             \/* Link creation time *\/$/;"	m	struct:clusterLink
ctime	cluster.h	/^    mstime_t ctime; \/* Node object creation time. *\/$/;"	m	struct:clusterNode
ctime	server.h	/^    time_t ctime;           \/* Client creation time. *\/$/;"	m	struct:client
ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	struct:RedisModuleCallReply	file:
ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	struct:RedisModuleKey	file:
ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	struct:__anon32	file:
ctx	server.h	/^    struct RedisModuleCtx *ctx; \/* Optional context, see RM_GetContextFromIO()*\/$/;"	m	struct:RedisModuleIO	typeref:struct:RedisModuleIO::RedisModuleCtx
current	module.c	/^            void *current;         \/* Zset iterator current node. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
current	quicklist.h	/^    quicklistNode *current;$/;"	m	struct:quicklistIter
currentEpoch	cluster.h	/^    uint64_t currentEpoch;  \/* The epoch accordingly to the sending node. *\/$/;"	m	struct:__anon12
currentEpoch	cluster.h	/^    uint64_t currentEpoch;$/;"	m	struct:clusterState
current_client	server.h	/^    client *current_client;     \/* Current client executing the command. *\/$/;"	m	struct:redisServer
current_epoch	redis-cli.c	/^    uint64_t current_epoch;$/;"	m	struct:clusterManagerNode	file:
current_epoch	sentinel.c	/^    uint64_t current_epoch;         \/* Current epoch. *\/$/;"	m	struct:sentinelState	file:
current_sec_latency_histogram	redis-benchmark.c	/^    struct hdr_histogram* current_sec_latency_histogram;$/;"	m	struct:config	typeref:struct:config::hdr_histogram	file:
current_slot_index	redis-benchmark.c	/^    int current_slot_index;$/;"	m	struct:clusterNode	file:
currentid	module.c	/^            streamID currentid;    \/* Current entry while iterating. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon30	file:
currentline	scripting.c	/^    int currentline;    \/* Current line number. *\/$/;"	m	struct:ldbState	file:
cursor	module.c	/^    int cursor;$/;"	m	struct:RedisModuleScanCursor	file:
cursor	module.c	/^    unsigned long *cursor;$/;"	m	struct:RedisModuleDefragCtx	file:
czero	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
d	dict.h	/^        double d;$/;"	m	union:dictEntry::__anon18
d	dict.h	/^    dict *d;$/;"	m	struct:dictIterator
d2string	util.c	/^int d2string(char *buf, size_t len, double value) {$/;"	f
daemonize	server.c	/^void daemonize(void) {$/;"	f
daemonize	server.h	/^    int daemonize;                  \/* True if running as a daemon *\/$/;"	m	struct:redisServer
dallocx	zmalloc.c	80;"	d	file:
data	cluster.h	/^    union clusterMsgData data;$/;"	m	struct:__anon12	typeref:union:__anon12::clusterMsgData
data	config.c	/^    typeData data; \/* The type specific data exposed used by the interface *\/$/;"	m	struct:standardConfig	file:
data	module.c	/^    void *data;                         \/* Private data for the callback. *\/$/;"	m	struct:RedisModuleTimer	file:
data	rax.h	/^    unsigned char data[];$/;"	m	struct:raxNode
data	rax.h	/^    void *data;             \/* Data associated to this key. *\/$/;"	m	struct:raxIterator
data	sha256.h	/^	BYTE data[64];$/;"	m	struct:__anon58
data_received	cluster.h	/^    mstime_t data_received;  \/* Unix time we received any data *\/$/;"	m	struct:clusterNode
databasesCron	server.c	/^void databasesCron(void) {$/;"	f
datalen	sha256.h	/^	WORD datalen;$/;"	m	struct:__anon58
dataset	server.h	/^    size_t dataset;$/;"	m	struct:redisMemOverhead
dataset_perc	server.h	/^    float dataset_perc;$/;"	m	struct:redisMemOverhead
datasize	redis-benchmark.c	/^    int datasize;$/;"	m	struct:config	file:
dataver	redismodule.h	/^    uint64_t dataver;   \/* Version of the structure we pass as 'data'. *\/$/;"	m	struct:RedisModuleEvent
daylight_active	server.h	/^    int daylight_active;        \/* Currently in daylight saving time. *\/$/;"	m	struct:redisServer
db	module.c	/^    redisDb *db;$/;"	m	struct:RedisModuleKey	file:
db	multi.c	/^    redisDb *db;$/;"	m	struct:watchedKey	file:
db	redismodule.h	/^    uint16_t db;            \/* Selected DB. *\/$/;"	m	struct:RedisModuleClientInfo
db	server.h	/^    redisDb *db;            \/* Pointer to currently SELECTed DB. *\/$/;"	m	struct:client
db	server.h	/^    redisDb *db;$/;"	m	struct:readyList
db	server.h	/^    redisDb *db;$/;"	m	struct:redisServer
db	server.h	/^    } *db;$/;"	m	struct:redisMemOverhead	typeref:struct:redisMemOverhead::__anon46
dbAdd	db.c	/^void dbAdd(redisDb *db, robj *key, robj *val) {$/;"	f
dbAddRDBLoad	db.c	/^int dbAddRDBLoad(redisDb *db, sds key, robj *val) {$/;"	f
dbAsyncDelete	lazyfree.c	/^int dbAsyncDelete(redisDb *db, robj *key) {$/;"	f
dbBackup	db.c	/^struct dbBackup {$/;"	s	file:
dbBackup	server.h	/^typedef struct dbBackup dbBackup;$/;"	t	typeref:struct:dbBackup
dbDelete	db.c	/^int dbDelete(redisDb *db, robj *key) {$/;"	f
dbDictType	server.c	/^dictType dbDictType = {$/;"	v
dbExpiresDictType	server.c	/^dictType dbExpiresDictType = {$/;"	v
dbOverwrite	db.c	/^void dbOverwrite(redisDb *db, robj *key, robj *val) {$/;"	f
dbRandomKey	db.c	/^robj *dbRandomKey(redisDb *db) {$/;"	f
dbSwapDatabases	db.c	/^int dbSwapDatabases(int id1, int id2) {$/;"	f
dbSyncDelete	db.c	/^int dbSyncDelete(redisDb *db, robj *key) {$/;"	f
dbTotalServerKeyCount	db.c	/^long long dbTotalServerKeyCount() {$/;"	f
dbUnshareStringValue	db.c	/^robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {$/;"	f
dbarray	db.c	/^    redisDb *dbarray;$/;"	m	struct:dbBackup	file:
dbid	evict.c	/^    int dbid;                   \/* Key DB number. *\/$/;"	m	struct:evictionPoolEntry	file:
dbid	module.c	/^    int dbid;                           \/* Database number selected by the original client. *\/$/;"	m	struct:RedisModuleTimer	file:
dbid	module.c	/^    int dbid;           \/* Database number selected by the original client. *\/$/;"	m	struct:RedisModuleBlockedClient	file:
dbid	server.h	/^        size_t dbid;$/;"	m	struct:redisMemOverhead::__anon46
dbid	server.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
dbnum	redis-benchmark.c	/^    int dbnum;$/;"	m	struct:config	file:
dbnum	redis-cli.c	/^    int dbnum;$/;"	m	struct:config	file:
dbnum	redismodule.h	/^    int32_t dbnum;          \/* Flushed database number, -1 for ALL. *\/$/;"	m	struct:RedisModuleFlushInfo
dbnum	server.h	/^    int dbnum;                      \/* Total number of configured DBs *\/$/;"	m	struct:redisServer
dbnum_first	redismodule.h	/^    int32_t dbnum_first;    \/* Swap Db first dbnum *\/$/;"	m	struct:RedisModuleSwapDbInfo
dbnum_second	redismodule.h	/^    int32_t dbnum_second;   \/* Swap Db second dbnum *\/$/;"	m	struct:RedisModuleSwapDbInfo
dbnumstr	redis-benchmark.c	/^    sds dbnumstr;$/;"	m	struct:config	file:
dbsizeCommand	db.c	/^void dbsizeCommand(client *c) {$/;"	f
de	server.h	/^    dictEntry *de;$/;"	m	struct:__anon53
de	t_zset.c	/^                dictEntry *de;$/;"	m	struct:__anon61::__anon62::_iterset::__anon64	file:
debug	ziplist.c	1673;"	d	file:
debugCommand	debug.c	/^void debugCommand(client *c) {$/;"	f
debugDelay	debug.c	/^void debugDelay(int usec) {$/;"	f
debugf	rax.c	62;"	d	file:
debugf	rax.c	71;"	d	file:
debugnode	rax.c	69;"	d	file:
debugnode	rax.c	72;"	d	file:
decodeGeohash	geo.c	/^int decodeGeohash(double bits, double *xy) {$/;"	f
decodeHex	redis-cli.c	358;"	d	file:
decodeHexChar	redis-cli.c	357;"	d	file:
decodeTimeoutKey	timeout.c	/^void decodeTimeoutKey(unsigned char *buf, uint64_t *toptr, client **cptr) {$/;"	f
decrCommand	t_string.c	/^void decrCommand(client *c) {$/;"	f
decrRefCount	object.c	/^void decrRefCount(robj *o) {$/;"	f
decrRefCountVoid	object.c	/^void decrRefCountVoid(void *o) {$/;"	f
decrbyCommand	t_string.c	/^void decrbyCommand(client *c) {$/;"	f
default_username	server.h	/^    *getack, *special_asterick, *special_equals, *default_username,$/;"	m	struct:sharedObjectsStruct
default_value	config.c	/^    const char *default_value; \/* Default value of the config on rewrite. *\/$/;"	m	struct:sdsConfigData	file:
default_value	config.c	/^    const char *default_value; \/* Default value of the config on rewrite. *\/$/;"	m	struct:stringConfigData	file:
default_value	config.c	/^    const int default_value; \/* The default value of the config on rewrite *\/$/;"	m	struct:boolConfigData	file:
default_value	config.c	/^    const int default_value; \/* The default value of the config on rewrite *\/$/;"	m	struct:enumConfigData	file:
default_value	config.c	/^    const long long default_value; \/* The default value of the config on rewrite *\/$/;"	m	struct:numericConfigData	file:
defrag	redismodule.h	/^    RedisModuleTypeDefragFunc defrag;$/;"	m	struct:RedisModuleTypeMethods
defrag	server.h	/^    moduleTypeDefragFunc defrag;$/;"	m	struct:RedisModuleType
defragDictBucketCallback	defrag.c	/^void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {$/;"	f
defragHash	defrag.c	/^long defragHash(redisDb *db, dictEntry *kde) {$/;"	f
defragKey	defrag.c	/^long defragKey(redisDb *db, dictEntry *de) {$/;"	f
defragLater	defrag.c	/^void defragLater(redisDb *db, dictEntry *kde) {$/;"	f
defragLaterItem	defrag.c	/^int defragLaterItem(dictEntry *de, unsigned long *cursor, long long endtime) {$/;"	f
defragLaterStep	defrag.c	/^int defragLaterStep(redisDb *db, long long endtime) {$/;"	f
defragModule	defrag.c	/^long defragModule(redisDb *db, dictEntry *kde) {$/;"	f
defragOtherGlobals	defrag.c	/^long defragOtherGlobals() {$/;"	f
defragQuicklist	defrag.c	/^long defragQuicklist(redisDb *db, dictEntry *kde) {$/;"	f
defragRadixTree	defrag.c	/^long defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_cb, void *element_cb_data) {$/;"	f
defragRaxNode	defrag.c	/^int defragRaxNode(raxNode **noderef) {$/;"	f
defragScanCallback	defrag.c	/^void defragScanCallback(void *privdata, const dictEntry *de) {$/;"	f
defragSet	defrag.c	/^long defragSet(redisDb *db, dictEntry *kde) {$/;"	f
defragStream	defrag.c	/^long defragStream(redisDb *db, dictEntry *kde) {$/;"	f
defragStreamConsumer	defrag.c	/^void* defragStreamConsumer(raxIterator *ri, void *privdata, long *defragged) {$/;"	f
defragStreamConsumerGroup	defrag.c	/^void* defragStreamConsumerGroup(raxIterator *ri, void *privdata, long *defragged) {$/;"	f
defragStreamConsumerPendingEntry	defrag.c	/^void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, long *defragged) {$/;"	f
defragZsetSkiplist	defrag.c	/^long defragZsetSkiplist(redisDb *db, dictEntry *kde) {$/;"	f
defrag_cb	module.c	/^    RedisModuleDefragFunc defrag_cb;    \/* Callback for global data defrag. *\/$/;"	m	struct:RedisModule	file:
defrag_later	server.h	/^    list *defrag_later;         \/* List of key names to attempt to defrag one by one, gradually. *\/$/;"	m	struct:redisDb
defrag_later_current_key	defrag.c	/^static sds defrag_later_current_key = NULL;$/;"	v	file:
defrag_later_cursor	defrag.c	/^static unsigned long defrag_later_cursor = 0;$/;"	v	file:
defragged	defrag.c	/^    long defragged;$/;"	m	struct:__anon16	file:
defragged	module.c	/^    long defragged;$/;"	m	struct:RedisModuleDefragCtx	file:
deg_rad	geohash_helper.c	/^static inline double deg_rad(double ang) { return ang * D_R; }$/;"	f	file:
deinterleave64	geohash.c	/^static inline uint64_t deinterleave64(uint64_t interleaved) {$/;"	f	file:
del	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	struct:sharedObjectsStruct
delCommand	db.c	/^void delCommand(client *c) {$/;"	f
delCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::redisCommand
delGenericCommand	db.c	/^void delGenericCommand(client *c, int lazy) {$/;"	f
delKeysInSlot	db.c	/^unsigned int delKeysInSlot(unsigned int hashslot) {$/;"	f
delivery_count	stream.h	/^    uint64_t delivery_count;    \/* Number of times this message was delivered.*\/$/;"	m	struct:streamNACK
delivery_time	stream.h	/^    mstime_t delivery_time;     \/* Last time this message was delivered. *\/$/;"	m	struct:streamNACK
deny_scripts_reconfig	sentinel.c	/^    int deny_scripts_reconfig; \/* Allow SENTINEL SET ... to change script$/;"	m	struct:sentinelState	file:
deriveAnnouncedPorts	cluster.c	/^void deriveAnnouncedPorts(int *announced_port, int *announced_pport,$/;"	f
desc	redis-cli.c	/^    char *desc;$/;"	m	struct:clusterManagerOptionDef	file:
dh_params_file	server.h	/^    char *dh_params_file;$/;"	m	struct:redisTLSContextConfig
di	server.h	/^    dictIterator *di;$/;"	m	struct:__anon52
di	server.h	/^    dictIterator *di;$/;"	m	struct:__anon53
di	t_zset.c	/^                dictIterator *di;$/;"	m	struct:__anon61::__anon62::_iterset::__anon64	file:
dict	dict.h	/^typedef struct dict {$/;"	s
dict	dict.h	/^} dict;$/;"	t	typeref:struct:dict
dict	module.c	/^    RedisModuleDict *dict;$/;"	m	struct:RedisModuleDictIter	file:
dict	server.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	struct:redisDb
dict	server.h	/^    dict *dict;$/;"	m	struct:zset
dict	t_zset.c	/^                dict *dict;$/;"	m	struct:__anon61::__anon62::_iterset::__anon64	file:
dictAdd	dict.c	/^int dictAdd(dict *d, void *key, void *val)$/;"	f
dictAddOrFind	dict.c	/^dictEntry *dictAddOrFind(dict *d, void *key) {$/;"	f
dictAddRaw	dict.c	/^dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)$/;"	f
dictCStringKeyCompare	module.c	/^int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {$/;"	f
dictCStringKeyHash	module.c	/^uint64_t dictCStringKeyHash(const void *key) {$/;"	f
dictCompareKeys	dict.h	139;"	d
dictCreate	dict.c	/^dict *dictCreate(dictType *type,$/;"	f
dictDefragTables	defrag.c	/^long dictDefragTables(dict* d) {$/;"	f
dictDelete	dict.c	/^int dictDelete(dict *ht, const void *key) {$/;"	f
dictDisableResize	dict.c	/^void dictDisableResize(void) {$/;"	f
dictEmpty	dict.c	/^void dictEmpty(dict *d, void(callback)(void*)) {$/;"	f
dictEnableResize	dict.c	/^void dictEnableResize(void) {$/;"	f
dictEncObjHash	server.c	/^uint64_t dictEncObjHash(const void *key) {$/;"	f
dictEncObjKeyCompare	server.c	/^int dictEncObjKeyCompare(void *privdata, const void *key1,$/;"	f
dictEntry	dict.h	/^typedef struct dictEntry {$/;"	s
dictEntry	dict.h	/^} dictEntry;$/;"	t	typeref:struct:dictEntry
dictExpand	dict.c	/^int dictExpand(dict *d, unsigned long size) {$/;"	f
dictExpandAllowed	server.c	/^int dictExpandAllowed(size_t moreMem, double usedRatio) {$/;"	f
dictFetchValue	dict.c	/^void *dictFetchValue(dict *d, const void *key) {$/;"	f
dictFind	dict.c	/^dictEntry *dictFind(dict *d, const void *key)$/;"	f
dictFindEntryRefByPtrAndHash	dict.c	/^dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {$/;"	f
dictFingerprint	dict.c	/^long long dictFingerprint(dict *d) {$/;"	f
dictFreeKey	dict.h	128;"	d
dictFreeUnlinkedEntry	dict.c	/^void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {$/;"	f
dictFreeVal	dict.h	108;"	d
dictGenCaseHashFunction	dict.c	/^uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {$/;"	f
dictGenHashFunction	dict.c	/^uint64_t dictGenHashFunction(const void *key, int len) {$/;"	f
dictGenericDelete	dict.c	/^static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {$/;"	f	file:
dictGetDoubleVal	dict.h	149;"	d
dictGetFairRandomKey	dict.c	/^dictEntry *dictGetFairRandomKey(dict *d) {$/;"	f
dictGetHash	dict.c	/^uint64_t dictGetHash(dict *d, const void *key) {$/;"	f
dictGetHashFunctionSeed	dict.c	/^uint8_t *dictGetHashFunctionSeed(void) {$/;"	f
dictGetIterator	dict.c	/^dictIterator *dictGetIterator(dict *d)$/;"	f
dictGetKey	dict.h	145;"	d
dictGetRandomKey	dict.c	/^dictEntry *dictGetRandomKey(dict *d)$/;"	f
dictGetSafeIterator	dict.c	/^dictIterator *dictGetSafeIterator(dict *d) {$/;"	f
dictGetSignedIntegerVal	dict.h	147;"	d
dictGetSomeKeys	dict.c	/^unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {$/;"	f
dictGetStats	dict.c	/^void dictGetStats(char *buf, size_t bufsize, dict *d) {$/;"	f
dictGetUnsignedIntegerVal	dict.h	148;"	d
dictGetVal	dict.h	146;"	d
dictHashKey	dict.h	144;"	d
dictInstancesValDestructor	sentinel.c	/^void dictInstancesValDestructor (void *privdata, void *obj) {$/;"	f
dictIsRehashing	dict.h	152;"	d
dictIterDefragEntry	defrag.c	/^long dictIterDefragEntry(dictIterator *iter) {$/;"	f
dictIterator	dict.h	/^typedef struct dictIterator {$/;"	s
dictIterator	dict.h	/^} dictIterator;$/;"	t	typeref:struct:dictIterator
dictListDestructor	redis-cli.c	/^void dictListDestructor(void *privdata, void *val)$/;"	f
dictListDestructor	server.c	/^void dictListDestructor(void *privdata, void *val)$/;"	f
dictNext	dict.c	/^dictEntry *dictNext(dictIterator *iter)$/;"	f
dictObjHash	server.c	/^uint64_t dictObjHash(const void *key) {$/;"	f
dictObjKeyCompare	server.c	/^int dictObjKeyCompare(void *privdata, const void *key1,$/;"	f
dictObjectDestructor	server.c	/^void dictObjectDestructor(void *privdata, void *val)$/;"	f
dictPauseRehashing	dict.h	153;"	d
dictRehash	dict.c	/^int dictRehash(dict *d, int n) {$/;"	f
dictRehashMilliseconds	dict.c	/^int dictRehashMilliseconds(dict *d, int ms) {$/;"	f
dictRelease	dict.c	/^void dictRelease(dict *d)$/;"	f
dictReleaseIterator	dict.c	/^void dictReleaseIterator(dictIterator *iter)$/;"	f
dictReplace	dict.c	/^int dictReplace(dict *d, void *key, void *val)$/;"	f
dictResize	dict.c	/^int dictResize(dict *d)$/;"	f
dictResumeRehashing	dict.h	154;"	d
dictScan	dict.c	/^unsigned long dictScan(dict *d,$/;"	f
dictScanBucketFunction	dict.h	/^typedef void (dictScanBucketFunction)(void *privdata, dictEntry **bucketref);$/;"	t
dictScanFunction	dict.h	/^typedef void (dictScanFunction)(void *privdata, const dictEntry *de);$/;"	t
dictSdsCaseHash	server.c	/^uint64_t dictSdsCaseHash(const void *key) {$/;"	f
dictSdsDestructor	redis-cli.c	/^static void dictSdsDestructor(void *privdata, void *val)$/;"	f	file:
dictSdsDestructor	server.c	/^void dictSdsDestructor(void *privdata, void *val)$/;"	f
dictSdsHash	redis-benchmark.c	/^static uint64_t dictSdsHash(const void *key) {$/;"	f	file:
dictSdsHash	redis-cli.c	/^static uint64_t dictSdsHash(const void *key) {$/;"	f	file:
dictSdsHash	server.c	/^uint64_t dictSdsHash(const void *key) {$/;"	f
dictSdsKeyCaseCompare	server.c	/^int dictSdsKeyCaseCompare(void *privdata, const void *key1,$/;"	f
dictSdsKeyCompare	redis-benchmark.c	/^static int dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f	file:
dictSdsKeyCompare	redis-cli.c	/^static int dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f	file:
dictSdsKeyCompare	server.c	/^int dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f
dictSetDoubleVal	dict.h	125;"	d
dictSetHashFunctionSeed	dict.c	/^void dictSetHashFunctionSeed(uint8_t *seed) {$/;"	f
dictSetKey	dict.h	132;"	d
dictSetSignedIntegerVal	dict.h	119;"	d
dictSetUnsignedIntegerVal	dict.h	122;"	d
dictSetVal	dict.h	112;"	d
dictSize	dict.h	151;"	d
dictSlots	dict.h	150;"	d
dictStringHash	latency.c	/^uint64_t dictStringHash(const void *key) {$/;"	f
dictStringKeyCompare	latency.c	/^int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {$/;"	f
dictTest	dict.c	/^int dictTest(int argc, char **argv, int accurate) {$/;"	f
dictTryExpand	dict.c	/^int dictTryExpand(dict *d, unsigned long size) {$/;"	f
dictType	dict.h	/^typedef struct dictType {$/;"	s
dictType	dict.h	/^} dictType;$/;"	t	typeref:struct:dictType
dictTypeExpandAllowed	dict.c	/^static int dictTypeExpandAllowed(dict *d) {$/;"	f	file:
dictUnlink	dict.c	/^dictEntry *dictUnlink(dict *ht, const void *key) {$/;"	f
dictVanillaFree	server.c	/^void dictVanillaFree(void *privdata, void *val)$/;"	f
dict_can_resize	dict.c	/^static int dict_can_resize = 1;$/;"	v	file:
dict_force_resize_ratio	dict.c	/^static unsigned int dict_force_resize_ratio = 5;$/;"	v	file:
dict_hash_function_seed	dict.c	/^static uint8_t dict_hash_function_seed[16];$/;"	v	file:
dictht	dict.h	/^typedef struct dictht {$/;"	s
dictht	dict.h	/^} dictht;$/;"	t	typeref:struct:dictht
digest	redismodule.h	/^    RedisModuleTypeDigestFunc digest;$/;"	m	struct:RedisModuleTypeMethods
digest	server.h	/^    moduleTypeDigestFunc digest;$/;"	m	struct:RedisModuleType
digits10	util.c	/^uint32_t digits10(uint64_t v) {$/;"	f
direction	adlist.h	/^    int direction;$/;"	m	struct:listIter
direction	quicklist.h	/^    int direction;$/;"	m	struct:quicklistIter
direction	server.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	struct:__anon50
dirty	redis-cli.c	/^    int dirty;      \/* Node has changes that can be flushed *\/$/;"	m	struct:clusterManagerNode	file:
dirty	server.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	struct:redisServer
dirty_before_bgsave	server.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	struct:redisServer
disableTracking	tracking.c	/^void disableTracking(client *c) {$/;"	f
disableWatchdog	debug.c	/^void disableWatchdog(void) {$/;"	f
disable_thp	server.h	/^    int disable_thp;                              \/* If true, disable THP by syscall *\/$/;"	m	struct:redisServer
discardCommand	multi.c	/^void discardCommand(client *c) {$/;"	f
discardDbBackup	db.c	/^void discardDbBackup(dbBackup *buckup, int flags, void(callback)(void*)) {$/;"	f
discardTransaction	multi.c	/^void discardTransaction(client *c) {$/;"	f
disconnectAllBlockedClients	blocked.c	/^void disconnectAllBlockedClients(void) {$/;"	f
disconnectSlaves	networking.c	/^void disconnectSlaves(void) {$/;"	f
disconnect_callback	module.c	/^    RedisModuleDisconnectFunc disconnect_callback; \/* Called on disconnection.*\/$/;"	m	struct:RedisModuleBlockedClient	file:
disconnected	sentinel.c	/^    int disconnected;      \/* Non-zero if we need to reconnect cc or pc. *\/$/;"	m	struct:instanceLink	file:
disklessLoadDiscardBackup	replication.c	/^void disklessLoadDiscardBackup(dbBackup *buckup, int flag) {$/;"	f
disklessLoadMakeBackup	replication.c	/^dbBackup *disklessLoadMakeBackup(void) {$/;"	f
disklessLoadRestoreBackup	replication.c	/^void disklessLoadRestoreBackup(dbBackup *buckup) {$/;"	f
dist	geo.h	/^    double dist;$/;"	m	struct:geoPoint
distsamples	redis-cli.c	/^struct distsamples {$/;"	s	file:
doFastMemoryTest	debug.c	/^void doFastMemoryTest(void) {$/;"	f
docufy	modules/gendoc.rb	/^def docufy(src,i)$/;"	f
doing	redis-check-rdb.c	/^    int doing;                      \/* The state while reading the RDB. *\/$/;"	m	struct:__anon34	file:
done	module.c	/^    int done;$/;"	m	struct:RedisModuleScanCursor	file:
done_handler	module.c	/^    RedisModuleForkDoneHandler done_handler;$/;"	m	struct:RedisModuleForkInfo	file:
done_handler_user_data	module.c	/^    void* done_handler_user_data;$/;"	m	struct:RedisModuleForkInfo	file:
down_after_period	sentinel.c	/^    mstime_t down_after_period; \/* Consider it down after that period. *\/$/;"	m	struct:sentinelRedisInstance	file:
dstkey	t_zset.c	/^    robj                                *dstkey;$/;"	m	struct:zrange_result_handler	file:
dstobj	t_zset.c	/^    robj                                *dstobj;$/;"	m	struct:zrange_result_handler	file:
dumpCodeAroundEIP	debug.c	/^void dumpCodeAroundEIP(void *eip) {$/;"	f
dumpCommand	cluster.c	/^void dumpCommand(client *c) {$/;"	f
dumpX86Calls	debug.c	/^void dumpX86Calls(void *addr, size_t len) {$/;"	f
dup	adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list
dupClientReplyValue	networking.c	/^void *dupClientReplyValue(void *o) {$/;"	f
dupSentinelAddr	sentinel.c	/^sentinelAddr *dupSentinelAddr(sentinelAddr *src) {$/;"	f
dupStringObject	object.c	/^robj *dupStringObject(const robj *o) {$/;"	f
duration	server.h	/^    long duration;          \/* Current command duration. Used for measuring latency of blocking\/non-blocking cmds *\/$/;"	m	struct:client
duration	slowlog.h	/^    long long duration; \/* Time spent by the query, in microseconds. *\/$/;"	m	struct:slowlogEntry
dynamic_hz	server.h	/^    int dynamic_hz;             \/* Change hz value depending on # of clients. *\/$/;"	m	struct:redisServer
east	geohash.h	/^    GeoHashBits east;$/;"	m	struct:__anon23
echoCommand	server.c	/^void echoCommand(client *c) {$/;"	f
el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	struct:benchmarkThread	file:
el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	struct:config	file:
el	server.h	/^    aeEventLoop *el;$/;"	m	struct:redisServer
elapsedMs	monotonic.h	/^static inline uint64_t elapsedMs(monotime start_time) {$/;"	f
elapsedStart	monotonic.h	/^static inline void elapsedStart(monotime *start_time) {$/;"	f
elapsedUs	monotonic.h	/^static inline uint64_t elapsedUs(monotime start_time) {$/;"	f
ele	server.h	/^    sds ele;$/;"	m	struct:zskiplistNode
ele	t_zset.c	/^    sds ele;$/;"	m	struct:__anon67	file:
elen	t_zset.c	/^    unsigned int elen;$/;"	m	struct:__anon67	file:
ell	t_zset.c	/^    long long ell;$/;"	m	struct:__anon67	file:
embedCommonConfig	config.c	1730;"	d	file:
embedCommonNumericalConfig	config.c	2079;"	d	file:
embedConfigInterface	config.c	1735;"	d	file:
emitResultFromCBuffer	t_zset.c	/^    zrangeResultEmitCBufferFunction      emitResultFromCBuffer;$/;"	m	struct:zrange_result_handler	file:
emitResultFromLongLong	t_zset.c	/^    zrangeResultEmitLongLongFunction     emitResultFromLongLong;$/;"	m	struct:zrange_result_handler	file:
emptyDb	db.c	/^long long emptyDb(int dbnum, int flags, void(callback)(void*)) {$/;"	f
emptyDbAsync	lazyfree.c	/^void emptyDbAsync(redisDb *db) {$/;"	f
emptyDbStructure	db.c	/^long long emptyDbStructure(redisDb *dbarray, int dbnum, int async,$/;"	f
emptyarray	server.h	/^    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
emptybulk	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
emptymap	server.h	/^    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],$/;"	m	struct:sharedObjectsStruct
emptyscan	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
emptyset	server.h	/^    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],$/;"	m	struct:sharedObjectsStruct
enableBcastTrackingForPrefix	tracking.c	/^void enableBcastTrackingForPrefix(client *c, char *prefix, size_t plen) {$/;"	f
enableTracking	tracking.c	/^void enableTracking(client *c, uint64_t redirect_to, uint64_t options, robj **prefix, size_t numprefix) {$/;"	f
enableWatchdog	debug.c	/^void enableWatchdog(int period) {$/;"	f
enable_ldb_on_eval	redis-cli.c	/^    int enable_ldb_on_eval; \/* Handle manual SCRIPT DEBUG + EVAL commands. *\/$/;"	m	struct:config	file:
enable_tracking	redis-benchmark.c	/^    int enable_tracking;$/;"	m	struct:config	file:
encodeTimeoutKey	timeout.c	/^void encodeTimeoutKey(unsigned char *buf, uint64_t timeout, client *c) {$/;"	f
encoding	hyperloglog.c	/^    uint8_t encoding;   \/* HLL_DENSE or HLL_SPARSE. *\/$/;"	m	struct:hllhdr	file:
encoding	intset.h	/^    uint32_t encoding;$/;"	m	struct:intset
encoding	quicklist.h	/^    unsigned int encoding : 2;   \/* RAW==1 or LZF==2 *\/$/;"	m	struct:quicklistNode
encoding	server.h	/^    int encoding;$/;"	m	struct:__anon52
encoding	server.h	/^    int encoding;$/;"	m	struct:__anon53
encoding	server.h	/^    unsigned char encoding;$/;"	m	struct:__anon50
encoding	server.h	/^    unsigned encoding:4;$/;"	m	struct:redisObject
encoding	t_zset.c	/^    int encoding;$/;"	m	struct:__anon61	file:
encoding	ziplist.c	/^    unsigned char encoding;      \/* Set to ZIP_STR_* or ZIP_INT_* depending on$/;"	m	struct:zlentry	file:
end	module.c	/^            uint32_t end;          \/* End pos for positional ranges. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
end	setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon56	file:
end_benchmark	dict.c	1219;"	d	file:
end_key	stream.h	/^    uint64_t end_key[2];    \/* End key as 128 bit big endian. *\/$/;"	m	struct:streamIterator
endianconvTest	endianconv.c	/^int endianconvTest(int argc, char *argv[], int accurate) {$/;"	f
endtime	module.c	/^    long long int endtime;$/;"	m	struct:RedisModuleDefragCtx	file:
entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
entry	server.h	/^    quicklistEntry entry; \/* Entry in quicklist *\/$/;"	m	struct:__anon51
entry_flags	stream.h	/^    int entry_flags;                    \/* Flags of entry we are emitting. *\/$/;"	m	struct:streamIterator
enumConfigData	config.c	/^typedef struct enumConfigData {$/;"	s	file:
enumConfigData	config.c	/^} enumConfigData;$/;"	t	typeref:struct:enumConfigData	file:
enum_value	config.c	/^    configEnum *enum_value; \/* The underlying enum type this data represents *\/$/;"	m	struct:enumConfigData	file:
enumd	config.c	/^    enumConfigData enumd;$/;"	m	union:typeData	file:
epfd	ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
epos	redis-check-aof.c	/^static off_t epos;$/;"	v	file:
eptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon61::__anon62::_iterzset::__anon65	file:
equalStringObjects	object.c	/^int equalStringObjects(robj *a, robj *b) {$/;"	f
er	module.c	/^            int er;                \/* Zset iterator end reached flag$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
err	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
error	redis-check-aof.c	/^static char error[1044];$/;"	v	file:
error	redis-check-rdb.c	/^    char error[1024];$/;"	m	struct:__anon34	file:
error	server.h	/^    int error;          \/* True if error condition happened. *\/$/;"	m	struct:RedisModuleIO
error	setproctitle.c	/^	int error;$/;"	m	struct:__anon56	file:
error_set	redis-check-rdb.c	/^    int error_set;                  \/* True if error is populated. *\/$/;"	m	struct:__anon34	file:
errors	redis-cli.c	/^    list *errors;$/;"	m	struct:clusterManager	file:
errors	server.h	/^    rax *errors;                \/* Errors table *\/$/;"	m	struct:redisServer
estimateObjectIdleTime	evict.c	/^unsigned long long estimateObjectIdleTime(robj *o) {$/;"	f
estr	t_zset.c	/^    unsigned char *estr;$/;"	m	struct:__anon67	file:
eval	redis-cli.c	/^    char *eval;$/;"	m	struct:config	file:
eval	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
evalCommand	scripting.c	/^void evalCommand(client *c) {$/;"	f
evalGenericCommand	scripting.c	/^void evalGenericCommand(client *c, int evalsha) {$/;"	f
evalGenericCommandWithDebugging	scripting.c	/^void evalGenericCommandWithDebugging(client *c, int evalsha) {$/;"	f
evalGetKeys	db.c	/^int evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
evalMode	redis-cli.c	/^static int evalMode(int argc, char **argv) {$/;"	f	file:
evalShaCommand	scripting.c	/^void evalShaCommand(client *c) {$/;"	f
eval_ldb	redis-cli.c	/^    int eval_ldb;$/;"	m	struct:config	file:
eval_ldb_end	redis-cli.c	/^    int eval_ldb_end;   \/* Lua debugging session ended. *\/$/;"	m	struct:config	file:
eval_ldb_sync	redis-cli.c	/^    int eval_ldb_sync;  \/* Ask for synchronous mode of the Lua debugger. *\/$/;"	m	struct:config	file:
event	module.c	/^    RedisModuleEvent event;$/;"	m	struct:RedisModuleEventListener	file:
event_mask	module.c	/^    int event_mask;$/;"	m	struct:RedisModuleKeyspaceSubscriber	file:
events	ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	ae_epoll.c	/^    struct epoll_event *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	ae_kqueue.c	/^    struct kevent *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
events_processed_while_blocked	server.h	/^    long long events_processed_while_blocked; \/* processEventsWhileBlocked() *\/$/;"	m	struct:redisServer
evictPolicyToString	config.c	/^const char *evictPolicyToString(void) {$/;"	f
evictionPoolAlloc	evict.c	/^void evictionPoolAlloc(void) {$/;"	f
evictionPoolEntry	evict.c	/^struct evictionPoolEntry {$/;"	s	file:
evictionPoolPopulate	evict.c	/^void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {$/;"	f
evictionTimeLimitUs	evict.c	/^static unsigned long evictionTimeLimitUs() {$/;"	f	file:
evictionTimeProc	evict.c	/^static int evictionTimeProc($/;"	f	file:
evport_debug	ae_evport.c	/^static int evport_debug = 0;$/;"	v	file:
exec	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
execBenchmarkThread	redis-benchmark.c	/^static void *execBenchmarkThread(void *ptr) {$/;"	f	file:
execCommand	multi.c	/^void execCommand(client *c) {$/;"	f
execCommand	server.h	/^                        *zpopmaxCommand, *sremCommand, *execCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
execCommandAbort	multi.c	/^void execCommandAbort(client *c, sds error) {$/;"	f
execCommandPropagateExec	multi.c	/^void execCommandPropagateExec(int dbid) {$/;"	f
execCommandPropagateMulti	multi.c	/^void execCommandPropagateMulti(int dbid) {$/;"	f
exec_argv	server.h	/^    char **exec_argv;           \/* Executable argv vector (copy). *\/$/;"	m	struct:redisServer
execaborterr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
executable	server.h	/^    char *executable;           \/* Absolute executable file path. *\/$/;"	m	struct:redisServer
existsCommand	db.c	/^void existsCommand(client *c) {$/;"	f
exitFromChild	server.c	/^void exitFromChild(int retcode) {$/;"	f
expandAllowed	dict.h	/^    int (*expandAllowed)(size_t moreMem, double usedRatio);$/;"	m	struct:dictType
expandProcTitleTemplate	server.c	/^static sds expandProcTitleTemplate(const char *template, const char *title) {$/;"	f	file:
expect	lzf_c.c	79;"	d	file:
expect	lzf_c.c	82;"	d	file:
expect_false	lzf_c.c	86;"	d	file:
expect_true	lzf_c.c	87;"	d	file:
expireCommand	expire.c	/^void expireCommand(client *c) {$/;"	f
expireCommand	server.h	/^                        *expireCommand, *pexpireCommand, *xclaimCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
expireGenericCommand	expire.c	/^void expireGenericCommand(client *c, long long basetime, int unit) {$/;"	f
expireIfNeeded	db.c	/^int expireIfNeeded(redisDb *db, robj *key) {$/;"	f
expireSlaveKeys	expire.c	/^void expireSlaveKeys(void) {$/;"	f
expireatCommand	expire.c	/^void expireatCommand(client *c) {$/;"	f
expires	redis-check-rdb.c	/^    unsigned long expires;          \/* Number of keys with an expire. *\/$/;"	m	struct:__anon34	file:
expires	server.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	struct:redisDb
expires_cursor	server.h	/^    unsigned long expires_cursor; \/* Cursor of the active expire cycle. *\/$/;"	m	struct:redisDb
extra	quicklist.h	/^    unsigned int extra : 10; \/* more bits to steal for future usage *\/$/;"	m	struct:quicklistNode
extractBoxOrReply	geo.c	/^int extractBoxOrReply(client *c, robj **argv, double *conversion,$/;"	f
extractDistanceOrReply	geo.c	/^int extractDistanceOrReply(client *c, robj **argv,$/;"	f
extractLongLatOrReply	geo.c	/^int extractLongLatOrReply(client *c, robj **argv, double *xy) {$/;"	f
extractUnitOrReply	geo.c	/^double extractUnitOrReply(client *c, robj *unit) {$/;"	f
fail	cluster.h	/^    } fail;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon8
failTest	modules/testmodule.c	/^int failTest(RedisModuleCtx *ctx, const char *msg) {$/;"	f
fail_reports	cluster.h	/^    list *fail_reports;         \/* List of nodes signaling this as failing *\/$/;"	m	struct:clusterNode
fail_time	cluster.h	/^    mstime_t fail_time;      \/* Unix time when FAIL flag was set *\/$/;"	m	struct:clusterNode
failed	server.c	/^    int failed;$/;"	m	struct:redisTest	file:
failed_calls	server.h	/^    long long microseconds, calls, rejected_calls, failed_calls;$/;"	m	struct:redisCommand
failoverCommand	replication.c	/^void failoverCommand(client *c) {$/;"	f
failover_auth_count	cluster.h	/^    int failover_auth_count;    \/* Number of votes received so far. *\/$/;"	m	struct:clusterState
failover_auth_epoch	cluster.h	/^    uint64_t failover_auth_epoch; \/* Epoch of the current election. *\/$/;"	m	struct:clusterState
failover_auth_rank	cluster.h	/^    int failover_auth_rank;     \/* This slave rank for current auth request. *\/$/;"	m	struct:clusterState
failover_auth_sent	cluster.h	/^    int failover_auth_sent;     \/* True if we already asked for votes. *\/$/;"	m	struct:clusterState
failover_auth_time	cluster.h	/^    mstime_t failover_auth_time; \/* Time of previous or next election. *\/$/;"	m	struct:clusterState
failover_delay_logged	sentinel.c	/^    mstime_t failover_delay_logged; \/* For what failover_start_time value we$/;"	m	struct:sentinelRedisInstance	file:
failover_end_time	server.h	/^    mstime_t failover_end_time; \/* Deadline for failover command. *\/$/;"	m	struct:redisServer
failover_epoch	sentinel.c	/^    uint64_t failover_epoch; \/* Epoch of the currently started failover. *\/$/;"	m	struct:sentinelRedisInstance	file:
failover_start_time	sentinel.c	/^    mstime_t failover_start_time;   \/* Last failover attempt start time. *\/$/;"	m	struct:sentinelRedisInstance	file:
failover_state	sentinel.c	/^    int failover_state; \/* See SENTINEL_FAILOVER_STATE_* defines. *\/$/;"	m	struct:sentinelRedisInstance	file:
failover_state	server.h	/^    int failover_state; \/* Failover state *\/$/;"	m	struct:redisServer
failover_state	server.h	/^} failover_state;$/;"	t	typeref:enum:__anon43
failover_state_change_time	sentinel.c	/^    mstime_t failover_state_change_time;$/;"	m	struct:sentinelRedisInstance	file:
failover_timeout	sentinel.c	/^    mstime_t failover_timeout;      \/* Max time to refresh failover state. *\/$/;"	m	struct:sentinelRedisInstance	file:
fd	ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
fd	bio.c	/^    int fd; \/* Fd for file based background jobs *\/$/;"	m	struct:bio_job	file:
fd	connection.h	/^    int fd;$/;"	m	struct:connection
fd	rio.h	/^            int fd;       \/* File descriptor. *\/$/;"	m	struct:_rio::__anon37::__anon41
fd	rio.h	/^        } fd;$/;"	m	union:_rio::__anon37	typeref:struct:_rio::__anon37::__anon41
fd	sentinel.c	/^    int fd;$/;"	m	struct:redisAeEvents	file:
fd	server.h	/^    int fd[CONFIG_BINDADDR_MAX];$/;"	m	struct:socketFds
feedAppendOnlyFile	aof.c	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {$/;"	f
feedReplicationBacklog	replication.c	/^void feedReplicationBacklog(void *ptr, size_t len) {$/;"	f
feedReplicationBacklogWithObject	replication.c	/^void feedReplicationBacklogWithObject(robj *o) {$/;"	f
fetchClusterConfiguration	redis-benchmark.c	/^static int fetchClusterConfiguration() {$/;"	f	file:
fetchClusterSlotsConfiguration	redis-benchmark.c	/^static int fetchClusterSlotsConfiguration(client c) {$/;"	f	file:
field_buf	stream.h	/^    unsigned char field_buf[LP_INTBUF_SIZE];$/;"	m	struct:streamIterator
file	rio.h	/^        } file;$/;"	m	union:_rio::__anon37	typeref:struct:_rio::__anon37::__anon39
fill	quicklist.h	/^    int fill : QL_FILL_BITS;              \/* fill factor for individual nodes *\/$/;"	m	struct:quicklist
filters	module.c	/^    list *filters;  \/* List of filters the module has registered. *\/$/;"	m	struct:RedisModule	file:
finalizeResultEmission	t_zset.c	/^    zrangeResultFinalizeFunction         finalizeResultEmission;$/;"	m	struct:zrange_result_handler	file:
finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
findBigKeys	redis-cli.c	/^static void findBigKeys(int memkeys, unsigned memkeys_samples) {$/;"	f	file:
findHotKeys	redis-cli.c	/^static void findHotKeys(void) {$/;"	f	file:
findReplica	replication.c	/^static client *findReplica(char *host, int port) {$/;"	f	file:
fingerprint	dict.h	/^    long long fingerprint;$/;"	m	struct:dictIterator
fired	ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	struct:aeEventLoop
firstkey	server.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:redisCommand
fixed_time_expire	server.h	/^    long fixed_time_expire;     \/* If > 0, expire keys against server.mstime. *\/$/;"	m	struct:redisServer
flag	acl.c	/^    uint64_t flag;$/;"	m	struct:ACLCategoryItem	file:
flag	acl.c	/^    uint64_t flag;$/;"	m	struct:ACLUserFlag	file:
flag	cluster.c	/^    uint16_t flag;$/;"	m	struct:redisNodeFlags	file:
flagTransaction	multi.c	/^void flagTransaction(client *c) {$/;"	f
flags	ae.h	/^    int flags;$/;"	m	struct:aeEventLoop
flags	cluster.h	/^    int flags;      \/* CLUSTER_NODE_... *\/$/;"	m	struct:clusterNode
flags	cluster.h	/^    uint16_t flags;             \/* node->flags copy *\/$/;"	m	struct:__anon2
flags	cluster.h	/^    uint16_t flags;      \/* Sender node flags *\/$/;"	m	struct:__anon12
flags	config.c	/^    const unsigned int flags; \/* Flags for this specific config *\/$/;"	m	struct:standardConfig	file:
flags	connection.h	/^    short int flags;$/;"	m	struct:connection
flags	module.c	/^    int flags;                      \/* REDISMODULE_CTX_... flags. *\/$/;"	m	struct:RedisModuleCtx	file:
flags	module.c	/^    int flags;      \/* REDISMODULE_REPLYFLAG_...  *\/$/;"	m	struct:RedisModuleCallReply	file:
flags	module.c	/^    int flags;$/;"	m	struct:RedisModuleCommandFilter	file:
flags	module.c	/^    int flags;$/;"	m	struct:moduleClusterNodeInfo	file:
flags	rax.h	/^    int flags;$/;"	m	struct:raxIterator
flags	redis-benchmark.c	/^    int flags;$/;"	m	struct:clusterNode	file:
flags	redis-cli.c	/^    int flags;$/;"	m	struct:clusterManagerCommand	file:
flags	redis-cli.c	/^    int flags;$/;"	m	struct:clusterManagerNode	file:
flags	redismodule.h	/^    uint64_t flags;         \/* REDISMODULE_CLIENTINFO_FLAG_* *\/$/;"	m	struct:RedisModuleClientInfo
flags	rio.h	/^    uint64_t cksum, flags;$/;"	m	struct:_rio
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr16
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr32
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr64
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr8
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, and 5 msb of string length *\/$/;"	m	struct:sdshdr5
flags	sentinel.c	/^    int flags;              \/* Script job flags: SENTINEL_SCRIPT_* *\/$/;"	m	struct:sentinelScriptJob	file:
flags	sentinel.c	/^    int flags;      \/* See SRI_... defines *\/$/;"	m	struct:sentinelRedisInstance	file:
flags	server.h	/^    uint64_t flags;         \/* Client flags: CLIENT_* macros. *\/$/;"	m	struct:client
flags	server.h	/^    uint64_t flags; \/* See USER_FLAG_* *\/$/;"	m	struct:__anon45
flags	server.h	/^    uint64_t flags; \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	struct:redisCommand
flags	t_zset.c	/^    int flags;$/;"	m	struct:__anon67	file:
flags	tls.c	/^    int flags;$/;"	m	struct:tls_connection	file:
flags_str	redis-cli.c	/^    list *flags_str; \/* Flags string representations *\/$/;"	m	struct:clusterManagerNode	file:
flush	rio.h	/^    int (*flush)(struct _rio *);$/;"	m	struct:_rio
flushAllDataAndResetRDB	db.c	/^void flushAllDataAndResetRDB(int flags) {$/;"	f
flushAppendOnlyFile	aof.c	/^void flushAppendOnlyFile(int force) {$/;"	f
flushSlaveKeysWithExpireList	expire.c	/^void flushSlaveKeysWithExpireList(void) {$/;"	f
flushSlavesOutputBuffers	networking.c	/^void flushSlavesOutputBuffers(void) {$/;"	f
flushallCommand	db.c	/^void flushallCommand(client *c) {$/;"	f
flushdbCallback	modules/hellohook.c	/^void flushdbCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)$/;"	f
flushdbCommand	db.c	/^void flushdbCommand(client *c) {$/;"	f
fn	module.c	/^    RedisModuleScanCB fn;$/;"	m	struct:__anon32	file:
fn	module.c	/^    RedisModuleScanKeyCB fn;$/;"	m	struct:__anon33	file:
force	server.h	/^    *time, *pxat, *px, *retrycount, *force, *justid, $/;"	m	struct:sharedObjectsStruct
forceCommandPropagation	server.c	/^void forceCommandPropagation(client *c, int flags) {$/;"	f
force_cancel_loop	redis-cli.c	/^static volatile sig_atomic_t force_cancel_loop = 0;$/;"	v	file:
force_failover	server.h	/^    int force_failover; \/* If true then failover will be foreced at the$/;"	m	struct:redisServer
forked	scripting.c	/^    int forked; \/* Is this a fork()ed debugging session? *\/$/;"	m	struct:ldbState	file:
forward	server.h	/^        struct zskiplistNode *forward;$/;"	m	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode
fp	rio.h	/^            FILE *fp;$/;"	m	struct:_rio::__anon37::__anon39
fptr	server.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon53
free	adlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:list
free	aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:
free	redismodule.h	/^    RedisModuleTypeFreeFunc free;$/;"	m	struct:RedisModuleTypeMethods
free	server.h	/^    moduleTypeFreeFunc free;$/;"	m	struct:RedisModuleType
free	zmalloc.c	73;"	d	file:
free	zmalloc.c	78;"	d	file:
freeAllClients	redis-benchmark.c	/^static void freeAllClients(void) {$/;"	f	file:
freeBenchmarkThread	redis-benchmark.c	/^static void freeBenchmarkThread(benchmarkThread *thread) {$/;"	f	file:
freeBenchmarkThreads	redis-benchmark.c	/^static void freeBenchmarkThreads() {$/;"	f	file:
freeCallback	dict.c	/^void freeCallback(void *privdata, void *val) {$/;"	f
freeClient	networking.c	/^void freeClient(client *c) {$/;"	f
freeClient	redis-benchmark.c	/^static void freeClient(client c) {$/;"	f	file:
freeClientArgv	networking.c	/^static void freeClientArgv(client *c) {$/;"	f	file:
freeClientAsync	networking.c	/^void freeClientAsync(client *c) {$/;"	f
freeClientMultiState	multi.c	/^void freeClientMultiState(client *c) {$/;"	f
freeClientOriginalArgv	networking.c	/^void freeClientOriginalArgv(client *c) {$/;"	f
freeClientReplyValue	networking.c	/^void freeClientReplyValue(void *o) {$/;"	f
freeClientsInAsyncFreeQueue	networking.c	/^int freeClientsInAsyncFreeQueue(void) {$/;"	f
freeClusterLink	cluster.c	/^void freeClusterLink(clusterLink *link) {$/;"	f
freeClusterManager	redis-cli.c	/^static void freeClusterManager(void) {$/;"	f	file:
freeClusterManagerNode	redis-cli.c	/^static void freeClusterManagerNode(clusterManagerNode *node) {$/;"	f	file:
freeClusterManagerNodeFlags	redis-cli.c	/^static void freeClusterManagerNodeFlags(list *flags) {$/;"	f	file:
freeClusterNode	cluster.c	/^void freeClusterNode(clusterNode *n) {$/;"	f
freeClusterNode	redis-benchmark.c	/^static void freeClusterNode(clusterNode *node) {$/;"	f	file:
freeClusterNodes	redis-benchmark.c	/^static void freeClusterNodes() {$/;"	f	file:
freeFakeClient	aof.c	/^void freeFakeClient(struct client *c) {$/;"	f
freeFakeClientArgv	aof.c	/^void freeFakeClientArgv(struct client *c) {$/;"	f
freeHashObject	object.c	/^void freeHashObject(robj *o) {$/;"	f
freeHintsCallback	redis-cli.c	/^static void freeHintsCallback(void *ptr) {$/;"	f	file:
freeListObject	object.c	/^void freeListObject(robj *o) {$/;"	f
freeLuaScriptsAsync	lazyfree.c	/^void freeLuaScriptsAsync(dict *lua_scripts) {$/;"	f
freeMemoryGetNotCountedMemory	evict.c	/^size_t freeMemoryGetNotCountedMemory(void) {$/;"	f
freeMemoryOverheadData	object.c	/^void freeMemoryOverheadData(struct redisMemOverhead *mh) {$/;"	f
freeModuleObject	object.c	/^void freeModuleObject(robj *o) {$/;"	f
freeObjAsync	lazyfree.c	/^void freeObjAsync(robj *key, robj *obj) {$/;"	f
freeRedisConfig	redis-benchmark.c	/^static void freeRedisConfig(redisConfig *cfg) {$/;"	f	file:
freeReplicationBacklog	replication.c	/^void freeReplicationBacklog(void) {$/;"	f
freeSentinelConfig	sentinel.c	/^void freeSentinelConfig() {$/;"	f
freeSentinelLoadQueueEntry	sentinel.c	/^void freeSentinelLoadQueueEntry(void *item) {$/;"	f
freeSetObject	object.c	/^void freeSetObject(robj *o) {$/;"	f
freeSlotsToKeysMap	db.c	/^void freeSlotsToKeysMap(rax *rt, int async) {$/;"	f
freeSlotsToKeysMapAsync	lazyfree.c	/^void freeSlotsToKeysMapAsync(rax *rt) {$/;"	f
freeSparklineSequence	sparkline.c	/^void freeSparklineSequence(struct sequence *seq) {$/;"	f
freeStream	t_stream.c	/^void freeStream(stream *s) {$/;"	f
freeStreamObject	object.c	/^void freeStreamObject(robj *o) {$/;"	f
freeStringObject	object.c	/^void freeStringObject(robj *o) {$/;"	f
freeTrackingRadixTree	tracking.c	/^void freeTrackingRadixTree(rax *rt) {$/;"	f
freeTrackingRadixTreeAsync	lazyfree.c	/^void freeTrackingRadixTreeAsync(rax *tracking) {$/;"	f
freeTrackingRadixTreeCallback	tracking.c	/^void freeTrackingRadixTreeCallback(void *rt) {$/;"	f
freeZsetObject	object.c	/^void freeZsetObject(robj *o) {$/;"	f
free_args	bio.c	/^    void *free_args[]; \/* List of arguments to be passed to the free function *\/$/;"	m	struct:bio_job	file:
free_effort	redismodule.h	/^    RedisModuleTypeFreeEffortFunc free_effort;$/;"	m	struct:RedisModuleTypeMethods
free_effort	server.h	/^    moduleTypeFreeEffortFunc free_effort;$/;"	m	struct:RedisModuleType
free_fn	bio.c	/^    lazy_free_fn *free_fn; \/* Function that will free the provided arguments *\/$/;"	m	struct:bio_job	file:
free_privdata	module.c	/^    void (*free_privdata)(RedisModuleCtx*,void*);\/* privdata cleanup callback.*\/$/;"	m	struct:RedisModuleBlockedClient	file:
friends	redis-cli.c	/^    list *friends;$/;"	m	struct:clusterManagerNode	file:
from	redis-cli.c	/^    char *from;$/;"	m	struct:clusterManagerCommand	file:
from_askpass	redis-cli.c	/^    int from_askpass;$/;"	m	struct:clusterManagerCommand	file:
from_pass	redis-cli.c	/^    char *from_pass;$/;"	m	struct:clusterManagerCommand	file:
from_user	redis-cli.c	/^    char *from_user;$/;"	m	struct:clusterManagerCommand	file:
full	redis-cli.c	/^    sds full;$/;"	m	struct:__anon35	file:
func	module.c	/^    RedisModuleCmdFunc func;$/;"	m	struct:RedisModuleCommandProxy	file:
func	module.c	/^    void *func;$/;"	m	struct:RedisModuleSharedAPI	file:
genBenchmarkRandomData	redis-benchmark.c	/^static void genBenchmarkRandomData(char *data, int count) {$/;"	f	file:
genClientAddrString	networking.c	/^void genClientAddrString(client *client, char *addr,$/;"	f
genModulesInfoString	module.c	/^sds genModulesInfoString(sds info) {$/;"	f
genModulesInfoStringRenderModuleOptions	module.c	/^sds genModulesInfoStringRenderModuleOptions(struct RedisModule *module) {$/;"	f
genModulesInfoStringRenderModulesList	module.c	/^sds genModulesInfoStringRenderModulesList(list *l) {$/;"	f
genRedisInfoString	server.c	/^sds genRedisInfoString(const char *section) {$/;"	f
generateSkyline	lolwut6.c	/^void generateSkyline(lwCanvas *canvas) {$/;"	f
generateSkyscraper	lolwut6.c	/^void generateSkyscraper(lwCanvas *canvas, struct skyscraper *si) {$/;"	f
genericGetKeys	db.c	/^int genericGetKeys(int storeKeyOfs, int keyCountOfs, int firstKeyOfs, int keyStep,$/;"	f
genericHgetallCommand	t_hash.c	/^void genericHgetallCommand(client *c, int flags) {$/;"	f
genericSetKey	db.c	/^void genericSetKey(client *c, redisDb *db, robj *key, robj *val, int keepttl, int signal) {$/;"	f
genericZpopCommand	t_zset.c	/^void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg) {$/;"	f
genericZrangebylexCommand	t_zset.c	/^void genericZrangebylexCommand(zrange_result_handler *handler,$/;"	f
genericZrangebyrankCommand	t_zset.c	/^void genericZrangebyrankCommand(zrange_result_handler *handler,$/;"	f
genericZrangebyscoreCommand	t_zset.c	/^void genericZrangebyscoreCommand(zrange_result_handler *handler,$/;"	f
genrand64_int63	mt19937-64.c	/^long long genrand64_int63(void)$/;"	f
genrand64_int64	mt19937-64.c	/^unsigned long long genrand64_int64(void)$/;"	f
genrand64_real1	mt19937-64.c	/^double genrand64_real1(void)$/;"	f
genrand64_real2	mt19937-64.c	/^double genrand64_real2(void)$/;"	f
genrand64_real3	mt19937-64.c	/^double genrand64_real3(void)$/;"	f
genstr	quicklist.c	/^static char *genstr(char *prefix, int i) {$/;"	f	file:
geoAppendIfWithinShape	geo.c	/^int geoAppendIfWithinShape(geoArray *ga, GeoShape *shape, double score, sds member) {$/;"	f
geoArray	geo.h	/^typedef struct geoArray {$/;"	s
geoArray	geo.h	/^} geoArray;$/;"	t	typeref:struct:geoArray
geoArrayAppend	geo.c	/^geoPoint *geoArrayAppend(geoArray *ga) {$/;"	f
geoArrayCreate	geo.c	/^geoArray *geoArrayCreate(void) {$/;"	f
geoArrayFree	geo.c	/^void geoArrayFree(geoArray *ga) {$/;"	f
geoGetPointsInRange	geo.c	/^int geoGetPointsInRange(robj *zobj, double min, double max, GeoShape *shape, geoArray *ga, unsigned long limit) {$/;"	f
geoPoint	geo.h	/^typedef struct geoPoint {$/;"	s
geoPoint	geo.h	/^} geoPoint;$/;"	t	typeref:struct:geoPoint
geoaddCommand	geo.c	/^void geoaddCommand(client *c) {$/;"	f
geodistCommand	geo.c	/^void geodistCommand(client *c) {$/;"	f
geohashAlign52Bits	geohash_helper.c	/^GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {$/;"	f
geohashBoundingBox	geohash_helper.c	/^int geohashBoundingBox(GeoShape *shape, double *bounds) {$/;"	f
geohashCalculateAreasByShapeWGS84	geohash_helper.c	/^GeoHashRadius geohashCalculateAreasByShapeWGS84(GeoShape *shape) {$/;"	f
geohashCommand	geo.c	/^void geohashCommand(client *c) {$/;"	f
geohashDecode	geohash.c	/^int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,$/;"	f
geohashDecodeAreaToLongLat	geohash.c	/^int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {$/;"	f
geohashDecodeToLongLatType	geohash.c	/^int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {$/;"	f
geohashDecodeToLongLatWGS84	geohash.c	/^int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {$/;"	f
geohashDecodeType	geohash.c	/^int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {$/;"	f
geohashDecodeWGS84	geohash.c	/^int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {$/;"	f
geohashEncode	geohash.c	/^int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,$/;"	f
geohashEncodeType	geohash.c	/^int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {$/;"	f
geohashEncodeWGS84	geohash.c	/^int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,$/;"	f
geohashEstimateStepsByRadius	geohash_helper.c	/^uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {$/;"	f
geohashGetCoordRange	geohash.c	/^void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {$/;"	f
geohashGetDistance	geohash_helper.c	/^double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {$/;"	f
geohashGetDistanceIfInRadius	geohash_helper.c	/^int geohashGetDistanceIfInRadius(double x1, double y1,$/;"	f
geohashGetDistanceIfInRadiusWGS84	geohash_helper.c	/^int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,$/;"	f
geohashGetDistanceIfInRectangle	geohash_helper.c	/^int geohashGetDistanceIfInRectangle(double width_m, double height_m, double x1, double y1,$/;"	f
geohashNeighbors	geohash.c	/^void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {$/;"	f
geohash_move_x	geohash.c	/^static void geohash_move_x(GeoHashBits *hash, int8_t d) {$/;"	f	file:
geohash_move_y	geohash.c	/^static void geohash_move_y(GeoHashBits *hash, int8_t d) {$/;"	f	file:
geoposCommand	geo.c	/^void geoposCommand(client *c) {$/;"	f
georadiusCommand	geo.c	/^void georadiusCommand(client *c) {$/;"	f
georadiusGeneric	geo.c	/^void georadiusGeneric(client *c, int srcKeyIndex, int flags) {$/;"	f
georadiusGetKeys	db.c	/^int georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
georadiusbymemberCommand	geo.c	/^void georadiusbymemberCommand(client *c) {$/;"	f
georadiusbymemberroCommand	geo.c	/^void georadiusbymemberroCommand(client *c) {$/;"	f
georadiusroCommand	geo.c	/^void georadiusroCommand(client *c) {$/;"	f
geosearchCommand	geo.c	/^void geosearchCommand(client *c) {$/;"	f
geosearchstoreCommand	geo.c	/^void geosearchstoreCommand(client *c) {$/;"	f
get	config.c	/^    void (*get)(client *c, typeData data);$/;"	m	struct:typeInterface	file:
getAbsolutePath	util.c	/^sds getAbsolutePath(char *filename) {$/;"	f
getAllClientsInfoString	networking.c	/^sds getAllClientsInfoString(int type) {$/;"	f
getAllocatorFragmentation	defrag.c	/^float getAllocatorFragmentation(size_t *out_frag_bytes) {$/;"	f
getBitOffsetFromArgument	bitops.c	/^int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {$/;"	f
getBitfieldTypeFromArgument	bitops.c	/^int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {$/;"	f
getBlockedTypeByType	blocked.c	/^static int getBlockedTypeByType(int type) {$/;"	f	file:
getClientOutputBufferMemoryUsage	networking.c	/^unsigned long getClientOutputBufferMemoryUsage(client *c) {$/;"	f
getClientPeerId	networking.c	/^char *getClientPeerId(client *c) {$/;"	f
getClientSockname	networking.c	/^char *getClientSockname(client *c) {$/;"	f
getClientType	networking.c	/^int getClientType(client *c) {$/;"	f
getClientTypeByName	networking.c	/^int getClientTypeByName(char *name) {$/;"	f
getClientTypeName	networking.c	/^char *getClientTypeName(int class) {$/;"	f
getClientsMaxBuffers	networking.c	/^void getClientsMaxBuffers(unsigned long *longest_output_list,$/;"	f
getClusterConnectionsCount	cluster.c	/^unsigned long getClusterConnectionsCount(void) {$/;"	f
getClusterHostFromCmdArgs	redis-cli.c	/^static int getClusterHostFromCmdArgs(int argc, char **argv,$/;"	f	file:
getCommand	t_string.c	/^void getCommand(client *c) {$/;"	f
getDbSize	redis-cli.c	/^static int getDbSize(void) {$/;"	f	file:
getDecodedObject	object.c	/^robj *getDecodedObject(robj *o) {$/;"	f
getDotfilePath	redis-cli.c	/^static sds getDotfilePath(char *envoverride, char *dotfilename) {$/;"	f	file:
getDoubleFromObject	object.c	/^int getDoubleFromObject(const robj *o, double *target) {$/;"	f
getDoubleFromObjectOrReply	object.c	/^int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {$/;"	f
getExpansiveClientsInfo	server.c	/^void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {$/;"	f
getExpire	db.c	/^long long getExpire(redisDb *db, robj *key) {$/;"	f
getFailoverStateString	replication.c	/^const char *getFailoverStateString() {$/;"	f
getFlushCommandFlags	db.c	/^int getFlushCommandFlags(client *c, int *flags) {$/;"	f
getGenericCommand	t_string.c	/^int getGenericCommand(client *c) {$/;"	f
getIOPendingCount	networking.c	/^static inline unsigned long getIOPendingCount(int i) {$/;"	f	file:
getInfoField	redis-cli.c	/^static char *getInfoField(char *info, char *field) {$/;"	f	file:
getInstantaneousMetric	server.c	/^long long getInstantaneousMetric(int metric) {$/;"	f
getIntFromObjectOrReply	object.c	/^int getIntFromObjectOrReply(client *c, robj *o, int *target, const char *msg) {$/;"	f
getKeyFreqs	redis-cli.c	/^static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {$/;"	f	file:
getKeySizes	redis-cli.c	/^static void getKeySizes(redisReply *keys, typeinfo **types,$/;"	f	file:
getKeyTypes	redis-cli.c	/^static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {$/;"	f	file:
getKeysFreeResult	db.c	/^void getKeysFreeResult(getKeysResult *result) {$/;"	f
getKeysFromCommand	db.c	/^int getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
getKeysInSlot	db.c	/^unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {$/;"	f
getKeysPrepareResult	db.c	/^int *getKeysPrepareResult(getKeysResult *result, int numkeys) {$/;"	f
getKeysResult	server.h	/^} getKeysResult;$/;"	t	typeref:struct:__anon48
getKeysUsingCommandTable	db.c	/^int getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, getKeysResult *result) {$/;"	f
getLRUClock	evict.c	/^unsigned int getLRUClock(void) {$/;"	f
getListPositionFromObjectOrReply	t_list.c	/^int getListPositionFromObjectOrReply(client *c, robj *arg, int *position) {$/;"	f
getLongDoubleFromObject	object.c	/^int getLongDoubleFromObject(robj *o, long double *target) {$/;"	f
getLongDoubleFromObjectOrReply	object.c	/^int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {$/;"	f
getLongFromObjectOrReply	object.c	/^int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {$/;"	f
getLongInfoField	redis-cli.c	/^static long getLongInfoField(char *info, char *field) {$/;"	f	file:
getLongLongFromObject	object.c	/^int getLongLongFromObject(robj *o, long long *target) {$/;"	f
getLongLongFromObjectOrReply	object.c	/^int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {$/;"	f
getMaxmemoryState	evict.c	/^int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {$/;"	f
getMcontextEip	debug.c	/^static void *getMcontextEip(ucontext_t *uc) {$/;"	f	file:
getMemoryDoctorReport	object.c	/^sds getMemoryDoctorReport(void) {$/;"	f
getMemoryOverheadData	object.c	/^struct redisMemOverhead *getMemoryOverheadData(void) {$/;"	f
getMonotonicUs	monotonic.c	/^monotime (*getMonotonicUs)(void) = NULL;$/;"	v
getMonotonicUs_aarch64	monotonic.c	/^static monotime getMonotonicUs_aarch64() {$/;"	f	file:
getMonotonicUs_posix	monotonic.c	/^static monotime getMonotonicUs_posix() {$/;"	f	file:
getMonotonicUs_x86	monotonic.c	/^static monotime getMonotonicUs_x86() {$/;"	f	file:
getNodeByQuery	cluster.c	/^clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {$/;"	f
getObjectReadOnlyString	bitops.c	/^unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {$/;"	f
getObjectTypeName	db.c	/^char* getObjectTypeName(robj *o) {$/;"	f
getPositiveLongFromObjectOrReply	object.c	/^int getPositiveLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {$/;"	f
getPsyncInitialOffset	replication.c	/^long long getPsyncInitialOffset(void) {$/;"	f
getRDB	redis-cli.c	/^static void getRDB(clusterManagerNode *node) {$/;"	f	file:
getRandomBytes	util.c	/^void getRandomBytes(unsigned char *p, size_t len) {$/;"	f
getRandomHexChars	util.c	/^void getRandomHexChars(char *p, size_t len) {$/;"	f
getRangeLongFromObjectOrReply	object.c	/^int getRangeLongFromObjectOrReply(client *c, robj *o, long min, long max, long *target, const char *msg) {$/;"	f
getRedisConfig	redis-benchmark.c	/^static redisConfig *getRedisConfig(const char *ip, int port,$/;"	f	file:
getRedisContext	redis-benchmark.c	/^static redisContext *getRedisContext(const char *ip, int port,$/;"	f	file:
getSafeInfoString	server.c	/^const char *getSafeInfoString(const char *s, size_t len, char **tmp) {$/;"	f
getSdsArrayFromArgv	redis-cli.c	/^static sds *getSdsArrayFromArgv(int argc, char **argv, int quoted) {$/;"	f	file:
getSentinelRedisInstanceByAddrAndRunID	sentinel.c	/^sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *addr, int port, char *runid) {$/;"	f
getSignedBitfield	bitops.c	/^int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {$/;"	f
getSlaveKeyWithExpireCount	expire.c	/^size_t getSlaveKeyWithExpireCount(void) {$/;"	f
getSlotOrReply	cluster.c	/^int getSlotOrReply(client *c, robj *o) {$/;"	f
getStringObjectFromListPosition	t_list.c	/^robj *getStringObjectFromListPosition(int position) {$/;"	f
getStringObjectLen	networking.c	/^size_t getStringObjectLen(robj *o) {$/;"	f
getStringObjectSdsUsedMemory	networking.c	/^size_t getStringObjectSdsUsedMemory(robj *o) {$/;"	f
getTestProcByName	server.c	/^redisTestProc *getTestProcByName(const char *name) {$/;"	f
getTimeZone	util.c	/^long getTimeZone(void) {$/;"	f
getTimeoutFromObjectOrReply	timeout.c	/^int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {$/;"	f
getUnsignedBitfield	bitops.c	/^uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {$/;"	f
get_ack_from_slaves	server.h	/^    int get_ack_from_slaves;            \/* If true we send REPLCONF GETACK. *\/$/;"	m	struct:redisServer
get_last_error	connection.h	/^    const char *(*get_last_error)(struct connection *conn);$/;"	m	struct:ConnectionType
get_section_heading	modules/gendoc.rb	/^def get_section_heading(src, i)$/;"	f
get_type	connection.h	/^    int (*get_type)(struct connection *conn);$/;"	m	struct:ConnectionType
getack	server.h	/^    *getack, *special_asterick, *special_equals, *default_username,$/;"	m	struct:sharedObjectsStruct
getapifuncptr	module.c	/^    void *getapifuncptr;            \/* NOTE: Must be the first field. *\/$/;"	m	struct:RedisModuleCtx	file:
getbitCommand	bitops.c	/^void getbitCommand(client *c) {$/;"	f
getdelCommand	t_string.c	/^void getdelCommand(client *c) {$/;"	f
getexCommand	t_string.c	/^void getexCommand(client *c) {$/;"	f
getkeys_proc	server.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	struct:redisCommand
getrangeCommand	t_string.c	/^void getrangeCommand(client *c) {$/;"	f
getrdb_mode	redis-cli.c	/^    int getrdb_mode;$/;"	m	struct:config	file:
getsetCommand	t_string.c	/^void getsetCommand(client *c) {$/;"	f
global	modules/helloacl.c	/^static RedisModuleUser *global;$/;"	v	file:
global_auth_client_id	modules/helloacl.c	/^static uint64_t global_auth_client_id = 0;$/;"	v	file:
gopher_enabled	server.h	/^    int gopher_enabled;         \/* If true the server will reply to gopher$/;"	m	struct:redisServer
gossip	cluster.h	/^        clusterMsgDataGossip gossip[1];$/;"	m	struct:clusterMsgData::__anon7
group	help.h	/^  int group;$/;"	m	struct:commandHelp
groupname	stream.h	/^    robj *groupname;$/;"	m	struct:streamPropInfo
handle	module.c	/^    void *handle;   \/* Module dlopen() handle. *\/$/;"	m	struct:RedisModule	file:
handleBlockedClientsTimeout	timeout.c	/^void handleBlockedClientsTimeout(void) {$/;"	f
handleClientsBlockedOnKeys	blocked.c	/^void handleClientsBlockedOnKeys(void) {$/;"	f
handleClientsWithPendingReadsUsingThreads	networking.c	/^int handleClientsWithPendingReadsUsingThreads(void) {$/;"	f
handleClientsWithPendingWrites	networking.c	/^int handleClientsWithPendingWrites(void) {$/;"	f
handleClientsWithPendingWritesUsingThreads	networking.c	/^int handleClientsWithPendingWritesUsingThreads(void) {$/;"	f
handleLinkIOError	cluster.c	/^void handleLinkIOError(clusterLink *link) {$/;"	f
handleSSLReturnCode	tls.c	/^static int handleSSLReturnCode(tls_connection *conn, int ret_value, WantIOType *want) {$/;"	f	file:
handshaking	redis-cli.c	/^    int handshaking;$/;"	m	struct:clusterManagerLink	file:
hard_limit_bytes	server.h	/^    unsigned long long hard_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig
harndfieldReplyWithZiplist	t_hash.c	/^static void harndfieldReplyWithZiplist(client *c, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {$/;"	f	file:
hasActiveChildProcess	server.c	/^int hasActiveChildProcess() {$/;"	f
hash	geohash.h	/^    GeoHashBits hash;$/;"	m	struct:__anon22
hash	geohash_helper.h	/^    GeoHashBits hash;$/;"	m	struct:__anon27
hashCallback	dict.c	/^uint64_t hashCallback(const void *key) {$/;"	f
hashDictType	server.c	/^dictType hashDictType = {$/;"	v
hashFunction	dict.h	/^    uint64_t (*hashFunction)(const void *key);$/;"	m	struct:dictType
hashReplyFromZiplistEntry	t_hash.c	/^void hashReplyFromZiplistEntry(client *c, ziplistEntry *e) {$/;"	f
hashSdsFromZiplistEntry	t_hash.c	/^sds hashSdsFromZiplistEntry(ziplistEntry *e) {$/;"	f
hashTypeConvert	t_hash.c	/^void hashTypeConvert(robj *o, int enc) {$/;"	f
hashTypeConvertZiplist	t_hash.c	/^void hashTypeConvertZiplist(robj *o, int enc) {$/;"	f
hashTypeCurrentFromHashTable	t_hash.c	/^sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {$/;"	f
hashTypeCurrentFromZiplist	t_hash.c	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	f
hashTypeCurrentObject	t_hash.c	/^void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {$/;"	f
hashTypeCurrentObjectNewSds	t_hash.c	/^sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {$/;"	f
hashTypeDelete	t_hash.c	/^int hashTypeDelete(robj *o, sds field) {$/;"	f
hashTypeDup	t_hash.c	/^robj *hashTypeDup(robj *o) {$/;"	f
hashTypeExists	t_hash.c	/^int hashTypeExists(robj *o, sds field) {$/;"	f
hashTypeGetFromHashTable	t_hash.c	/^sds hashTypeGetFromHashTable(robj *o, sds field) {$/;"	f
hashTypeGetFromZiplist	t_hash.c	/^int hashTypeGetFromZiplist(robj *o, sds field,$/;"	f
hashTypeGetValue	t_hash.c	/^int hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {$/;"	f
hashTypeGetValueLength	t_hash.c	/^size_t hashTypeGetValueLength(robj *o, sds field) {$/;"	f
hashTypeGetValueObject	t_hash.c	/^robj *hashTypeGetValueObject(robj *o, sds field) {$/;"	f
hashTypeInitIterator	t_hash.c	/^hashTypeIterator *hashTypeInitIterator(robj *subject) {$/;"	f
hashTypeIterator	server.h	/^} hashTypeIterator;$/;"	t	typeref:struct:__anon53
hashTypeLength	t_hash.c	/^unsigned long hashTypeLength(const robj *o) {$/;"	f
hashTypeLookupWriteOrCreate	t_hash.c	/^robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {$/;"	f
hashTypeNext	t_hash.c	/^int hashTypeNext(hashTypeIterator *hi) {$/;"	f
hashTypeRandomElement	t_hash.c	/^void hashTypeRandomElement(robj *hashobj, unsigned long hashsize, ziplistEntry *key, ziplistEntry *val) {$/;"	f
hashTypeReleaseIterator	t_hash.c	/^void hashTypeReleaseIterator(hashTypeIterator *hi) {$/;"	f
hashTypeSet	t_hash.c	/^int hashTypeSet(robj *o, sds field, sds value, int flags) {$/;"	f
hashTypeTryConversion	t_hash.c	/^void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {$/;"	f
hashZiplistValidateIntegrity	t_hash.c	/^int hashZiplistValidateIntegrity(unsigned char *zl, size_t size, int deep) {$/;"	f
hash_max_ziplist_entries	server.h	/^    size_t hash_max_ziplist_entries;$/;"	m	struct:redisServer
hash_max_ziplist_value	server.h	/^    size_t hash_max_ziplist_value;$/;"	m	struct:redisServer
hdelCommand	t_hash.c	/^void hdelCommand(client *c) {$/;"	f
head	adlist.h	/^    listNode *head;$/;"	m	struct:list
head	modules/hellotype.c	/^    struct HelloTypeNode *head;$/;"	m	struct:HelloTypeObject	typeref:struct:HelloTypeObject::HelloTypeNode	file:
head	quicklist.h	/^    quicklistNode *head;$/;"	m	struct:quicklist
head	rax.h	/^    raxNode *head;$/;"	m	struct:rax
header	server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode
headersize	ziplist.c	/^    unsigned int headersize;     \/* prevrawlensize + lensize. *\/$/;"	m	struct:zlentry	file:
height	geohash.h	/^            double height;$/;"	m	struct:__anon24::__anon25::__anon26
height	lolwut.h	/^    int height;$/;"	m	struct:lwCanvas
height	lolwut6.c	/^    int height;     \/* Pixels height. *\/$/;"	m	struct:skyscraper	file:
helloCommand	networking.c	/^void helloCommand(client *c) {$/;"	f
helpEntries	redis-cli.c	/^static helpEntry *helpEntries;$/;"	v	file:
helpEntriesLen	redis-cli.c	/^static int helpEntriesLen;$/;"	v	file:
helpEntry	redis-cli.c	/^} helpEntry;$/;"	t	typeref:struct:__anon35	file:
hex_digit_to_int	sds.c	/^int hex_digit_to_int(char c) {$/;"	f
hexistsCommand	t_hash.c	/^void hexistsCommand(client *c) {$/;"	f
hgetCommand	t_hash.c	/^void hgetCommand(client *c) {$/;"	f
hgetallCommand	t_hash.c	/^void hgetallCommand(client *c) {$/;"	f
hincrbyCommand	t_hash.c	/^void hincrbyCommand(client *c) {$/;"	f
hincrbyfloatCommand	t_hash.c	/^void hincrbyfloatCommand(client *c) {$/;"	f
hints	redis-cli.c	/^    int hints;$/;"	m	struct:pref	file:
hintsCallback	redis-cli.c	/^static char *hintsCallback(const char *buf, int *color, int *bold) {$/;"	f	file:
hkeysCommand	t_hash.c	/^void hkeysCommand(client *c) {$/;"	f
hlenCommand	t_hash.c	/^void hlenCommand(client *c) {$/;"	f
hllAdd	hyperloglog.c	/^int hllAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f
hllCount	hyperloglog.c	/^uint64_t hllCount(struct hllhdr *hdr, int *invalid) {$/;"	f
hllDenseAdd	hyperloglog.c	/^int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {$/;"	f
hllDenseRegHisto	hyperloglog.c	/^void hllDenseRegHisto(uint8_t *registers, int* reghisto) {$/;"	f
hllDenseSet	hyperloglog.c	/^int hllDenseSet(uint8_t *registers, long index, uint8_t count) {$/;"	f
hllMerge	hyperloglog.c	/^int hllMerge(uint8_t *max, robj *hll) {$/;"	f
hllPatLen	hyperloglog.c	/^int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {$/;"	f
hllRawRegHisto	hyperloglog.c	/^void hllRawRegHisto(uint8_t *registers, int* reghisto) {$/;"	f
hllSigma	hyperloglog.c	/^double hllSigma(double x) {$/;"	f
hllSparseAdd	hyperloglog.c	/^int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f
hllSparseRegHisto	hyperloglog.c	/^void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto) {$/;"	f
hllSparseSet	hyperloglog.c	/^int hllSparseSet(robj *o, long index, uint8_t count) {$/;"	f
hllSparseToDense	hyperloglog.c	/^int hllSparseToDense(robj *o) {$/;"	f
hllTau	hyperloglog.c	/^double hllTau(double x) {$/;"	f
hll_sparse_max_bytes	server.h	/^    size_t hll_sparse_max_bytes;$/;"	m	struct:redisServer
hllhdr	hyperloglog.c	/^struct hllhdr {$/;"	s	file:
hmgetCommand	t_hash.c	/^void hmgetCommand(client *c) {$/;"	f
hostip	redis-benchmark.c	/^    const char *hostip;$/;"	m	struct:config	file:
hostip	redis-cli.c	/^    char *hostip;$/;"	m	struct:config	file:
hostname	sentinel.c	/^    char *hostname;         \/* Hostname OR address, as specified *\/$/;"	m	struct:sentinelAddr	file:
hostport	redis-benchmark.c	/^    int hostport;$/;"	m	struct:config	file:
hostport	redis-cli.c	/^    int hostport;$/;"	m	struct:config	file:
hostsocket	redis-benchmark.c	/^    const char *hostsocket;$/;"	m	struct:config	file:
hostsocket	redis-cli.c	/^    char *hostsocket;$/;"	m	struct:config	file:
hotkeys	redis-cli.c	/^    int hotkeys;$/;"	m	struct:config	file:
hrandfieldCommand	t_hash.c	/^void hrandfieldCommand(client *c) {$/;"	f
hrandfieldWithCountCommand	t_hash.c	/^void hrandfieldWithCountCommand(client *c, long l, int withvalues) {$/;"	f
hscanCommand	t_hash.c	/^void hscanCommand(client *c) {$/;"	f
hset	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
hsetCommand	t_hash.c	/^void hsetCommand(client *c) {$/;"	f
hsetnxCommand	t_hash.c	/^void hsetnxCommand(client *c) {$/;"	f
hstrlenCommand	t_hash.c	/^void hstrlenCommand(client *c) {$/;"	f
ht	dict.h	/^    dictht ht[2];$/;"	m	struct:dict
ht	t_zset.c	/^            } ht;$/;"	m	union:__anon61::__anon62::_iterset	typeref:struct:__anon61::__anon62::_iterset::__anon64	file:
htNeedsResize	server.c	/^int htNeedsResize(dict *dict) {$/;"	f
htonu64	endianconv.h	67;"	d
htonu64	endianconv.h	70;"	d
hvalsCommand	t_hash.c	/^void hvalsCommand(client *c) {$/;"	f
hz	redismodule.h	/^    int32_t hz;             \/* Approximate number of events per second. *\/$/;"	m	struct:RedisModuleCronLoopInfo
hz	redismodule.h	/^    int32_t hz;             \/* Approximate number of events per second. *\/$/;"	m	struct:RedisModuleLoadingProgressInfo
hz	server.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	struct:redisServer
hz	server.h	1149;"	d
i	config.c	/^        int *i;$/;"	m	union:numericConfigData::__anon14	file:
i64	bitops.c	/^    int64_t i64;        \/* Increment amount (INCRBY) or SET value *\/$/;"	m	struct:bitfieldOp	file:
iAmMaster	server.c	/^int iAmMaster(void) {$/;"	f
id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
id	redismodule.h	/^    uint64_t id;            \/* Client ID. *\/$/;"	m	struct:RedisModuleClientInfo
id	redismodule.h	/^    uint64_t id;        \/* REDISMODULE_EVENT_... defines. *\/$/;"	m	struct:RedisModuleEvent
id	server.h	/^    int id;                     \/* Database ID *\/$/;"	m	struct:redisDb
id	server.h	/^    int id;     \/* Command ID. This is a progressive ID starting from 0 that$/;"	m	struct:redisCommand
id	server.h	/^    uint64_t id;            \/* Client incremental unique ID. *\/$/;"	m	struct:client
id	server.h	/^    uint64_t id; \/* Higher 54 bits of type ID + 10 lower bits of encoding ver. *\/$/;"	m	struct:RedisModuleType
id	slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	struct:slowlogEntry
id	t_stream.c	/^    streamID id; \/* User-provided ID, for XADD only. *\/$/;"	m	struct:__anon59	file:
id_given	t_stream.c	/^    int id_given; \/* Was an ID different than "*" specified? for XADD only. *\/$/;"	m	struct:__anon59	file:
idle	evict.c	/^    unsigned long long idle;    \/* Object idle time (inverse frequency for LFU) *\/$/;"	m	struct:evictionPoolEntry	file:
idlemode	redis-benchmark.c	/^    int idlemode;$/;"	m	struct:config	file:
idx	latency.h	/^    int idx; \/* Index of the next sample to store. *\/$/;"	m	struct:latencyTimeSeries
idx	server.h	/^        int idx;$/;"	m	struct:redisServer::__anon47
ignore_warnings	server.h	/^    char *ignore_warnings;      \/* Config: warnings that should be ignored. *\/$/;"	m	struct:redisServer
ii	server.h	/^    int ii; \/* intset iterator *\/$/;"	m	struct:__anon52
ii	t_zset.c	/^                int ii;$/;"	m	struct:__anon61::__anon62::_iterset::__anon63	file:
importing	redis-benchmark.c	/^    sds *importing; \/* An array of sds where even strings are slots and odd$/;"	m	struct:clusterNode	file:
importing	redis-cli.c	/^    sds *importing; \/* An array of sds where even strings are slots and odd$/;"	m	struct:clusterManagerNode	file:
importing_count	redis-benchmark.c	/^    int importing_count; \/* Length of the importing array (importing slots*2) *\/$/;"	m	struct:clusterNode	file:
importing_count	redis-cli.c	/^    int importing_count; \/* Length of the importing array (importing slots*2) *\/$/;"	m	struct:clusterManagerNode	file:
importing_slots_from	cluster.h	/^    clusterNode *importing_slots_from[CLUSTER_SLOTS];$/;"	m	struct:clusterState
in_call	module.c	/^    int in_call;    \/* RM_Call() nesting level *\/$/;"	m	struct:RedisModule	file:
in_dict_field	module.c	/^    int in_dict_field;  \/* indication that we're currently appending to a dict *\/$/;"	m	struct:RedisModuleInfoCtx	file:
in_eval	server.h	/^    int in_eval;                \/* Are we inside EVAL? *\/$/;"	m	struct:redisServer
in_exec	server.h	/^    int in_exec;                \/* Are we inside EXEC? *\/$/;"	m	struct:redisServer
in_fork_child	server.h	/^    int in_fork_child;          \/* indication that this is a fork child *\/$/;"	m	struct:redisServer
in_hook	module.c	/^    int in_hook;    \/* Hooks callback nesting level for this module (0 or 1). *\/$/;"	m	struct:RedisModule	file:
in_multi	redis-cli.c	/^    int in_multi;$/;"	m	struct:config	file:
in_section	module.c	/^    int in_section;     \/* indication if we're in an active section or not *\/$/;"	m	struct:RedisModuleInfoCtx	file:
incrCommand	t_string.c	/^void incrCommand(client *c) {$/;"	f
incrDecrCommand	t_string.c	/^void incrDecrCommand(client *c, long long incr) {$/;"	f
incrRefCount	object.c	/^void incrRefCount(robj *o) {$/;"	f
incrbyCommand	t_string.c	/^void incrbyCommand(client *c) {$/;"	f
incrbyfloatCommand	t_string.c	/^void incrbyfloatCommand(client *c) {$/;"	f
incrementErrorCount	server.c	/^void incrementErrorCount(const char *fullerr, size_t namelen) {$/;"	f
incrementallyRehash	server.c	/^int incrementallyRehash(int dbid) {$/;"	f
index	dict.h	/^    long index;$/;"	m	struct:dictIterator
index	redis-benchmark.c	/^    int index;$/;"	m	struct:benchmarkThread	file:
info	module.c	/^    sds info;           \/* info string we collected so far *\/$/;"	m	struct:RedisModuleInfoCtx	file:
info	sentinel.c	/^    sds info; \/* cached INFO output *\/$/;"	m	struct:sentinelRedisInstance	file:
infoCommand	server.c	/^void infoCommand(client *c) {$/;"	f
info_cb	module.c	/^    RedisModuleInfoFunc info_cb; \/* Callback for module to add INFO fields. *\/$/;"	m	struct:RedisModule	file:
info_refresh	sentinel.c	/^    mstime_t info_refresh;  \/* Time at which we received INFO output from it. *\/$/;"	m	struct:sentinelRedisInstance	file:
info_section_from_redis	sentinel.c	3893;"	d	file:
information_type	childinfo.c	/^    childInfoType information_type; \/* Type of information *\/$/;"	m	struct:__anon1	file:
init	config.c	/^    void (*init)(typeData data);$/;"	m	struct:typeInterface	file:
initBenchmarkThreads	redis-benchmark.c	/^static void initBenchmarkThreads() {$/;"	f	file:
initClientMultiState	multi.c	/^void initClientMultiState(client *c) {$/;"	f
initConfigValues	config.c	/^void initConfigValues() {$/;"	f
initCryptoLocks	tls.c	/^static void initCryptoLocks(void) {$/;"	f	file:
initEntry	quicklist.c	82;"	d	file:
initSentinel	sentinel.c	/^void initSentinel(void) {$/;"	f
initSentinelConfig	sentinel.c	/^void initSentinelConfig(void) {$/;"	f
initServer	server.c	/^void initServer(void) {$/;"	f
initServerConfig	server.c	/^void initServerConfig(void) {$/;"	f
initStaticStringObject	server.h	693;"	d
initThreadedIO	networking.c	/^void initThreadedIO(void) {$/;"	f
init_by_array64	mt19937-64.c	/^void init_by_array64(unsigned long long init_key[],$/;"	f
init_genrand64	mt19937-64.c	/^void init_genrand64(unsigned long long seed)$/;"	f
initial_memory_usage	server.h	/^    size_t initial_memory_usage; \/* Bytes used after initialization. *\/$/;"	m	struct:redisServer
initializeSentinelConfig	sentinel.c	/^void initializeSentinelConfig() {$/;"	f
inline	lzf_c.c	80;"	d	file:
inline	lzf_c.c	83;"	d	file:
inputCatSds	object.c	/^void inputCatSds(void *result, const char *str) {$/;"	f
insertHelper	ziplist.c	/^static unsigned char *insertHelper(unsigned char *zl, char ch, size_t len, unsigned char *pos) {$/;"	f	file:
inst_metric	server.h	/^    } inst_metric[STATS_METRIC_COUNT];$/;"	m	struct:redisServer	typeref:struct:redisServer::__anon47
instanceLink	sentinel.c	/^typedef struct instanceLink {$/;"	s	file:
instanceLink	sentinel.c	/^} instanceLink;$/;"	t	typeref:struct:instanceLink	file:
instanceLinkCloseConnection	sentinel.c	/^void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {$/;"	f
instanceLinkConnectionError	sentinel.c	/^void instanceLinkConnectionError(const redisAsyncContext *c) {$/;"	f
instanceLinkNegotiateTLS	sentinel.c	/^static int instanceLinkNegotiateTLS(redisAsyncContext *context) {$/;"	f	file:
instancesDictType	sentinel.c	/^dictType instancesDictType = {$/;"	v
integers	server.h	/^    *integers[OBJ_SHARED_INTEGERS],$/;"	m	struct:sharedObjectsStruct
interactive	redis-cli.c	/^    int interactive;$/;"	m	struct:config	file:
interface	config.c	/^    typeInterface interface; \/* The function pointers that define the type interface *\/$/;"	m	struct:standardConfig	file:
interleave64	geohash.c	/^static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {$/;"	f	file:
interval	redis-cli.c	/^    long interval;$/;"	m	struct:config	file:
intrev16	endianconv.c	/^uint16_t intrev16(uint16_t v) {$/;"	f
intrev16ifbe	endianconv.h	52;"	d
intrev16ifbe	endianconv.h	59;"	d
intrev32	endianconv.c	/^uint32_t intrev32(uint32_t v) {$/;"	f
intrev32ifbe	endianconv.h	53;"	d
intrev32ifbe	endianconv.h	60;"	d
intrev64	endianconv.c	/^uint64_t intrev64(uint64_t v) {$/;"	f
intrev64ifbe	endianconv.h	54;"	d
intrev64ifbe	endianconv.h	61;"	d
intrinsicLatencyMode	redis-cli.c	/^static void intrinsicLatencyMode(void) {$/;"	f	file:
intrinsicLatencyModeStop	redis-cli.c	/^static void intrinsicLatencyModeStop(int s) {$/;"	f	file:
intrinsic_latency_duration	redis-cli.c	/^    int intrinsic_latency_duration;$/;"	m	struct:config	file:
intrinsic_latency_mode	redis-cli.c	/^    int intrinsic_latency_mode;$/;"	m	struct:config	file:
intset	intset.h	/^typedef struct intset {$/;"	s
intset	intset.h	/^} intset;$/;"	t	typeref:struct:intset
intsetAdd	intset.c	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {$/;"	f
intsetBlobLen	intset.c	/^size_t intsetBlobLen(intset *is) {$/;"	f
intsetFind	intset.c	/^uint8_t intsetFind(intset *is, int64_t value) {$/;"	f
intsetGet	intset.c	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {$/;"	f
intsetLen	intset.c	/^uint32_t intsetLen(const intset *is) {$/;"	f
intsetMoveTail	intset.c	/^static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {$/;"	f	file:
intsetNew	intset.c	/^intset *intsetNew(void) {$/;"	f
intsetRandom	intset.c	/^int64_t intsetRandom(intset *is) {$/;"	f
intsetRemove	intset.c	/^intset *intsetRemove(intset *is, int64_t value, int *success) {$/;"	f
intsetResize	intset.c	/^static intset *intsetResize(intset *is, uint32_t len) {$/;"	f	file:
intsetSearch	intset.c	/^static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {$/;"	f	file:
intsetTest	intset.c	/^int intsetTest(int argc, char **argv, int accurate) {$/;"	f
intsetUpgradeAndAdd	intset.c	/^static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {$/;"	f	file:
intsetValidateIntegrity	intset.c	/^int intsetValidateIntegrity(const unsigned char *p, size_t size, int deep) {$/;"	f
invalid_hll_err	hyperloglog.c	/^static char *invalid_hll_err = "-INVALIDOBJ Corrupted HLL object detected";$/;"	v	file:
io	rio.h	/^    } io;$/;"	m	struct:_rio	typeref:union:_rio::__anon37
io_threads	networking.c	/^pthread_t io_threads[IO_THREADS_MAX_NUM];$/;"	v
io_threads_active	server.h	/^    int io_threads_active;      \/* Is IO threads currently active? *\/$/;"	m	struct:redisServer
io_threads_do_reads	server.h	/^    int io_threads_do_reads;    \/* Read and parse from IO threads? *\/$/;"	m	struct:redisServer
io_threads_list	networking.c	/^list *io_threads_list[IO_THREADS_MAX_NUM];$/;"	v
io_threads_mutex	networking.c	/^pthread_mutex_t io_threads_mutex[IO_THREADS_MAX_NUM];$/;"	v
io_threads_num	server.h	/^    int io_threads_num;         \/* Number of IO threads to use. *\/$/;"	m	struct:redisServer
io_threads_op	networking.c	/^int io_threads_op;      \/* IO_THREADS_OP_WRITE or IO_THREADS_OP_READ. *\/$/;"	v
io_threads_pending	networking.c	/^redisAtomic unsigned long io_threads_pending[IO_THREADS_MAX_NUM];$/;"	v
ip	cluster.h	/^    char ip[NET_IP_STR_LEN];  \/* IP address last time it was seen *\/$/;"	m	struct:__anon2
ip	cluster.h	/^    char ip[NET_IP_STR_LEN];  \/* Latest known IP address of this node *\/$/;"	m	struct:clusterNode
ip	module.c	/^    char ip[NET_IP_STR_LEN];$/;"	m	struct:moduleClusterNodeInfo	file:
ip	redis-benchmark.c	/^    char *ip;$/;"	m	struct:clusterNode	file:
ip	redis-cli.c	/^    char *ip;$/;"	m	struct:clusterManagerNode	file:
ip	sentinel.c	/^    char *ip;               \/* Always a resolved address *\/$/;"	m	struct:sentinelAddr	file:
ip_len	anet.h	49;"	d
ipfd	server.h	/^    socketFds ipfd;             \/* TCP socket file descriptors *\/$/;"	m	struct:redisServer
is	t_zset.c	/^                intset *is;$/;"	m	struct:__anon61::__anon62::_iterset::__anon63	file:
is	t_zset.c	/^            } is;$/;"	m	union:__anon61::__anon62::_iterset	typeref:struct:__anon61::__anon62::_iterset::__anon63	file:
isColorTerm	redis-cli.c	/^int isColorTerm(void) {$/;"	f
isEvictionProcRunning	evict.c	/^static int isEvictionProcRunning = 0;$/;"	v	file:
isHLLObjectOrReply	hyperloglog.c	/^int isHLLObjectOrReply(client *c, robj *o) {$/;"	f
isHexChar	redis-cli.c	356;"	d	file:
isInvalidateReply	redis-cli.c	/^static int isInvalidateReply(redisReply *reply) {$/;"	f	file:
isMutuallyExclusiveChildType	server.c	/^int isMutuallyExclusiveChildType(int type) {$/;"	f
isObjectRepresentableAsLongLong	object.c	/^int isObjectRepresentableAsLongLong(robj *o, long long *llval) {$/;"	f
isSafeToPerformEvictions	evict.c	/^static int isSafeToPerformEvictions(void) {$/;"	f	file:
isSdsRepresentableAsLongLong	object.c	/^int isSdsRepresentableAsLongLong(sds s, long long *llval) {$/;"	f
isValidAOFfilename	config.c	/^static int isValidAOFfilename(char *val, const char **err) {$/;"	f	file:
isValidDBfilename	config.c	/^static int isValidDBfilename(char *val, const char **err) {$/;"	f	file:
isValidProcTitleTemplate	config.c	/^static int isValidProcTitleTemplate(char *val, const char **err) {$/;"	f	file:
is_fetching_slots	redis-benchmark.c	/^    redisAtomic int is_fetching_slots;$/;"	m	struct:config	file:
is_func_line	modules/gendoc.rb	/^def is_func_line(src, i)$/;"	f
is_hex_digit	sds.c	/^int is_hex_digit(char c) {$/;"	f
is_leap_year	localtime.c	/^static int is_leap_year(time_t year) {$/;"	f	file:
is_memory	config.c	/^    int is_memory; \/* Indicates if this value can be loaded as a memory value *\/$/;"	m	struct:numericConfigData	file:
is_section_doc	modules/gendoc.rb	/^def is_section_doc(src, i)$/;"	f
is_updating_slots	redis-benchmark.c	/^    redisAtomic int is_updating_slots;$/;"	m	struct:config	file:
is_updating_slots_mutex	redis-benchmark.c	/^    pthread_mutex_t is_updating_slots_mutex;$/;"	m	struct:config	file:
is_valid_fn	config.c	/^    int (*is_valid_fn)(char* val, const char **err); \/* Optional function to check validity of new value (generic doc above) *\/$/;"	m	struct:stringConfigData	file:
is_valid_fn	config.c	/^    int (*is_valid_fn)(int val, const char **err); \/* Optional function to check validity of new value (generic doc above) *\/$/;"	m	struct:boolConfigData	file:
is_valid_fn	config.c	/^    int (*is_valid_fn)(int val, const char **err); \/* Optional function to check validity of new value (generic doc above) *\/$/;"	m	struct:enumConfigData	file:
is_valid_fn	config.c	/^    int (*is_valid_fn)(long long val, const char **err); \/* Optional function to check validity of new value (generic doc above) *\/$/;"	m	struct:numericConfigData	file:
is_valid_fn	config.c	/^    int (*is_valid_fn)(sds val, const char **err); \/* Optional function to check validity of new value (generic doc above) *\/$/;"	m	struct:sdsConfigData	file:
iscompr	rax.h	/^    uint32_t iscompr:1;   \/* Node is compressed. *\/$/;"	m	struct:raxNode
isfinite	solarisfixes.h	40;"	d
isfinite	solarisfixes.h	41;"	d
isinf	solarisfixes.h	45;"	d
isinf	solarisfixes.h	46;"	d
iskey	rax.h	/^    uint32_t iskey:1;     \/* Does this node contain a key? *\/$/;"	m	struct:raxNode
isnan	solarisfixes.h	35;"	d
isnan	solarisfixes.h	36;"	d
isnull	rax.h	/^    uint32_t isnull:1;    \/* Associated value is NULL (don't store it). *\/$/;"	m	struct:raxNode
issueCommand	redis-cli.c	/^static int issueCommand(int argc, char **argv) {$/;"	f	file:
issueCommandRepeat	redis-cli.c	/^static int issueCommandRepeat(int argc, char **argv, long repeat) {$/;"	f	file:
items	rax.h	/^    size_t items, maxitems; \/* Number of items contained and total space. *\/$/;"	m	struct:raxStack
iter	module.c	/^    void *iter;     \/* Iterator. *\/$/;"	m	struct:RedisModuleKey	file:
iter	server.h	/^    quicklistIter *iter;$/;"	m	struct:__anon50
iter	t_zset.c	/^    } iter;$/;"	m	struct:__anon61	typeref:union:__anon61::__anon62	file:
iterset	t_zset.c	/^typedef union _iterset iterset;$/;"	t	typeref:union:_iterset	file:
iterzset	t_zset.c	/^typedef union _iterzset iterzset;$/;"	t	typeref:union:_iterzset	file:
itrprintr	quicklist.c	/^static int itrprintr(quicklist *ql, int print) {$/;"	f	file:
itrprintr_rev	quicklist.c	/^static int itrprintr_rev(quicklist *ql, int print) {$/;"	f	file:
jemalloc_bg_thread	server.h	/^    int jemalloc_bg_thread;         \/* Enable jemalloc background thread *\/$/;"	m	struct:redisServer
jemalloc_purge	zmalloc.c	/^int jemalloc_purge() {$/;"	f
justid	server.h	/^    *time, *pxat, *px, *retrycount, *force, *justid, $/;"	m	struct:sharedObjectsStruct
k	sha256.c	/^static const WORD k[64] = {$/;"	v	file:
keepalive	redis-benchmark.c	/^    int keepalive;$/;"	m	struct:config	file:
keepttl	server.h	/^    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,$/;"	m	struct:sharedObjectsStruct
key	cli_common.h	/^    char *key;$/;"	m	struct:cliSSLconfig
key	dict.h	/^    void *key;$/;"	m	struct:dictEntry
key	evict.c	/^    sds key;                    \/* Key name. *\/$/;"	m	struct:evictionPoolEntry	file:
key	module.c	/^    RedisModuleKey *key;$/;"	m	struct:__anon33	file:
key	module.c	/^    robj *key;      \/* Key name object. *\/$/;"	m	struct:RedisModuleKey	file:
key	multi.c	/^    robj *key;$/;"	m	struct:watchedKey	file:
key	rax.h	/^    unsigned char *key;     \/* The current string. *\/$/;"	m	struct:raxIterator
key	redis-check-rdb.c	/^    robj *key;                      \/* Current key we are reading. *\/$/;"	m	struct:__anon34	file:
key	server.h	/^    robj *key;$/;"	m	struct:readyList
key	server.h	/^    struct redisObject *key;    \/* Optional name of key processed *\/$/;"	m	struct:RedisModuleIO	typeref:struct:RedisModuleIO::redisObject
keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType
keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType
keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType
keyHashSlot	cluster.c	/^unsigned int keyHashSlot(char *key, int keylen) {$/;"	f
keyIsExpired	db.c	/^int keyIsExpired(redisDb *db, robj *key) {$/;"	f
key_file	server.h	/^    char *key_file;                 \/* Private key filename for cert_file *\/$/;"	m	struct:redisTLSContextConfig
key_file_pass	server.h	/^    char *key_file_pass;            \/* Optional password for key_file *\/$/;"	m	struct:redisTLSContextConfig
key_len	rax.h	/^    size_t key_len;         \/* Current key length. *\/$/;"	m	struct:raxIterator
key_load_delay	server.h	/^    int key_load_delay;             \/* Delay in microseconds between keys while$/;"	m	struct:redisServer
key_max	rax.h	/^    size_t key_max;         \/* Max key len the current key buffer can hold. *\/$/;"	m	struct:raxIterator
key_static_string	rax.h	/^    unsigned char key_static_string[RAX_ITER_STATIC_LEN];$/;"	m	struct:raxIterator
key_type	redis-check-rdb.c	/^    int key_type;                   \/* Current key type if != -1. *\/$/;"	m	struct:__anon34	file:
keylistDictType	server.c	/^dictType keylistDictType = {$/;"	v
keyname	stream.h	/^    robj *keyname;$/;"	m	struct:streamPropInfo
keys	childinfo.c	/^    size_t keys;$/;"	m	struct:__anon1	file:
keys	redis-check-rdb.c	/^    unsigned long keys;             \/* Number of keys processed. *\/$/;"	m	struct:__anon34	file:
keys	server.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	struct:blockingState
keys	server.h	/^    int *keys;                          \/* Key indices array, points to keysbuf or heap *\/$/;"	m	struct:__anon48
keys	tracking.c	/^    rax *keys;      \/* Keys modified in the current event loop cycle. *\/$/;"	m	struct:bcastState	file:
keysCommand	db.c	/^void keysCommand(client *c) {$/;"	f
keys_result	module.c	/^    getKeysResult *keys_result;$/;"	m	struct:RedisModuleCtx	file:
keysbuf	server.h	/^    int keysbuf[MAX_KEYS_BUFFER];       \/* Pre-allocated buffer, to save heap allocations *\/$/;"	m	struct:__anon48
keysize	redis-benchmark.c	/^    int keysize;$/;"	m	struct:config	file:
keyspaceEventsFlagsToString	notify.c	/^sds keyspaceEventsFlagsToString(int flags) {$/;"	f
keyspaceEventsStringToFlags	notify.c	/^int keyspaceEventsStringToFlags(char *classes) {$/;"	f
keystep	server.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	struct:redisCommand
killAppendOnlyChild	aof.c	/^void killAppendOnlyChild(void) {$/;"	f
killIOThreads	networking.c	/^void killIOThreads(void) {$/;"	f
killMainThread	debug.c	/^static void killMainThread(void) {$/;"	f	file:
killRDBChild	rdb.c	/^void killRDBChild(void) {$/;"	f
killThreads	debug.c	/^void killThreads(void) {$/;"	f
kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
l	config.c	/^        long *l;$/;"	m	union:numericConfigData::__anon14	file:
label	sparkline.h	/^    char *label;$/;"	m	struct:sample
label_margin_top	sparkline.c	/^static int label_margin_top = 1;$/;"	v	file:
labels	sparkline.h	/^    int labels;$/;"	m	struct:sequence
lastVoteEpoch	cluster.h	/^    uint64_t lastVoteEpoch;     \/* Epoch of the last vote granted. *\/$/;"	m	struct:clusterState
last_avail_time	sentinel.c	/^    mstime_t last_avail_time; \/* Last time the instance replied to ping with$/;"	m	struct:instanceLink	file:
last_cmd_type	redis-cli.c	/^    int last_cmd_type;$/;"	m	struct:config	file:
last_dbid	cluster.c	/^    long last_dbid;$/;"	m	struct:migrateCachedSocket	file:
last_errno	connection.h	/^    int last_errno;$/;"	m	struct:connection
last_hello_time	sentinel.c	/^    mstime_t last_hello_time; \/* Only used if SRI_SENTINEL is set. Last time$/;"	m	struct:sentinelRedisInstance	file:
last_id	stream.h	/^    streamID last_id;       \/* Last delivered (not acknowledged) ID for this$/;"	m	struct:streamCG
last_id	stream.h	/^    streamID last_id;       \/* Zero if there are yet no items. *\/$/;"	m	struct:stream
last_master_down_reply_time	sentinel.c	/^    mstime_t last_master_down_reply_time; \/* Time of last reply to$/;"	m	struct:sentinelRedisInstance	file:
last_ping_time	sentinel.c	/^    mstime_t last_ping_time;  \/* Time at which we sent the last ping. This is$/;"	m	struct:instanceLink	file:
last_pong_time	sentinel.c	/^    mstime_t last_pong_time;  \/* Last time the instance replied to ping,$/;"	m	struct:instanceLink	file:
last_printed_bytes	redis-benchmark.c	/^    int last_printed_bytes;$/;"	m	struct:config	file:
last_pub_time	sentinel.c	/^    mstime_t last_pub_time;   \/* Last time we sent hello via Pub\/Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:
last_reconn_time	sentinel.c	/^    mstime_t last_reconn_time;  \/* Last reconnection attempt performed when$/;"	m	struct:instanceLink	file:
last_sample_count	server.h	/^        long long last_sample_count;\/* Count in last sample *\/$/;"	m	struct:redisServer::__anon47
last_sample_time	server.h	/^        long long last_sample_time; \/* Timestamp of last sample in ms *\/$/;"	m	struct:redisServer::__anon47
last_use_time	cluster.c	/^    time_t last_use_time;$/;"	m	struct:migrateCachedSocket	file:
lastbgsave_status	server.h	/^    int lastbgsave_status;          \/* C_OK or C_ERR *\/$/;"	m	struct:redisServer
lastbgsave_try	server.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	struct:redisServer
lastcmd	server.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	struct:client	typeref:struct:client::
lastid	server.h	/^    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,$/;"	m	struct:sharedObjectsStruct
lastinteraction	server.h	/^    time_t lastinteraction; \/* Time of the last interaction, used for timeout *\/$/;"	m	struct:client
lastkey	server.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	struct:redisCommand
lastsave	server.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	struct:redisServer
lastsaveCommand	db.c	/^void lastsaveCommand(client *c) {$/;"	f
latency	latency.h	/^    uint32_t latency; \/* Latency in milliseconds. *\/$/;"	m	struct:latencySample
latency	redis-benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	struct:_client	file:
latencyAddSample	latency.c	/^void latencyAddSample(const char *event, mstime_t latency) {$/;"	f
latencyAddSampleIfNeeded	latency.h	85;"	d
latencyCommand	latency.c	/^void latencyCommand(client *c) {$/;"	f
latencyCommandGenSparkeline	latency.c	/^sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {$/;"	f
latencyCommandReplyWithLatestEvents	latency.c	/^void latencyCommandReplyWithLatestEvents(client *c) {$/;"	f
latencyCommandReplyWithSamples	latency.c	/^void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {$/;"	f
latencyDistMode	redis-cli.c	/^static void latencyDistMode(void) {$/;"	f	file:
latencyEndMonitor	latency.h	80;"	d
latencyMode	redis-cli.c	/^static void latencyMode(void) {$/;"	f	file:
latencyModePrint	redis-cli.c	/^static void latencyModePrint(long long min, long long max, double avg, long long count) {$/;"	f	file:
latencyMonitorInit	latency.c	/^void latencyMonitorInit(void) {$/;"	f
latencyRemoveNestedEvent	latency.h	91;"	d
latencyResetEvent	latency.c	/^int latencyResetEvent(char *event_to_reset) {$/;"	f
latencySample	latency.h	/^struct latencySample {$/;"	s
latencyStartMonitor	latency.h	72;"	d
latencyStats	latency.h	/^struct latencyStats {$/;"	s
latencyTimeSeries	latency.h	/^struct latencyTimeSeries {$/;"	s
latencyTimeSeriesDictType	latency.c	/^dictType latencyTimeSeriesDictType = {$/;"	v
latency_dist_mode	redis-cli.c	/^    int latency_dist_mode;$/;"	m	struct:config	file:
latency_events	server.h	/^    dict *latency_events;$/;"	m	struct:redisServer
latency_histogram	redis-benchmark.c	/^    struct hdr_histogram* latency_histogram;$/;"	m	struct:config	typeref:struct:config::hdr_histogram	file:
latency_history	redis-cli.c	/^    int latency_history;$/;"	m	struct:config	file:
latency_mode	redis-cli.c	/^    int latency_mode;$/;"	m	struct:config	file:
latency_monitor_threshold	server.h	/^    long long latency_monitor_threshold;$/;"	m	struct:redisServer
latitude	geo.h	/^    double latitude;$/;"	m	struct:geoPoint
latitude	geohash.h	/^    GeoHashRange latitude;$/;"	m	struct:__anon22
lazyFreeLuaScripts	lazyfree.c	/^void lazyFreeLuaScripts(void *args[]) {$/;"	f
lazyFreeTrackingTable	lazyfree.c	/^void lazyFreeTrackingTable(void *args[]) {$/;"	f
lazy_free_fn	bio.h	/^typedef void lazy_free_fn(void *args[]);$/;"	t
lazyfreeFreeDatabase	lazyfree.c	/^void lazyfreeFreeDatabase(void *args[]) {$/;"	f
lazyfreeFreeObject	lazyfree.c	/^void lazyfreeFreeObject(void *args[]) {$/;"	f
lazyfreeFreeSlotsMap	lazyfree.c	/^void lazyfreeFreeSlotsMap(void *args[]) {$/;"	f
lazyfreeGetFreeEffort	lazyfree.c	/^size_t lazyfreeGetFreeEffort(robj *key, robj *obj) {$/;"	f
lazyfreeGetFreedObjectsCount	lazyfree.c	/^size_t lazyfreeGetFreedObjectsCount(void) {$/;"	f
lazyfreeGetPendingObjectsCount	lazyfree.c	/^size_t lazyfreeGetPendingObjectsCount(void) {$/;"	f
lazyfree_lazy_eviction	server.h	/^    int lazyfree_lazy_eviction;$/;"	m	struct:redisServer
lazyfree_lazy_expire	server.h	/^    int lazyfree_lazy_expire;$/;"	m	struct:redisServer
lazyfree_lazy_server_del	server.h	/^    int lazyfree_lazy_server_del;$/;"	m	struct:redisServer
lazyfree_lazy_user_del	server.h	/^    int lazyfree_lazy_user_del;$/;"	m	struct:redisServer
lazyfree_lazy_user_flush	server.h	/^    int lazyfree_lazy_user_flush;$/;"	m	struct:redisServer
lazyfree_objects	lazyfree.c	/^static redisAtomic size_t lazyfree_objects = 0;$/;"	v	file:
lazyfreed_objects	lazyfree.c	/^static redisAtomic size_t lazyfreed_objects = 0;$/;"	v	file:
lcsGetKeys	db.c	/^int lcsGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
ld2string	util.c	/^int ld2string(char *buf, size_t len, long double value, ld2string_mode mode) {$/;"	f
ld2string_mode	util.h	/^} ld2string_mode;$/;"	t	typeref:enum:__anon71
ldb	scripting.c	/^} ldb;$/;"	v	typeref:struct:ldbState
ldbAddBreakpoint	scripting.c	/^int ldbAddBreakpoint(int line) {$/;"	f
ldbBreak	scripting.c	/^void ldbBreak(sds *argv, int argc) {$/;"	f
ldbCatStackValue	scripting.c	/^sds ldbCatStackValue(sds s, lua_State *lua, int idx) {$/;"	f
ldbCatStackValueRec	scripting.c	/^sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {$/;"	f
ldbDelBreakpoint	scripting.c	/^int ldbDelBreakpoint(int line) {$/;"	f
ldbDisable	scripting.c	/^void ldbDisable(client *c) {$/;"	f
ldbEnable	scripting.c	/^void ldbEnable(client *c) {$/;"	f
ldbEndSession	scripting.c	/^void ldbEndSession(client *c) {$/;"	f
ldbEval	scripting.c	/^void ldbEval(lua_State *lua, sds *argv, int argc) {$/;"	f
ldbFlushLog	scripting.c	/^void ldbFlushLog(list *log) {$/;"	f
ldbGetSourceLine	scripting.c	/^char *ldbGetSourceLine(int line) {$/;"	f
ldbInit	scripting.c	/^void ldbInit(void) {$/;"	f
ldbIsBreakpoint	scripting.c	/^int ldbIsBreakpoint(int line) {$/;"	f
ldbKillForkedSessions	scripting.c	/^void ldbKillForkedSessions(void) {$/;"	f
ldbList	scripting.c	/^void ldbList(int around, int context) {$/;"	f
ldbLog	scripting.c	/^void ldbLog(sds entry) {$/;"	f
ldbLogRedisReply	scripting.c	/^void ldbLogRedisReply(char *reply) {$/;"	f
ldbLogSourceLine	scripting.c	/^void ldbLogSourceLine(int lnum) {$/;"	f
ldbLogStackValue	scripting.c	/^void ldbLogStackValue(lua_State *lua, char *prefix) {$/;"	f
ldbLogWithMaxLen	scripting.c	/^void ldbLogWithMaxLen(sds entry) {$/;"	f
ldbMaxlen	scripting.c	/^void ldbMaxlen(sds *argv, int argc) {$/;"	f
ldbPendingChildren	scripting.c	/^int ldbPendingChildren(void) {$/;"	f
ldbPrint	scripting.c	/^void ldbPrint(lua_State *lua, char *varname) {$/;"	f
ldbPrintAll	scripting.c	/^void ldbPrintAll(lua_State *lua) {$/;"	f
ldbRedis	scripting.c	/^void ldbRedis(lua_State *lua, sds *argv, int argc) {$/;"	f
ldbRedisProtocolToHuman	scripting.c	/^char *ldbRedisProtocolToHuman(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Bool	scripting.c	/^char *ldbRedisProtocolToHuman_Bool(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Bulk	scripting.c	/^char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Double	scripting.c	/^char *ldbRedisProtocolToHuman_Double(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Int	scripting.c	/^char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Map	scripting.c	/^char *ldbRedisProtocolToHuman_Map(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_MultiBulk	scripting.c	/^char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Null	scripting.c	/^char *ldbRedisProtocolToHuman_Null(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Set	scripting.c	/^char *ldbRedisProtocolToHuman_Set(sds *o, char *reply) {$/;"	f
ldbRedisProtocolToHuman_Status	scripting.c	/^char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {$/;"	f
ldbRemoveChild	scripting.c	/^int ldbRemoveChild(pid_t pid) {$/;"	f
ldbRepl	scripting.c	/^int ldbRepl(lua_State *lua) {$/;"	f
ldbReplParseCommand	scripting.c	/^sds *ldbReplParseCommand(int *argcp) {$/;"	f
ldbSendLogs	scripting.c	/^void ldbSendLogs(void) {$/;"	f
ldbStartSession	scripting.c	/^int ldbStartSession(client *c) {$/;"	f
ldbState	scripting.c	/^struct ldbState {$/;"	s	file:
ldbTrace	scripting.c	/^void ldbTrace(lua_State *lua) {$/;"	f
leader	sentinel.c	/^    char *leader;       \/* If this is a master instance, this is the runid of$/;"	m	struct:sentinelRedisInstance	file:
leaderVotesDictType	sentinel.c	/^dictType leaderVotesDictType = {$/;"	v
leader_epoch	sentinel.c	/^    uint64_t leader_epoch; \/* Epoch of the 'leader' field. *\/$/;"	m	struct:sentinelRedisInstance	file:
left	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
len	adlist.h	/^    unsigned long len;$/;"	m	struct:list
len	cluster.h	/^    uint32_t len;           \/* ID of the sender module. *\/$/;"	m	struct:__anon6
len	module.c	/^    size_t len;     \/* Len of strings or num of elements of arrays. *\/$/;"	m	struct:RedisModuleCallReply	file:
len	modules/hellotype.c	/^    size_t len; \/* Number of elements added. *\/$/;"	m	struct:HelloTypeObject	file:
len	quicklist.h	/^    unsigned long len;          \/* number of quicklistNodes *\/$/;"	m	struct:quicklist
len	redis-cli.c	/^    int len;                    \/* Actual length of the array *\/$/;"	m	struct:clusterManagerNodeArray	file:
len	sds.h	/^    uint16_t len; \/* used *\/$/;"	m	struct:sdshdr16
len	sds.h	/^    uint32_t len; \/* used *\/$/;"	m	struct:sdshdr32
len	sds.h	/^    uint64_t len; \/* used *\/$/;"	m	struct:sdshdr64
len	sds.h	/^    uint8_t len; \/* used *\/$/;"	m	struct:sdshdr8
len	ziplist.c	/^    unsigned int len;            \/* Bytes used to represent the actual entry.$/;"	m	struct:zlentry	file:
length	intset.h	/^    uint32_t length;$/;"	m	struct:intset
length	server.h	/^    unsigned long length;$/;"	m	struct:zskiplist
length	sparkline.h	/^    int length;$/;"	m	struct:sequence
length	stream.h	/^    uint64_t length;        \/* Number of elements inside this stream. *\/$/;"	m	struct:stream
lensize	ziplist.c	/^    unsigned int lensize;        \/* Bytes used to encode this entry type\/len.$/;"	m	struct:zlentry	file:
level	server.h	/^    int level;$/;"	m	struct:zskiplist
level	server.h	/^    } level[];$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel
lfu_decay_time	server.h	/^    int lfu_decay_time;             \/* LFU counter decay factor. *\/$/;"	m	struct:redisServer
lfu_log_factor	server.h	/^    int lfu_log_factor;             \/* LFU logarithmic counter factor. *\/$/;"	m	struct:redisServer
li	server.h	/^    listTypeIterator *li;$/;"	m	struct:__anon51
likely	config.h	107;"	d
likely	config.h	110;"	d
limit	t_stream.c	/^    long long limit; \/* Maximum amount of entries to trim. If 0, no limitation$/;"	m	struct:__anon59	file:
lindexCommand	t_list.c	/^void lindexCommand(client *c) {$/;"	f
line	redis-check-aof.c	/^static long long line = 1;$/;"	v	file:
line	server.h	/^    sds line;$/;"	m	struct:sentinelLoadQueueEntry
linebreak_proto	modules/gendoc.rb	/^def linebreak_proto(proto, indent)$/;"	f
linenum	server.h	/^    int linenum;$/;"	m	struct:sentinelLoadQueueEntry
lines	scripting.c	/^    int lines;  \/* Number of lines in 'src'. *\/$/;"	m	struct:ldbState	file:
link	cluster.h	/^    clusterLink *link;          \/* TCP\/IP link with this node *\/$/;"	m	struct:clusterNode
link	sentinel.c	/^    instanceLink *link; \/* Link to the instance, may be shared for Sentinels. *\/$/;"	m	struct:sentinelRedisInstance	file:
linkClient	networking.c	/^void linkClient(client *c) {$/;"	f
linsertCommand	t_list.c	/^void linsertCommand(client *c) {$/;"	f
linuxMadvFreeForkBugCheck	server.c	/^int linuxMadvFreeForkBugCheck(void) {$/;"	f
linuxMemoryWarnings	server.c	/^void linuxMemoryWarnings(void) {$/;"	f
linuxOvercommitMemoryValue	server.c	/^int linuxOvercommitMemoryValue(void) {$/;"	f
list	adlist.h	/^typedef struct list {$/;"	s
list	adlist.h	/^} list;$/;"	t	typeref:struct:list
listAddNodeHead	adlist.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f
listAddNodeTail	adlist.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f
listCreate	adlist.c	/^list *listCreate(void)$/;"	f
listDelNode	adlist.c	/^void listDelNode(list *list, listNode *node)$/;"	f
listDup	adlist.c	/^list *listDup(list *orig)$/;"	f
listElementsRemoved	t_list.c	/^void listElementsRemoved(client *c, robj *key, int where, robj *o, long count) {$/;"	f
listEmpty	adlist.c	/^void listEmpty(list *list)$/;"	f
listFirst	adlist.h	58;"	d
listGetDupMethod	adlist.h	68;"	d
listGetFreeMethod	adlist.h	69;"	d
listGetIterator	adlist.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f
listGetMatchMethod	adlist.h	70;"	d
listIndex	adlist.c	/^listNode *listIndex(list *list, long index) {$/;"	f
listInsertNode	adlist.c	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$/;"	f
listIter	adlist.h	/^typedef struct listIter {$/;"	s
listIter	adlist.h	/^} listIter;$/;"	t	typeref:struct:listIter
listJoin	adlist.c	/^void listJoin(list *l, list *o) {$/;"	f
listLast	adlist.h	59;"	d
listLength	adlist.h	57;"	d
listMatchObjects	networking.c	/^int listMatchObjects(void *a, void *b) {$/;"	f
listNext	adlist.c	/^listNode *listNext(listIter *iter)$/;"	f
listNextNode	adlist.h	61;"	d
listNode	adlist.h	/^typedef struct listNode {$/;"	s
listNode	adlist.h	/^} listNode;$/;"	t	typeref:struct:listNode
listNodeValue	adlist.h	62;"	d
listPopSaver	t_list.c	/^void *listPopSaver(unsigned char *data, unsigned int sz) {$/;"	f
listPos	server.h	/^    struct listPos {$/;"	s	struct:blockingState
listPrevNode	adlist.h	60;"	d
listRelease	adlist.c	/^void listRelease(list *list)$/;"	f
listReleaseIterator	adlist.c	/^void listReleaseIterator(listIter *iter) {$/;"	f
listRewind	adlist.c	/^void listRewind(list *list, listIter *li) {$/;"	f
listRewindTail	adlist.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f
listRotateHeadToTail	adlist.c	/^void listRotateHeadToTail(list *list) {$/;"	f
listRotateTailToHead	adlist.c	/^void listRotateTailToHead(list *list) {$/;"	f
listSearchKey	adlist.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f
listSetDupMethod	adlist.h	64;"	d
listSetFreeMethod	adlist.h	65;"	d
listSetMatchMethod	adlist.h	66;"	d
listTypeConvert	t_list.c	/^void listTypeConvert(robj *subject, int enc) {$/;"	f
listTypeDelete	t_list.c	/^void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {$/;"	f
listTypeDup	t_list.c	/^robj *listTypeDup(robj *o) {$/;"	f
listTypeEntry	server.h	/^} listTypeEntry;$/;"	t	typeref:struct:__anon51
listTypeEqual	t_list.c	/^int listTypeEqual(listTypeEntry *entry, robj *o) {$/;"	f
listTypeGet	t_list.c	/^robj *listTypeGet(listTypeEntry *entry) {$/;"	f
listTypeInitIterator	t_list.c	/^listTypeIterator *listTypeInitIterator(robj *subject, long index,$/;"	f
listTypeInsert	t_list.c	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where) {$/;"	f
listTypeIterator	server.h	/^} listTypeIterator;$/;"	t	typeref:struct:__anon50
listTypeLength	t_list.c	/^unsigned long listTypeLength(const robj *subject) {$/;"	f
listTypeNext	t_list.c	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {$/;"	f
listTypePop	t_list.c	/^robj *listTypePop(robj *subject, int where) {$/;"	f
listTypePush	t_list.c	/^void listTypePush(robj *subject, robj *value, int where) {$/;"	f
listTypeReleaseIterator	t_list.c	/^void listTypeReleaseIterator(listTypeIterator *li) {$/;"	f
list_compress_depth	server.h	/^    int list_compress_depth;$/;"	m	struct:redisServer
list_max_ziplist_size	server.h	/^    int list_max_ziplist_size;$/;"	m	struct:redisServer
listenToPort	server.c	/^int listenToPort(int port, socketFds *sfd) {$/;"	f
listnode	blocked.c	/^    listNode *listnode;     \/* List node for db->blocking_keys[key] list. *\/$/;"	m	struct:bkinfo	file:
listpos	server.h	/^    } listpos;              \/* The positions in the src\/dst lists$/;"	m	struct:blockingState	typeref:struct:blockingState::listPos
liveclients	redis-benchmark.c	/^    redisAtomic int liveclients;$/;"	m	struct:config	file:
liveclients_mutex	redis-benchmark.c	/^    pthread_mutex_t liveclients_mutex;$/;"	m	struct:config	file:
ll	config.c	/^        long long *ll;$/;"	m	union:numericConfigData::__anon14	file:
ll	module.c	/^        long long ll;    \/* Reply value for integer reply. *\/$/;"	m	union:RedisModuleCallReply::__anon31	file:
ll2string	util.c	/^int ll2string(char *dst, size_t dstlen, long long svalue) {$/;"	f
llenCommand	t_list.c	/^void llenCommand(client *c) {$/;"	f
lmove	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
lmoveCommand	server.h	/^                        *xgroupCommand, *rpoplpushCommand, *lmoveCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
lmoveCommand	t_list.c	/^void lmoveCommand(client *c) {$/;"	f
lmoveGenericCommand	t_list.c	/^void lmoveGenericCommand(client *c, int wherefrom, int whereto) {$/;"	f
lmoveHandlePush	t_list.c	/^void lmoveHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value,$/;"	f
load	server.h	/^    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,$/;"	m	struct:sharedObjectsStruct
loadAppendOnlyFile	aof.c	/^int loadAppendOnlyFile(char *filename) {$/;"	f
loadDataFromDisk	server.c	/^void loadDataFromDisk(void) {$/;"	f
loadSentinelConfigFromQueue	sentinel.c	/^void loadSentinelConfigFromQueue(void) {$/;"	f
loadServerConfig	config.c	/^void loadServerConfig(char *filename, char config_from_stdin, char *options) {$/;"	f
loadServerConfigFromString	config.c	/^void loadServerConfigFromString(char *config) {$/;"	f
loading	server.h	/^    volatile sig_atomic_t loading; \/* We are loading data from disk if true *\/$/;"	m	struct:redisServer
loadingProgress	rdb.c	/^void loadingProgress(off_t pos) {$/;"	f
loading_loaded_bytes	server.h	/^    off_t loading_loaded_bytes;$/;"	m	struct:redisServer
loading_process_events_interval_bytes	server.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	struct:redisServer
loading_rdb_used_mem	server.h	/^    off_t loading_rdb_used_mem;$/;"	m	struct:redisServer
loading_start_time	server.h	/^    time_t loading_start_time;$/;"	m	struct:redisServer
loading_total_bytes	server.h	/^    off_t loading_total_bytes;$/;"	m	struct:redisServer
loadingerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
loadmodule_queue	server.h	/^    list *loadmodule_queue;     \/* List of modules to load at startup. *\/$/;"	m	struct:redisServer
logCurrentClient	debug.c	/^void logCurrentClient(void) {$/;"	f
logModulesInfo	debug.c	/^void logModulesInfo(void) {$/;"	f
logRegisters	debug.c	/^void logRegisters(ucontext_t *uc) {$/;"	f
logServerInfo	debug.c	/^void logServerInfo(void) {$/;"	f
logStackContent	debug.c	/^void logStackContent(void **sp) {$/;"	f
logStackTrace	debug.c	/^void logStackTrace(void *eip, int uplevel) {$/;"	f
logfile	server.h	/^    char *logfile;                  \/* Path of log file *\/$/;"	m	struct:redisServer
loglevel_enum	config.c	/^configEnum loglevel_enum[] = {$/;"	v
logs	scripting.c	/^    list *logs; \/* List of messages to send to the client. *\/$/;"	m	struct:ldbState	file:
lolwut5Command	lolwut5.c	/^void lolwut5Command(client *c) {$/;"	f
lolwut6Command	lolwut6.c	/^void lolwut6Command(client *c) {$/;"	f
lolwutCommand	lolwut.c	/^void lolwutCommand(client *c) {$/;"	f
lolwutUnstableCommand	lolwut.c	/^void lolwutUnstableCommand(client *c) {$/;"	f
longLatFromMember	geo.c	/^int longLatFromMember(robj *zobj, robj *member, double *xy) {$/;"	f
longitude	geo.h	/^    double longitude;$/;"	m	struct:geoPoint
longitude	geohash.h	/^    GeoHashRange longitude;$/;"	m	struct:__anon22
longval	quicklist.h	/^    long long longval;$/;"	m	struct:quicklistEntry
lookupClientByID	networking.c	/^client *lookupClientByID(uint64_t id) {$/;"	f
lookupCommand	server.c	/^struct redisCommand *lookupCommand(sds name) {$/;"	f
lookupCommandByCString	server.c	/^struct redisCommand *lookupCommandByCString(const char *s) {$/;"	f
lookupCommandOrOriginal	server.c	/^struct redisCommand *lookupCommandOrOriginal(sds name) {$/;"	f
lookupKey	db.c	/^robj *lookupKey(redisDb *db, robj *key, int flags) {$/;"	f
lookupKeyByPattern	sort.c	/^robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst, int writeflag) {$/;"	f
lookupKeyRead	db.c	/^robj *lookupKeyRead(redisDb *db, robj *key) {$/;"	f
lookupKeyReadOrReply	db.c	/^robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {$/;"	f
lookupKeyReadWithFlags	db.c	/^robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {$/;"	f
lookupKeyWrite	db.c	/^robj *lookupKeyWrite(redisDb *db, robj *key) {$/;"	f
lookupKeyWriteOrReply	db.c	/^robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {$/;"	f
lookupKeyWriteWithFlags	db.c	/^robj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags) {$/;"	f
lookupStringForBitCommand	bitops.c	/^robj *lookupStringForBitCommand(client *c, size_t maxbit) {$/;"	f
loop	redis-benchmark.c	/^    int loop;$/;"	m	struct:config	file:
loop	sentinel.c	/^    aeEventLoop *loop;$/;"	m	struct:redisAeEvents	file:
lower_bound	config.c	/^    long long lower_bound; \/* The lower bound of this numeric value *\/$/;"	m	struct:numericConfigData	file:
lp	stream.h	/^    unsigned char *lp;      \/* Current listpack. *\/$/;"	m	struct:streamIterator
lpAppend	listpack.c	/^unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {$/;"	f
lpAppendInteger	t_stream.c	/^unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {$/;"	f
lpBytes	listpack.c	/^uint32_t lpBytes(unsigned char *lp) {$/;"	f
lpCurrentEncodedSizeBytes	listpack.c	/^uint32_t lpCurrentEncodedSizeBytes(unsigned char *p) {$/;"	f
lpCurrentEncodedSizeUnsafe	listpack.c	/^uint32_t lpCurrentEncodedSizeUnsafe(unsigned char *p) {$/;"	f
lpDecodeBacklen	listpack.c	/^uint64_t lpDecodeBacklen(unsigned char *p) {$/;"	f
lpDelete	listpack.c	/^unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {$/;"	f
lpEncodeBacklen	listpack.c	/^unsigned long lpEncodeBacklen(unsigned char *buf, uint64_t l) {$/;"	f
lpEncodeGetType	listpack.c	/^int lpEncodeGetType(unsigned char *ele, uint32_t size, unsigned char *intenc, uint64_t *enclen) {$/;"	f
lpEncodeString	listpack.c	/^void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {$/;"	f
lpFirst	listpack.c	/^unsigned char *lpFirst(unsigned char *lp) {$/;"	f
lpFree	listpack.c	/^void lpFree(unsigned char *lp) {$/;"	f
lpGet	listpack.c	/^unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {$/;"	f
lpGetEdgeStreamID	t_stream.c	/^int lpGetEdgeStreamID(unsigned char *lp, int first, streamID *master_id, streamID *edge_id)$/;"	f
lpGetInteger	t_stream.c	289;"	d	file:
lpGetIntegerIfValid	t_stream.c	/^static inline int64_t lpGetIntegerIfValid(unsigned char *ele, int *valid) {$/;"	f	file:
lpGetNumElements	listpack.c	105;"	d	file:
lpGetTotalBytes	listpack.c	100;"	d	file:
lpInsert	listpack.c	/^unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, unsigned char *p, int where, unsigned char **newp) {$/;"	f
lpLast	listpack.c	/^unsigned char *lpLast(unsigned char *lp) {$/;"	f
lpLength	listpack.c	/^uint32_t lpLength(unsigned char *lp) {$/;"	f
lpNew	listpack.c	/^unsigned char *lpNew(size_t capacity) {$/;"	f
lpNext	listpack.c	/^unsigned char *lpNext(unsigned char *lp, unsigned char *p) {$/;"	f
lpPrev	listpack.c	/^unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {$/;"	f
lpReplaceInteger	t_stream.c	/^unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {$/;"	f
lpSeek	listpack.c	/^unsigned char *lpSeek(unsigned char *lp, long index) {$/;"	f
lpSetNumElements	listpack.c	114;"	d	file:
lpSetTotalBytes	listpack.c	107;"	d	file:
lpShrinkToFit	listpack.c	/^unsigned char* lpShrinkToFit(unsigned char *lp) {$/;"	f
lpSkip	listpack.c	/^unsigned char *lpSkip(unsigned char *p) {$/;"	f
lpStringToInt64	listpack.c	/^int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {$/;"	f
lpValidateIntegrity	listpack.c	/^int lpValidateIntegrity(unsigned char *lp, size_t size, int deep){$/;"	f
lpValidateNext	listpack.c	/^int lpValidateNext(unsigned char *lp, unsigned char **pp, size_t lpbytes) {$/;"	f
lp_ele	stream.h	/^    unsigned char *lp_ele;  \/* Current listpack cursor. *\/$/;"	m	struct:streamIterator
lp_flags	stream.h	/^    unsigned char *lp_flags; \/* Current entry flags pointer. *\/$/;"	m	struct:streamIterator
lp_free	listpack_malloc.h	44;"	d
lp_malloc	listpack_malloc.h	42;"	d
lp_malloc_size	listpack_malloc.h	45;"	d
lp_realloc	listpack_malloc.h	43;"	d
lpop	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
lpopCommand	server.h	/^                        *lpopCommand, *rpopCommand, *zpopminCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
lpopCommand	t_list.c	/^void lpopCommand(client *c) {$/;"	f
lposCommand	t_list.c	/^void lposCommand(client *c) {$/;"	f
lpush	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
lpushCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
lpushCommand	t_list.c	/^void lpushCommand(client *c) {$/;"	f
lpushxCommand	t_list.c	/^void lpushxCommand(client *c) {$/;"	f
lrangeCommand	t_list.c	/^void lrangeCommand(client *c) {$/;"	f
lremCommand	t_list.c	/^void lremCommand(client *c) {$/;"	f
lrs	module.c	/^            zlexrangespec lrs;     \/* Lex range. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
lru	server.h	/^    unsigned lru:LRU_BITS; \/* LRU time (relative to global lru_clock) or$/;"	m	struct:redisObject
lru_test_mode	redis-cli.c	/^    int lru_test_mode;$/;"	m	struct:config	file:
lru_test_sample_size	redis-cli.c	/^    long long lru_test_sample_size;$/;"	m	struct:config	file:
lruclock	server.h	/^    redisAtomic unsigned int lruclock; \/* Clock for LRU eviction *\/$/;"	m	struct:redisServer
lsetCommand	t_list.c	/^void lsetCommand(client *c) {$/;"	f
ltrimCommand	t_list.c	/^void ltrimCommand(client *c) {$/;"	f
lua	server.h	/^    lua_State *lua; \/* The Lua interpreter. We use just one for all clients *\/$/;"	m	struct:redisServer
luaCreateFunction	scripting.c	/^sds luaCreateFunction(client *c, lua_State *lua, robj *body) {$/;"	f
luaLdbLineHook	scripting.c	/^void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {$/;"	f
luaLoadLib	scripting.c	/^void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {$/;"	f
luaLoadLibraries	scripting.c	/^void luaLoadLibraries(lua_State *lua) {$/;"	f
luaLogCommand	scripting.c	/^int luaLogCommand(lua_State *lua) {$/;"	f
luaMaskCountHook	scripting.c	/^void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {$/;"	f
luaPushError	scripting.c	/^void luaPushError(lua_State *lua, char *error) {$/;"	f
luaRaiseError	scripting.c	/^int luaRaiseError(lua_State *lua) {$/;"	f
luaRedisBreakpointCommand	scripting.c	/^int luaRedisBreakpointCommand(lua_State *lua) {$/;"	f
luaRedisCallCommand	scripting.c	/^int luaRedisCallCommand(lua_State *lua) {$/;"	f
luaRedisDebugCommand	scripting.c	/^int luaRedisDebugCommand(lua_State *lua) {$/;"	f
luaRedisErrorReplyCommand	scripting.c	/^int luaRedisErrorReplyCommand(lua_State *lua) {$/;"	f
luaRedisGenericCommand	scripting.c	/^int luaRedisGenericCommand(lua_State *lua, int raise_error) {$/;"	f
luaRedisPCallCommand	scripting.c	/^int luaRedisPCallCommand(lua_State *lua) {$/;"	f
luaRedisReplicateCommandsCommand	scripting.c	/^int luaRedisReplicateCommandsCommand(lua_State *lua) {$/;"	f
luaRedisReturnSingleFieldTable	scripting.c	/^int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {$/;"	f
luaRedisSetReplCommand	scripting.c	/^int luaRedisSetReplCommand(lua_State *lua) {$/;"	f
luaRedisSha1hexCommand	scripting.c	/^int luaRedisSha1hexCommand(lua_State *lua) {$/;"	f
luaRedisStatusReplyCommand	scripting.c	/^int luaRedisStatusReplyCommand(lua_State *lua) {$/;"	f
luaRemoveUnsupportedFunctions	scripting.c	/^void luaRemoveUnsupportedFunctions(lua_State *lua) {$/;"	f
luaReplyToRedisReply	scripting.c	/^void luaReplyToRedisReply(client *c, lua_State *lua) {$/;"	f
luaSetGlobalArray	scripting.c	/^void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {$/;"	f
luaSetResp	scripting.c	/^int luaSetResp(lua_State *lua) {$/;"	f
luaSortArray	scripting.c	/^void luaSortArray(lua_State *lua) {$/;"	f
lua_always_replicate_commands	server.h	/^    int lua_always_replicate_commands; \/* Default replication type. *\/$/;"	m	struct:redisServer
lua_caches	server.h	/^    size_t lua_caches;$/;"	m	struct:redisMemOverhead
lua_caller	server.h	/^    client *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	struct:redisServer
lua_client	server.h	/^    client *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	struct:redisServer
lua_cur_script	server.h	/^    char* lua_cur_script; \/* SHA1 of the script currently running, or NULL *\/$/;"	m	struct:redisServer
lua_kill	server.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	struct:redisServer
lua_multi_emitted	server.h	/^    int lua_multi_emitted;\/* True if we already propagated MULTI. *\/$/;"	m	struct:redisServer
lua_oom	server.h	/^    int lua_oom;          \/* OOM detected when script start? *\/$/;"	m	struct:redisServer
lua_random_dirty	server.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	struct:redisServer
lua_repl	server.h	/^    int lua_repl;         \/* Script replication flags for redis.set_repl(). *\/$/;"	m	struct:redisServer
lua_replicate_commands	server.h	/^    int lua_replicate_commands; \/* True if we are doing single commands repl. *\/$/;"	m	struct:redisServer
lua_scripts	server.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	struct:redisServer
lua_scripts_mem	server.h	/^    unsigned long long lua_scripts_mem;  \/* Cached scripts' memory + oh *\/$/;"	m	struct:redisServer
lua_time_limit	server.h	/^    mstime_t lua_time_limit;  \/* Script timeout in milliseconds *\/$/;"	m	struct:redisServer
lua_time_snapshot	server.h	/^    mstime_t lua_time_snapshot; \/* Snapshot of mstime when script is started *\/$/;"	m	struct:redisServer
lua_time_start	server.h	/^    monotime lua_time_start;  \/* monotonic timer to detect timed-out script *\/$/;"	m	struct:redisServer
lua_timedout	server.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	struct:redisServer
lua_write_dirty	server.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	struct:redisServer
luabp	scripting.c	/^    int luabp;  \/* Stop at next line because redis.breakpoint() was called. *\/$/;"	m	struct:ldbState	file:
lval	ziplist.h	/^    long long lval;$/;"	m	struct:__anon72
lwCanvas	lolwut.h	/^typedef struct lwCanvas {$/;"	s
lwCanvas	lolwut.h	/^} lwCanvas;$/;"	t	typeref:struct:lwCanvas
lwCreateCanvas	lolwut.c	/^lwCanvas *lwCreateCanvas(int width, int height, int bgcolor) {$/;"	f
lwDrawLine	lolwut.c	/^void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {$/;"	f
lwDrawPixel	lolwut.c	/^void lwDrawPixel(lwCanvas *canvas, int x, int y, int color) {$/;"	f
lwDrawSchotter	lolwut5.c	/^lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_col) {$/;"	f
lwDrawSquare	lolwut.c	/^void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle, int color) {$/;"	f
lwFreeCanvas	lolwut.c	/^void lwFreeCanvas(lwCanvas *canvas) {$/;"	f
lwGetPixel	lolwut.c	/^int lwGetPixel(lwCanvas *canvas, int x, int y) {$/;"	f
lwTranslatePixelsGroup	lolwut5.c	/^void lwTranslatePixelsGroup(int byte, char *output) {$/;"	f
lzf_compress	lzf_c.c	/^lzf_compress (const void *const in_data, unsigned int in_len,$/;"	f
lzf_decompress	lzf_d.c	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	f
lzf_movsb	lzf_d.c	48;"	d	file:
mad	latency.h	/^    uint32_t mad;           \/* Mean absolute deviation. *\/$/;"	m	struct:latencyStats
magic	hyperloglog.c	/^    char magic[4];      \/* "HYLL" *\/$/;"	m	struct:hllhdr	file:
main	crc64.c	/^int main(int argc, char *argv[]) {$/;"	f
main	localtime.c	/^int main(void) {$/;"	f
main	mt19937-64.c	/^int main(void)$/;"	f
main	redis-benchmark.c	/^int main(int argc, const char **argv) {$/;"	f
main	redis-cli.c	/^int main(int argc, char **argv) {$/;"	f
main	server.c	/^int main(int argc, char **argv) {$/;"	f
main	setproctitle.c	/^int main(int argc, char *argv[]) {$/;"	f
main	siphash.c	/^int main(void) {$/;"	f
main_thread_id	server.h	/^    pthread_t main_thread_id;         \/* Main thread id *\/$/;"	m	struct:redisServer
makeObjectShared	object.c	/^robj *makeObjectShared(robj *o) {$/;"	f
makeThreadKillable	server.c	/^void makeThreadKillable(void) {$/;"	f
mallctl_int	debug.c	/^void mallctl_int(client *c, robj **argv, int argc) {$/;"	f
mallctl_string	debug.c	/^void mallctl_string(client *c, robj **argv, int argc) {$/;"	f
malloc	zmalloc.c	70;"	d	file:
malloc	zmalloc.c	75;"	d	file:
malloc_stats	server.h	/^struct malloc_stats {$/;"	s
mallocx	zmalloc.c	79;"	d	file:
manualFailoverCheckTimeout	cluster.c	/^void manualFailoverCheckTimeout(void) {$/;"	f
markNodeAsFailingIfNeeded	cluster.c	/^void markNodeAsFailingIfNeeded(clusterNode *node) {$/;"	f
markdown	modules/gendoc.rb	/^def markdown(s)$/;"	f
mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE|BARRIER) *\/$/;"	m	struct:aeFileEvent
mask	ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
master	redismodule.h	/^    int master;             \/* true if master, false if replica *\/$/;"	m	struct:RedisModuleReplicationInfo
master	sentinel.c	/^    struct sentinelRedisInstance *master; \/* Master instance if it's slave. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:
master	server.h	/^    client *master;     \/* Client that is master for this slave *\/$/;"	m	struct:redisServer
masterTryPartialResynchronization	replication.c	/^int masterTryPartialResynchronization(client *c) {$/;"	f
master_fields_count	stream.h	/^    uint64_t master_fields_count;       \/* Master entries # of fields. *\/$/;"	m	struct:streamIterator
master_fields_ptr	stream.h	/^    unsigned char *master_fields_ptr;   \/* Master field to emit next. *\/$/;"	m	struct:streamIterator
master_fields_start	stream.h	/^    unsigned char *master_fields_start; \/* Master entries start in listpack. *\/$/;"	m	struct:streamIterator
master_id	module.c	/^    char master_id[40]; \/* Only if flags & REDISMODULE_NODE_MASTER is true. *\/$/;"	m	struct:moduleClusterNodeInfo	file:
master_id	redis-cli.c	/^    char *master_id;$/;"	m	struct:clusterManagerCommand	file:
master_id	stream.h	/^    streamID master_id;     \/* ID of the master entry at listpack head. *\/$/;"	m	struct:streamIterator
master_initial_offset	server.h	/^    long long master_initial_offset;           \/* Master PSYNC offset. *\/$/;"	m	struct:redisServer
master_link_down_time	sentinel.c	/^    mstime_t master_link_down_time; \/* Slave replication link down time. *\/$/;"	m	struct:sentinelRedisInstance	file:
master_repl_offset	server.h	/^    long long master_repl_offset;   \/* My current replication offset *\/$/;"	m	struct:redisServer
master_replid	server.h	/^    char master_replid[CONFIG_RUN_ID_SIZE+1];  \/* Master PSYNC runid. *\/$/;"	m	struct:redisServer
masterauth	server.h	/^    sds masterauth;                 \/* AUTH with this password with master *\/$/;"	m	struct:redisServer
masterdownerr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
masterhost	redismodule.h	/^    char *masterhost;       \/* master instance hostname for NOW_REPLICA *\/$/;"	m	struct:RedisModuleReplicationInfo
masterhost	server.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	struct:redisServer
masterport	redismodule.h	/^    int masterport;         \/* master instance port for NOW_REPLICA *\/$/;"	m	struct:RedisModuleReplicationInfo
masterport	server.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	struct:redisServer
masters	sentinel.c	/^    dict *masters;      \/* Dictionary of master sentinelRedisInstances.$/;"	m	struct:sentinelState	file:
masteruser	server.h	/^    char *masteruser;               \/* AUTH with this user and masterauth with master *\/$/;"	m	struct:redisServer
match	adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list
max	geohash.h	/^    double max;$/;"	m	struct:__anon21
max	latency.h	/^    uint32_t max;           \/* Max of current samples. *\/$/;"	m	struct:latencyStats
max	latency.h	/^    uint32_t max; \/* Max latency observed for this event. *\/$/;"	m	struct:latencyTimeSeries
max	redis-cli.c	/^    long long max;   \/* Max latency to fit into this interval (usec). *\/$/;"	m	struct:distsamples	file:
max	server.h	/^    double min, max;$/;"	m	struct:__anon54
max	server.h	/^    sds min, max;     \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon55
max	sparkline.h	/^    double min, max;$/;"	m	struct:sequence
max_processing_chunk	rio.h	/^    size_t max_processing_chunk;$/;"	m	struct:_rio
maxclients	server.h	/^    unsigned int maxclients;            \/* Max number of simultaneous clients *\/$/;"	m	struct:redisServer
maxex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon54
maxex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon55
maxfd	ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	struct:aeEventLoop
maxidletime	server.h	/^    int maxidletime;                \/* Client timeout in seconds *\/$/;"	m	struct:redisServer
maxitems	rax.h	/^    size_t items, maxitems; \/* Number of items contained and total space. *\/$/;"	m	struct:raxStack
maxlen	scripting.c	/^    size_t maxlen;  \/* Max var dump \/ reply length. *\/$/;"	m	struct:ldbState	file:
maxlen	t_stream.c	/^    long long maxlen; \/* After trimming, leave stream at this length . *\/$/;"	m	struct:__anon59	file:
maxlen_hint_sent	scripting.c	/^    int maxlen_hint_sent; \/* Did we already hint about "set maxlen"? *\/$/;"	m	struct:ldbState	file:
maxmemory	server.h	/^    unsigned long long maxmemory;   \/* Max number of memory bytes to use *\/$/;"	m	struct:redisServer
maxmemory_eviction_tenacity	server.h	/^    int maxmemory_eviction_tenacity;\/* Aggressiveness of eviction processing *\/$/;"	m	struct:redisServer
maxmemory_policy	server.h	/^    int maxmemory_policy;           \/* Policy for key eviction *\/$/;"	m	struct:redisServer
maxmemory_policy_enum	config.c	/^configEnum maxmemory_policy_enum[] = {$/;"	v
maxmemory_samples	server.h	/^    int maxmemory_samples;          \/* Precision of random sampling *\/$/;"	m	struct:redisServer
maxstring	server.h	/^    sds minstring, maxstring;$/;"	m	struct:sharedObjectsStruct
mb_delim	redis-cli.c	/^    sds mb_delim;$/;"	m	struct:config	file:
mbulkhdr	server.h	/^    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct
mdouleClusterNodeInfo	module.c	/^} mdouleClusterNodeInfo;$/;"	t	typeref:struct:moduleClusterNodeInfo	file:
med3	pqsort.c	/^med3(char *a, char *b, char *c,$/;"	f	file:
mem_usage	redismodule.h	/^    RedisModuleTypeMemUsageFunc mem_usage;$/;"	m	struct:RedisModuleTypeMethods
mem_usage	server.h	/^    moduleTypeMemUsageFunc mem_usage;$/;"	m	struct:RedisModuleType
member	geo.h	/^    char *member;$/;"	m	struct:geoPoint
membersOfAllNeighbors	geo.c	/^int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, GeoShape *shape, geoArray *ga, unsigned long limit) {$/;"	f
membersOfGeoHashBox	geo.c	/^int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, GeoShape *shape, unsigned long limit) {$/;"	f
memcheck_enabled	server.h	/^    int memcheck_enabled;           \/* Enable memory check on crash. *\/$/;"	m	struct:redisServer
memkeys	redis-cli.c	/^    int memkeys;$/;"	m	struct:config	file:
memkeys_samples	redis-cli.c	/^    unsigned memkeys_samples;$/;"	m	struct:config	file:
memmapchars	util.c	/^char *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen) {$/;"	f
memory	module.c	/^    char memory[];$/;"	m	struct:RedisModulePoolAllocBlock	file:
memoryCommand	object.c	/^void memoryCommand(client *c) {$/;"	f
memoryGetKeys	db.c	/^int memoryGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
mempbrk	util.c	/^const char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen) {$/;"	f
memrev16	endianconv.c	/^void memrev16(void *p) {$/;"	f
memrev16ifbe	endianconv.h	49;"	d
memrev16ifbe	endianconv.h	56;"	d
memrev32	endianconv.c	/^void memrev32(void *p) {$/;"	f
memrev32ifbe	endianconv.h	50;"	d
memrev32ifbe	endianconv.h	57;"	d
memrev64	endianconv.c	/^void memrev64(void *p) {$/;"	f
memrev64ifbe	endianconv.h	51;"	d
memrev64ifbe	endianconv.h	58;"	d
memtest	memtest.c	/^void memtest(size_t megabytes, int passes) {$/;"	f
memtest_addressing	memtest.c	/^int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {$/;"	f
memtest_alloc_and_test	memtest.c	/^void memtest_alloc_and_test(size_t megabytes, int passes) {$/;"	f
memtest_compare	memtest.c	/^int memtest_compare(unsigned long *l, size_t bytes, int interactive) {$/;"	f
memtest_compare_times	memtest.c	/^int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,$/;"	f
memtest_fill_random	memtest.c	/^void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {$/;"	f
memtest_fill_value	memtest.c	/^void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,$/;"	f
memtest_preserving_test	memtest.c	/^int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {$/;"	f
memtest_progress_end	memtest.c	/^void memtest_progress_end(void) {$/;"	f
memtest_progress_start	memtest.c	/^void memtest_progress_start(char *title, int pass) {$/;"	f
memtest_progress_step	memtest.c	/^void memtest_progress_step(size_t curr, size_t size, char c) {$/;"	f
memtest_test	memtest.c	/^int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {$/;"	f
memtest_test_linux_anonymous_maps	debug.c	/^int memtest_test_linux_anonymous_maps(void) {$/;"	f
memtoll	util.c	/^long long memtoll(const char *p, int *err) {$/;"	f
message_len	cluster.h	/^    uint32_t message_len;$/;"	m	struct:__anon4
messagebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
mf_can_start	cluster.h	/^    int mf_can_start;           \/* If non-zero signal that the manual failover$/;"	m	struct:clusterState
mf_end	cluster.h	/^    mstime_t mf_end;            \/* Manual failover time limit (ms unixtime).$/;"	m	struct:clusterState
mf_master_offset	cluster.h	/^    long long mf_master_offset; \/* Master offset the slave needs to start MF$/;"	m	struct:clusterState
mf_slave	cluster.h	/^    clusterNode *mf_slave;      \/* Slave performing the manual failover. *\/$/;"	m	struct:clusterState
mflags	cluster.h	/^    unsigned char mflags[3]; \/* Message flags: CLUSTERMSG_FLAG[012]_... *\/$/;"	m	struct:__anon12
mgetCommand	t_string.c	/^void mgetCommand(client *c) {$/;"	f
microseconds	server.h	/^    long long microseconds, calls, rejected_calls, failed_calls;$/;"	m	struct:redisCommand
migrateCacheDictType	server.c	/^dictType migrateCacheDictType = {$/;"	v
migrateCachedSocket	cluster.c	/^typedef struct migrateCachedSocket {$/;"	s	file:
migrateCachedSocket	cluster.c	/^} migrateCachedSocket;$/;"	t	typeref:struct:migrateCachedSocket	file:
migrateCloseSocket	cluster.c	/^void migrateCloseSocket(robj *host, robj *port) {$/;"	f
migrateCloseTimedoutSockets	cluster.c	/^void migrateCloseTimedoutSockets(void) {$/;"	f
migrateCommand	cluster.c	/^void migrateCommand(client *c) {$/;"	f
migrateGetKeys	db.c	/^int migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
migrateGetSocket	cluster.c	/^migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {$/;"	f
migrate_cached_sockets	server.h	/^    dict *migrate_cached_sockets;\/* MIGRATE cached sockets *\/$/;"	m	struct:redisServer
migrating	redis-benchmark.c	/^    sds *migrating; \/* An array of sds where even strings are slots and odd$/;"	m	struct:clusterNode	file:
migrating	redis-cli.c	/^    sds *migrating; \/* An array of sds where even strings are slots and odd$/;"	m	struct:clusterManagerNode	file:
migrating_count	redis-benchmark.c	/^    int migrating_count; \/* Length of the migrating array (migrating slots*2) *\/$/;"	m	struct:clusterNode	file:
migrating_count	redis-cli.c	/^    int migrating_count; \/* Length of the migrating array (migrating slots*2) *\/$/;"	m	struct:clusterManagerNode	file:
migrating_slots_to	cluster.h	/^    clusterNode *migrating_slots_to[CLUSTER_SLOTS];$/;"	m	struct:clusterState
min	geohash.h	/^    double min;$/;"	m	struct:__anon21
min	latency.h	/^    uint32_t min;           \/* Min of current samples. *\/$/;"	m	struct:latencyStats
min	pqsort.c	49;"	d	file:
min	server.h	/^    double min, max;$/;"	m	struct:__anon54
min	server.h	/^    sds min, max;     \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon55
min	sparkline.h	/^    double min, max;$/;"	m	struct:sequence
minex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon54
minex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon55
minid	t_stream.c	/^    streamID minid; \/* Trim by ID (No stream entries with ID < 'minid' will remain) *\/$/;"	m	struct:__anon59	file:
minstring	server.h	/^    sds minstring, maxstring;$/;"	m	struct:sharedObjectsStruct
mixDigest	debug.c	/^void mixDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f
mixStringObjectDigest	debug.c	/^void mixStringObjectDigest(unsigned char *digest, robj *o) {$/;"	f
mode	module.c	/^    int mode;       \/* Opening mode. *\/$/;"	m	struct:RedisModuleKey	file:
module	cluster.h	/^    } module;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon11
module	module.c	/^    RedisModule *module;                \/* Module reference. *\/$/;"	m	struct:RedisModuleTimer	file:
module	module.c	/^    RedisModule *module;    \/* Module blocking the client. *\/$/;"	m	struct:RedisModuleBlockedClient	file:
module	module.c	/^    RedisModule *module;$/;"	m	struct:RedisModuleCommandFilter	file:
module	module.c	/^    RedisModule *module;$/;"	m	struct:RedisModuleEventListener	file:
module	module.c	/^    RedisModule *module;$/;"	m	struct:RedisModuleKeyspaceSubscriber	file:
module	module.c	/^    RedisModule *module;$/;"	m	struct:RedisModuleSharedAPI	file:
module	module.c	/^    struct RedisModule *module;     \/* Module reference. *\/$/;"	m	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModule	file:
module	module.c	/^    struct RedisModule *module;$/;"	m	struct:RedisModuleCommandProxy	typeref:struct:RedisModuleCommandProxy::RedisModule	file:
module	module.c	/^    struct RedisModule *module;$/;"	m	struct:RedisModuleInfoCtx	typeref:struct:RedisModuleInfoCtx::RedisModule	file:
module	module.c	/^    struct RedisModule *module;$/;"	m	struct:moduleClusterReceiver	typeref:struct:moduleClusterReceiver::RedisModule	file:
module	server.h	/^    struct RedisModule *module;$/;"	m	struct:RedisModuleType	typeref:struct:RedisModuleType::RedisModule
moduleAPIDictType	module.c	/^dictType moduleAPIDictType = {$/;"	v
moduleAcquireGIL	module.c	/^void moduleAcquireGIL(void) {$/;"	f
moduleAllDatatypesHandleErrors	module.c	/^int moduleAllDatatypesHandleErrors() {$/;"	f
moduleAssertUnsharedString	module.c	/^RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {$/;"	f
moduleBlockClient	module.c	/^RedisModuleBlockedClient *moduleBlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) {$/;"	f
moduleBlockedClientPipeReadable	module.c	/^void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
moduleBlockedClientTimedOut	module.c	/^void moduleBlockedClientTimedOut(client *c) {$/;"	f
moduleCallClusterReceivers	module.c	/^void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {$/;"	f
moduleCallCommandFilters	module.c	/^void moduleCallCommandFilters(client *c) {$/;"	f
moduleClientIsBlockedOnKeys	module.c	/^int moduleClientIsBlockedOnKeys(client *c) {$/;"	f
moduleCloseKey	module.c	/^static void moduleCloseKey(RedisModuleKey *key) {$/;"	f	file:
moduleClusterNodeInfo	module.c	/^typedef struct moduleClusterNodeInfo {$/;"	s	file:
moduleClusterReceiver	module.c	/^typedef struct moduleClusterReceiver {$/;"	s	file:
moduleClusterReceiver	module.c	/^} moduleClusterReceiver;$/;"	t	typeref:struct:moduleClusterReceiver	file:
moduleCommand	module.c	/^void moduleCommand(client *c) {$/;"	f
moduleCommandFilters	module.c	/^static list *moduleCommandFilters;$/;"	v	file:
moduleCount	module.c	/^size_t moduleCount(void) {$/;"	f
moduleCreateArgvFromUserFormat	module.c	/^robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {$/;"	f
moduleCreateCallReplyFromProto	module.c	/^RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {$/;"	f
moduleCreateEmptyKey	module.c	/^int moduleCreateEmptyKey(RedisModuleKey *key, int type) {$/;"	f
moduleDefragGlobals	module.c	/^long moduleDefragGlobals(void) {$/;"	f
moduleDefragValue	module.c	/^int moduleDefragValue(robj *key, robj *value, long *defragged) {$/;"	f
moduleDelKeyIfEmpty	module.c	/^int moduleDelKeyIfEmpty(RedisModuleKey *key) {$/;"	f
moduleFireServerEvent	module.c	/^void moduleFireServerEvent(uint64_t eid, int subid, void *data) {$/;"	f
moduleForkInfo	module.c	/^} moduleForkInfo = {0};$/;"	v	typeref:struct:RedisModuleForkInfo	file:
moduleFreeAuthenticatedClients	module.c	/^static void moduleFreeAuthenticatedClients(RedisModule *module) {$/;"	f	file:
moduleFreeCallReplyRec	module.c	/^void moduleFreeCallReplyRec(RedisModuleCallReply *reply, int freenested){$/;"	f
moduleFreeContext	module.c	/^void moduleFreeContext(RedisModuleCtx *ctx) {$/;"	f
moduleFreeContextReusedClient	module.c	/^static client *moduleFreeContextReusedClient;$/;"	v	file:
moduleFreeModuleStructure	module.c	/^void moduleFreeModuleStructure(struct RedisModule *module) {$/;"	f
moduleGIL	module.c	/^static pthread_mutex_t moduleGIL = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
moduleGetCommandKeysViaAPI	module.c	/^int moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
moduleGetReplyClient	module.c	/^client *moduleGetReplyClient(RedisModuleCtx *ctx) {$/;"	f
moduleHandleBlockedClients	module.c	/^void moduleHandleBlockedClients(void) {$/;"	f
moduleHandlePropagationAfterCommandCallback	module.c	/^void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {$/;"	f
moduleInitDigestContext	server.h	647;"	d
moduleInitIOContext	server.h	626;"	d
moduleInitKey	module.c	/^static void moduleInitKey(RedisModuleKey *kp, RedisModuleCtx *ctx, robj *keyname, robj *value, int mode){$/;"	f	file:
moduleInitKeyTypeSpecific	module.c	/^static void moduleInitKeyTypeSpecific(RedisModuleKey *key) {$/;"	f	file:
moduleInitModulesSystem	module.c	/^void moduleInitModulesSystem(void) {$/;"	f
moduleInitModulesSystemLast	module.c	/^void moduleInitModulesSystemLast(void) {$/;"	f
moduleKeyspaceSubscribers	module.c	/^static list *moduleKeyspaceSubscribers;$/;"	v	file:
moduleLateDefrag	module.c	/^int moduleLateDefrag(robj *key, robj *value, unsigned long *cursor, long long endtime, long long *defragged) {$/;"	f
moduleLoad	module.c	/^int moduleLoad(const char *path, void **module_argv, int module_argc) {$/;"	f
moduleLoadFromQueue	module.c	/^void moduleLoadFromQueue(void) {$/;"	f
moduleLoadQueueEntry	server.h	/^struct moduleLoadQueueEntry {$/;"	s
moduleLoadString	module.c	/^void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {$/;"	f
moduleLogRaw	module.c	/^void moduleLogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {$/;"	f
moduleNotifyKeyUnlink	module.c	/^void moduleNotifyKeyUnlink(robj *key, robj *val) {$/;"	f
moduleNotifyKeyspaceEvent	module.c	/^void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {$/;"	f
moduleNotifyUserChanged	module.c	/^void moduleNotifyUserChanged(client *c) {$/;"	f
moduleParseCallReply	module.c	/^void moduleParseCallReply(RedisModuleCallReply *reply) {$/;"	f
moduleParseCallReply_Array	module.c	/^void moduleParseCallReply_Array(RedisModuleCallReply *reply) {$/;"	f
moduleParseCallReply_BulkString	module.c	/^void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {$/;"	f
moduleParseCallReply_Int	module.c	/^void moduleParseCallReply_Int(RedisModuleCallReply *reply) {$/;"	f
moduleParseCallReply_SimpleString	module.c	/^void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {$/;"	f
modulePopulateClientInfoStructure	module.c	/^int modulePopulateClientInfoStructure(void *ci, client *client, int structver) {$/;"	f
modulePopulateReplicationInfoStructure	module.c	/^int modulePopulateReplicationInfoStructure(void *ri, int structver) {$/;"	f
moduleRDBLoadError	module.c	/^void moduleRDBLoadError(RedisModuleIO *io) {$/;"	f
moduleRegisterApi	module.c	/^int moduleRegisterApi(const char *funcname, void *funcptr) {$/;"	f
moduleRegisterCoreAPI	module.c	/^void moduleRegisterCoreAPI(void) {$/;"	f
moduleReleaseGIL	module.c	/^void moduleReleaseGIL(void) {$/;"	f
moduleReplicateMultiIfNeeded	module.c	/^void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {$/;"	f
moduleScanCallback	module.c	/^static void moduleScanCallback(void *privdata, const dictEntry *de) {$/;"	f	file:
moduleScanKeyCallback	module.c	/^static void moduleScanKeyCallback(void *privdata, const dictEntry *de) {$/;"	f	file:
moduleTimerHandler	module.c	/^int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f
moduleTryAcquireGIL	module.c	/^int moduleTryAcquireGIL(void) {$/;"	f
moduleTryServeClientBlockedOnKey	module.c	/^int moduleTryServeClientBlockedOnKey(client *c, robj *key) {$/;"	f
moduleType	server.h	/^} moduleType;$/;"	t	typeref:struct:RedisModuleType
moduleTypeAuxLoadFunc	server.h	/^typedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);$/;"	t
moduleTypeAuxSaveFunc	server.h	/^typedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);$/;"	t
moduleTypeCopyFunc	server.h	/^typedef void *(*moduleTypeCopyFunc)(struct redisObject *fromkey, struct redisObject *tokey, const void *value);$/;"	t
moduleTypeDefragFunc	server.h	/^typedef int (*moduleTypeDefragFunc)(struct RedisModuleDefragCtx *ctx, struct redisObject *key, void **value);$/;"	t
moduleTypeDigestFunc	server.h	/^typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);$/;"	t
moduleTypeDupOrReply	module.c	/^robj *moduleTypeDupOrReply(client *c, robj *fromkey, robj *tokey, robj *value) {$/;"	f
moduleTypeEncodeId	module.c	/^uint64_t moduleTypeEncodeId(const char *name, int encver) {$/;"	f
moduleTypeFreeEffortFunc	server.h	/^typedef size_t (*moduleTypeFreeEffortFunc)(struct redisObject *key, const void *value);$/;"	t
moduleTypeFreeFunc	server.h	/^typedef void (*moduleTypeFreeFunc)(void *value);$/;"	t
moduleTypeLoadFunc	server.h	/^typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);$/;"	t
moduleTypeLookupModuleByID	module.c	/^moduleType *moduleTypeLookupModuleByID(uint64_t id) {$/;"	f
moduleTypeLookupModuleByName	module.c	/^moduleType *moduleTypeLookupModuleByName(const char *name) {$/;"	f
moduleTypeMemUsageFunc	server.h	/^typedef size_t (*moduleTypeMemUsageFunc)(const void *value);$/;"	t
moduleTypeModuleName	module.c	/^const char *moduleTypeModuleName(moduleType *mt) {$/;"	f
moduleTypeNameByID	module.c	/^void moduleTypeNameByID(char *name, uint64_t moduleid) {$/;"	f
moduleTypeRewriteFunc	server.h	/^typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);$/;"	t
moduleTypeSaveFunc	server.h	/^typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);$/;"	t
moduleTypeUnlinkFunc	server.h	/^typedef void (*moduleTypeUnlinkFunc)(struct redisObject *key, void *value);$/;"	t
moduleUnblockClient	module.c	/^void moduleUnblockClient(client *c) {$/;"	f
moduleUnblockClientByHandle	module.c	/^int moduleUnblockClientByHandle(RedisModuleBlockedClient *bc, void *privdata) {$/;"	f
moduleUnblockedClients	module.c	/^static list *moduleUnblockedClients;$/;"	v	file:
moduleUnblockedClientsMutex	module.c	/^static pthread_mutex_t moduleUnblockedClientsMutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
moduleUnload	module.c	/^int moduleUnload(sds name) {$/;"	f
moduleUnregisterCommands	module.c	/^void moduleUnregisterCommands(struct RedisModule *module) {$/;"	f
moduleUnregisterFilters	module.c	/^int moduleUnregisterFilters(RedisModule *module) {$/;"	f
moduleUnregisterSharedAPI	module.c	/^int moduleUnregisterSharedAPI(RedisModule *module) {$/;"	f
moduleUnregisterUsedAPI	module.c	/^int moduleUnregisterUsedAPI(RedisModule *module) {$/;"	f
moduleUnsubscribeAllServerEvents	module.c	/^void moduleUnsubscribeAllServerEvents(RedisModule *module) {$/;"	f
moduleUnsubscribeNotifications	module.c	/^void moduleUnsubscribeNotifications(RedisModule *module) {$/;"	f
moduleValue	server.h	/^typedef struct moduleValue {$/;"	s
moduleValue	server.h	/^} moduleValue;$/;"	t	typeref:struct:moduleValue
moduleZsetAddFlagsFromCoreFlags	module.c	/^int moduleZsetAddFlagsFromCoreFlags(int flags) {$/;"	f
moduleZsetAddFlagsToCoreFlags	module.c	/^int moduleZsetAddFlagsToCoreFlags(int flags) {$/;"	f
module_blocked_handle	server.h	/^    void *module_blocked_handle; \/* RedisModuleBlockedClient structure.$/;"	m	struct:blockingState
module_blocked_pipe	server.h	/^    int module_blocked_pipe[2]; \/* Pipe used to awake the event loop if a$/;"	m	struct:redisServer
module_client	server.h	/^    client *module_client;      \/* "Fake" client to call Redis from modules *\/$/;"	m	struct:redisServer
module_id	cluster.h	/^    uint64_t module_id;     \/* ID of the sender module. *\/$/;"	m	struct:__anon6
module_id	module.c	/^    uint64_t module_id;$/;"	m	struct:moduleClusterReceiver	file:
module_name	redismodule.h	/^    const char* module_name;\/* Name of module loaded or unloaded. *\/$/;"	m	struct:RedisModuleModuleChange
module_version	redismodule.h	/^    int32_t module_version; \/* Module version. *\/$/;"	m	struct:RedisModuleModuleChange
moduleapi	server.h	/^    dict *moduleapi;            \/* Exported core APIs dictionary for modules. *\/$/;"	m	struct:redisServer
modules	module.c	/^static dict *modules; \/* Hash table of modules. SDS -> RedisModule ptr.*\/$/;"	v	file:
modulesCollectInfo	module.c	/^sds modulesCollectInfo(sds info, const char *section, int for_crash_report, int sections) {$/;"	f
modulesDictType	server.c	/^dictType modulesDictType = {$/;"	v
monitorCommand	server.c	/^void monitorCommand(client *c) {$/;"	f
monitor_cfg	server.h	/^    list *monitor_cfg;$/;"	m	struct:sentinelConfig
monitor_mode	redis-cli.c	/^    int monitor_mode;$/;"	m	struct:config	file:
monitors	server.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer
mono_ticksPerMicrosecond	monotonic.c	/^static long mono_ticksPerMicrosecond = 0;$/;"	v	file:
monotime	monotonic.h	/^typedef uint64_t monotime;$/;"	t
monotonicInit	monotonic.c	/^const char * monotonicInit() {$/;"	f
monotonicInit_aarch64	monotonic.c	/^static void monotonicInit_aarch64() {$/;"	f	file:
monotonicInit_posix	monotonic.c	/^static void monotonicInit_posix() {$/;"	f	file:
monotonicInit_x86linux	monotonic.c	/^static void monotonicInit_x86linux() {$/;"	f	file:
monotonic_info_string	monotonic.c	/^static char monotonic_info_string[32];$/;"	v	file:
moveCommand	db.c	/^void moveCommand(client *c) {$/;"	f
ms	redismodule.h	/^    uint64_t ms;$/;"	m	struct:RedisModuleStreamID
ms	stream.h	/^    uint64_t ms;        \/* Unix time in milliseconds. *\/$/;"	m	struct:streamID
msetCommand	t_string.c	/^void msetCommand(client *c) {$/;"	f
msetGenericCommand	t_string.c	/^void msetGenericCommand(client *c, int nx) {$/;"	f
msetnxCommand	t_string.c	/^void msetnxCommand(client *c) {$/;"	f
msg	cluster.h	/^        clusterMsgDataPublish msg;$/;"	m	struct:clusterMsgData::__anon9
msg	cluster.h	/^        clusterMsgModule msg;$/;"	m	struct:clusterMsgData::__anon11
mstate	server.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	struct:client
mstime	quicklist.c	/^static long long mstime(void) { return ustime() \/ 1000; }$/;"	f	file:
mstime	redis-benchmark.c	/^static long long mstime(void) {$/;"	f	file:
mstime	redis-cli.c	/^static long long mstime(void) {$/;"	f	file:
mstime	server.c	/^mstime_t mstime(void) {$/;"	f
mstime	server.h	/^    mstime_t mstime;            \/* 'unixtime' in milliseconds. *\/$/;"	m	struct:redisServer
mstime_t	redismodule.h	/^typedef long long mstime_t;$/;"	t
mstime_t	server.h	/^typedef long long mstime_t; \/* millisecond time type. *\/$/;"	t
mt	mt19937-64.c	/^static unsigned long long mt[NN];$/;"	v	file:
mti	mt19937-64.c	/^static int mti=NN+1;$/;"	v	file:
multi	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
multiCmd	server.h	/^typedef struct multiCmd {$/;"	s
multiCmd	server.h	/^} multiCmd;$/;"	t	typeref:struct:multiCmd
multiCommand	multi.c	/^void multiCommand(client *c) {$/;"	f
multiCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
multiState	server.h	/^typedef struct multiState {$/;"	s
multiState	server.h	/^} multiState;$/;"	t	typeref:struct:multiState
multibulklen	server.h	/^    int multibulklen;       \/* Number of multi bulk arguments left to read. *\/$/;"	m	struct:client
myid	sentinel.c	/^    char myid[CONFIG_RUN_ID_SIZE+1]; \/* This sentinel ID. *\/$/;"	m	struct:sentinelState	file:
myip	cluster.h	/^    char myip[NET_IP_STR_LEN];    \/* Sender IP, if not all zeroed. *\/$/;"	m	struct:__anon12
myself	cluster.c	/^clusterNode *myself = NULL;$/;"	v
myself	cluster.h	/^    clusterNode *myself;  \/* This node *\/$/;"	m	struct:clusterState
myslots	cluster.h	/^    unsigned char myslots[CLUSTER_SLOTS\/8];$/;"	m	struct:__anon12
name	acl.c	/^    const char *name;$/;"	m	struct:ACLCategoryItem	file:
name	acl.c	/^    const char *name;$/;"	m	struct:ACLUserFlag	file:
name	cluster.c	/^    char *name;$/;"	m	struct:redisNodeFlags	file:
name	cluster.h	/^    char name[CLUSTER_NAMELEN]; \/* Node name, hex string, sha1-size *\/$/;"	m	struct:clusterNode
name	config.c	/^    const char *name; \/* The user visible name of this config *\/$/;"	m	struct:standardConfig	file:
name	config.c	/^    const char *name;$/;"	m	struct:configEnum	file:
name	help.h	/^  char *name;$/;"	m	struct:commandHelp
name	module.c	/^    char *name;     \/* Module name. *\/$/;"	m	struct:RedisModule	file:
name	quicklist.h	/^    char *name;$/;"	m	struct:quicklistBookmark
name	redis-benchmark.c	/^    sds name;$/;"	m	struct:clusterNode	file:
name	redis-cli.c	/^    char *name;$/;"	m	struct:__anon36	file:
name	redis-cli.c	/^    char *name;$/;"	m	struct:clusterManagerCommand	file:
name	redis-cli.c	/^    char *name;$/;"	m	struct:clusterManagerCommandDef	file:
name	redis-cli.c	/^    char *name;$/;"	m	struct:clusterManagerOptionDef	file:
name	redis-cli.c	/^    sds name;$/;"	m	struct:clusterManagerNode	file:
name	sentinel.c	/^    char *name;     \/* Master name from the point of view of this sentinel. *\/$/;"	m	struct:sentinelRedisInstance	file:
name	server.c	/^    char *name;$/;"	m	struct:redisTest	file:
name	server.h	/^    char *name;$/;"	m	struct:redisCommand
name	server.h	/^    char *name;$/;"	m	struct:redisFunctionSym
name	server.h	/^    char name[10]; \/* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- *\/$/;"	m	struct:RedisModuleType
name	server.h	/^    robj *name;             \/* As set by CLIENT SETNAME. *\/$/;"	m	struct:client
name	server.h	/^    sds name;       \/* The username as an SDS string. *\/$/;"	m	struct:__anon45
name	stream.h	/^    sds name;                   \/* Consumer name. This is how the consumer$/;"	m	struct:streamConsumer
neighbors	geohash_helper.h	/^    GeoHashNeighbors neighbors;$/;"	m	struct:__anon27
neterr	server.h	/^    char neterr[ANET_ERR_LEN];   \/* Error buffer for anet.c *\/$/;"	m	struct:redisServer
next	adlist.h	/^    listNode *next;$/;"	m	struct:listIter
next	adlist.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
next	dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry
next	module.c	/^    struct RedisModulePoolAllocBlock *next;$/;"	m	struct:RedisModulePoolAllocBlock	typeref:struct:RedisModulePoolAllocBlock::RedisModulePoolAllocBlock	file:
next	module.c	/^    struct moduleClusterReceiver *next;$/;"	m	struct:moduleClusterReceiver	typeref:struct:moduleClusterReceiver::moduleClusterReceiver	file:
next	modules/hellotype.c	/^    struct HelloTypeNode *next;$/;"	m	struct:HelloTypeNode	typeref:struct:HelloTypeNode::HelloTypeNode	file:
next	quicklist.h	/^    struct quicklistNode *next;$/;"	m	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode
next	rand.c	/^static void next(void) {$/;"	f	file:
nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
next_client_id	server.h	/^    redisAtomic uint64_t next_client_id; \/* Next client unique ID. Incremental. *\/$/;"	m	struct:redisServer
next_num	setcpuaffinity.c	/^static int next_num(const char *str, char **end, int *result) {$/;"	f	file:
next_token	setcpuaffinity.c	/^static const char *next_token(const char *q,  int sep) {$/;"	f	file:
nextid	acl.c	/^static unsigned long nextid = 0; \/* Next command id that has not been assigned *\/$/;"	v	file:
no_auth_warning	redis-cli.c	/^    int no_auth_warning;$/;"	m	struct:config	file:
no_mkstream	t_stream.c	/^    int no_mkstream; \/* if set to 1 do not create new stream *\/$/;"	m	struct:__anon59	file:
noautherr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
node	cluster.h	/^    struct clusterNode *node;   \/* Node related to this link if any, or NULL *\/$/;"	m	struct:clusterLink	typeref:struct:clusterLink::clusterNode
node	cluster.h	/^    struct clusterNode *node;  \/* Node reporting the failure condition. *\/$/;"	m	struct:clusterNodeFailReport	typeref:struct:clusterNodeFailReport::clusterNode
node	quicklist.h	/^    quicklistNode *node;$/;"	m	struct:quicklistBookmark
node	quicklist.h	/^    quicklistNode *node;$/;"	m	struct:quicklistEntry
node	rax.h	/^    raxNode *node;          \/* Current node. Only for unsafe iteration. *\/$/;"	m	struct:raxIterator
node	t_zset.c	/^                zskiplistNode *node;$/;"	m	struct:__anon61::__anon62::_iterzset::__anon66	file:
nodeCantFailover	cluster.h	67;"	d
nodeFailed	cluster.h	66;"	d
nodeHasAddr	cluster.h	63;"	d
nodeInHandshake	cluster.h	62;"	d
nodeIp2String	cluster.c	/^void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {$/;"	f
nodeIsMaster	cluster.h	60;"	d
nodeIsSlave	cluster.h	61;"	d
nodeTimedOut	cluster.h	65;"	d
nodeUpdateAddressIfNeeded	cluster.c	/^int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,$/;"	f
nodeWithoutAddr	cluster.h	64;"	d
node_addr	redis-cli.c	/^    sds node_addr;$/;"	m	struct:clusterManagerLink	file:
node_cb	rax.h	/^    raxNodeCallback node_cb; \/* Optional node callback. Normally set to NULL. *\/$/;"	m	struct:raxIterator
node_name	redis-cli.c	/^    sds node_name;$/;"	m	struct:clusterManagerLink	file:
nodecfg	cluster.h	/^        clusterMsgDataUpdate nodecfg;$/;"	m	struct:clusterMsgData::__anon10
nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN]; \/* Name of the slots owner. *\/$/;"	m	struct:__anon5
nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN];$/;"	m	struct:__anon2
nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN];$/;"	m	struct:__anon3
nodes	cluster.h	/^    dict *nodes;          \/* Hash table of name -> clusterNode structures *\/$/;"	m	struct:clusterState
nodes	redis-cli.c	/^    clusterManagerNode **nodes; \/* Actual nodes array *\/$/;"	m	struct:clusterManagerNodeArray	file:
nodes	redis-cli.c	/^    list *nodes;    \/* List of nodes in the configuration. *\/$/;"	m	struct:clusterManager	file:
nodes_black_list	cluster.h	/^    dict *nodes_black_list; \/* Nodes we don't re-add for a few seconds. *\/$/;"	m	struct:clusterState
nokeyerr	server.h	/^    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
nolocks_localtime	localtime.c	/^void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {$/;"	f
noninteractive	redis-cli.c	/^static int noninteractive(int argc, char **argv) {$/;"	f	file:
noreplicaserr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
north	geohash.h	/^    GeoHashBits north;$/;"	m	struct:__anon23
north_east	geohash.h	/^    GeoHashBits north_east;$/;"	m	struct:__anon23
north_west	geohash.h	/^    GeoHashBits north_west;$/;"	m	struct:__anon23
noscripterr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
notification_script	sentinel.c	/^    char *notification_script;$/;"	m	struct:sentinelRedisInstance	file:
notifyKeyspaceEvent	notify.c	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {$/;"	f
notify_callback	module.c	/^    RedisModuleNotificationFunc notify_callback;$/;"	m	struct:RedisModuleKeyspaceSubscriber	file:
notify_keyspace_events	server.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	struct:redisServer
notused	hyperloglog.c	/^    uint8_t notused[3]; \/* Reserved for future use, must be zero. *\/$/;"	m	struct:hllhdr	file:
notused1	cluster.h	/^    char notused1[32];  \/* 32 bytes reserved for future usage. *\/$/;"	m	struct:__anon12
notused1	cluster.h	/^    uint16_t notused1;$/;"	m	struct:__anon2
npending	ae_evport.c	/^    uint_t  npending;                           \/* # of pending fds *\/$/;"	m	struct:aeApiState	file:
ntohu64	endianconv.h	68;"	d
ntohu64	endianconv.h	71;"	d
nul	setproctitle.c	/^	char *nul;$/;"	m	struct:__anon56	file:
null	server.h	/^    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],$/;"	m	struct:sharedObjectsStruct
nullarray	server.h	/^    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],$/;"	m	struct:sharedObjectsStruct
num_dbs	server.h	/^    size_t num_dbs;$/;"	m	struct:redisMemOverhead
num_threads	redis-benchmark.c	/^    int num_threads;$/;"	m	struct:config	file:
numclients	redis-benchmark.c	/^    int numclients;$/;"	m	struct:config	file:
numele	rax.h	/^    uint64_t numele;$/;"	m	struct:rax
numeric	config.c	/^    numericConfigData numeric;$/;"	m	union:typeData	file:
numericConfigData	config.c	/^typedef struct numericConfigData {$/;"	s	file:
numericConfigData	config.c	/^} numericConfigData;$/;"	t	typeref:struct:numericConfigData	file:
numericType	config.c	/^typedef enum numericType {$/;"	g	file:
numericType	config.c	/^} numericType;$/;"	t	typeref:enum:numericType	file:
numeric_type	config.c	/^    numericType numeric_type; \/* An enum indicating the type of this value *\/$/;"	m	struct:numericConfigData	file:
numfieldsleft	module.c	/^            int64_t numfieldsleft; \/* Fields left to fetch for current entry. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon30	file:
numkeys	server.h	/^    int numkeys;                        \/* Number of key indices return *\/$/;"	m	struct:__anon48
numnodes	rax.h	/^    uint64_t numnodes;$/;"	m	struct:rax
numops	server.h	/^    int numops;$/;"	m	struct:redisOpArray
numreplicas	server.h	/^    int numreplicas;        \/* Number of replicas we are waiting for ACK. *\/$/;"	m	struct:blockingState
numslaves	cluster.h	/^    int numslaves;  \/* Number of slave nodes, if this is a master *\/$/;"	m	struct:clusterNode
numslots	cluster.h	/^    int numslots;   \/* Number of slots handled by this node *\/$/;"	m	struct:clusterNode
o	server.h	/^    unsigned char o[20];    \/* Ordered elements. *\/$/;"	m	struct:RedisModuleDigest
o_down_since_time	sentinel.c	/^    mstime_t o_down_since_time; \/* Objectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:
obj	server.h	/^    robj *obj;$/;"	m	struct:_redisSortObject
object	acl.c	/^    sds object;         \/* The key name or command name. *\/$/;"	m	struct:ACLLogEntry	file:
objectCommand	object.c	/^void objectCommand(client *c) {$/;"	f
objectCommandLookup	object.c	/^robj *objectCommandLookup(client *c, robj *key) {$/;"	f
objectCommandLookupOrReply	object.c	/^robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {$/;"	f
objectComputeSize	object.c	/^size_t objectComputeSize(robj *o, size_t sample_size) {$/;"	f
objectKeyHeapPointerValueDictType	server.c	/^dictType objectKeyHeapPointerValueDictType = {$/;"	v
objectKeyPointerValueDictType	server.c	/^dictType objectKeyPointerValueDictType = {$/;"	v
objectSetLRUOrLFU	object.c	/^int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,$/;"	f
obuf	redis-benchmark.c	/^    sds obuf;$/;"	m	struct:_client	file:
obuf_soft_limit_reached_time	server.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	struct:client
offset	bitops.c	/^    uint64_t offset;    \/* Bitfield offset. *\/$/;"	m	struct:bitfieldOp	file:
offset	cluster.h	/^    uint64_t offset;    \/* Master replication offset if node is a master or$/;"	m	struct:__anon12
offset	quicklist.h	/^    int offset;$/;"	m	struct:quicklistEntry
offset	quicklist.h	/^    long offset; \/* offset in current ziplist *\/$/;"	m	struct:quicklistIter
ok	intset.c	/^static void ok(void) {$/;"	f	file:
ok	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
oom	rax.h	/^    int oom; \/* True if pushing into this stack failed for OOM at some point. *\/$/;"	m	struct:raxStack
oom_score_adj	server.h	/^    int oom_score_adj;                            \/* If true, oom_score_adj is managed *\/$/;"	m	struct:redisServer
oom_score_adj_base	server.h	/^    int oom_score_adj_base;         \/* Base oom_score_adj value, as observed on startup *\/$/;"	m	struct:redisServer
oom_score_adj_enum	config.c	/^configEnum oom_score_adj_enum[] = {$/;"	v
oom_score_adj_values	server.h	/^    int oom_score_adj_values[CONFIG_OOM_COUNT];   \/* Linux oom_score_adj configuration *\/$/;"	m	struct:redisServer
oomerr	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
opcode	bitops.c	/^    int opcode;         \/* Operation id. *\/$/;"	m	struct:bitfieldOp	file:
openChildInfoPipe	childinfo.c	/^void openChildInfoPipe(void) {$/;"	f
openDirectLogFiledes	debug.c	/^int openDirectLogFiledes(void) {$/;"	f
openssl_locks	tls.c	/^static pthread_mutex_t *openssl_locks;$/;"	v	file:
ops	server.h	/^    redisOp *ops;$/;"	m	struct:redisOpArray
optimization_level	quicklist.c	/^static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};$/;"	v	file:
options	module.c	/^    int options;    \/* Module options and capabilities. *\/$/;"	m	struct:RedisModule	file:
options	redis-cli.c	/^    char *options;$/;"	m	struct:clusterManagerCommandDef	file:
org	redis-cli.c	/^    struct commandHelp *org;$/;"	m	struct:__anon35	typeref:struct:__anon35::commandHelp	file:
orig_commands	server.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	struct:redisServer
original_argc	server.h	/^    int original_argc;      \/* Num of arguments of original command if arguments were rewritten. *\/$/;"	m	struct:client
original_argv	server.h	/^    robj **original_argv;   \/* Arguments of original command if arguments were rewritten. *\/$/;"	m	struct:client
orphaned_time	cluster.h	/^    mstime_t orphaned_time;     \/* Starting time of orphaned master condition *\/$/;"	m	struct:clusterNode
ot	config.c	/^        off_t *ot;$/;"	m	union:numericConfigData::__anon14	file:
outofrangeerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
output	redis-cli.c	/^    int output; \/* output mode, see OUTPUT_* defines *\/$/;"	m	struct:config	file:
overMaxmemoryAfterAlloc	evict.c	/^int overMaxmemoryAfterAlloc(size_t moremem) {$/;"	f
overhead_ht_expires	server.h	/^        size_t overhead_ht_expires;$/;"	m	struct:redisMemOverhead::__anon46
overhead_ht_main	server.h	/^        size_t overhead_ht_main;$/;"	m	struct:redisMemOverhead::__anon46
overhead_total	server.h	/^    size_t overhead_total;$/;"	m	struct:redisMemOverhead
owtype	bitops.c	/^    int owtype;         \/* Overflow type to use. *\/$/;"	m	struct:bitfieldOp	file:
p	ziplist.c	/^    unsigned char *p;            \/* Pointer to the very start of the entry, that$/;"	m	struct:zlentry	file:
pa_head	module.c	/^    struct RedisModulePoolAllocBlock *pa_head;$/;"	m	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModulePoolAllocBlock	file:
panic	redisassert.h	44;"	d
parallel_syncs	sentinel.c	/^    int parallel_syncs; \/* How many slaves to reconfigure at same time. *\/$/;"	m	struct:sentinelRedisInstance	file:
params	help.h	/^  char *params;$/;"	m	struct:commandHelp
parseClusterNodeAddress	redis-cli.c	/^static int parseClusterNodeAddress(char *addr, char **ip_ptr, int *port_ptr,$/;"	f	file:
parseEnv	redis-cli.c	/^static void parseEnv() {$/;"	f	file:
parseExtendedStringArgumentsOrReply	t_string.c	/^int parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {$/;"	f
parseOptions	redis-benchmark.c	/^int parseOptions(int argc, const char **argv) {$/;"	f
parseOptions	redis-cli.c	/^static int parseOptions(int argc, char **argv) {$/;"	f	file:
parseProtocolsConfig	tls.c	/^static int parseProtocolsConfig(const char *str) {$/;"	f	file:
parseRedisUri	redis-cli.c	/^static void parseRedisUri(const char *uri) {$/;"	f	file:
parseScanCursorOrReply	db.c	/^int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {$/;"	f
parse_options	redis-trib.rb	/^def parse_options(cmd)$/;"	f
passwords	server.h	/^    list *passwords; \/* A list of SDS valid passwords for this user. *\/$/;"	m	struct:__anon45
path	server.h	/^    sds path;$/;"	m	struct:moduleLoadQueueEntry
pathIsBaseName	util.c	/^int pathIsBaseName(char *path) {$/;"	f
pattern	redis-cli.c	/^    sds pattern;$/;"	m	struct:config	file:
pattern	server.h	/^    robj *pattern;$/;"	m	struct:_redisSortOperation
patterns	server.h	/^    list *patterns;  \/* A list of allowed key patterns. If this field is NULL$/;"	m	struct:__anon45
pauseClients	networking.c	/^void pauseClients(mstime_t end, pause_type type) {$/;"	f
pause_type	server.h	/^} pause_type;$/;"	t	typeref:enum:__anon44
paused_clients	server.h	/^    list *paused_clients;       \/* List of pause clients *\/$/;"	m	struct:redisServer
paused_list_node	server.h	/^    listNode *paused_list_node; \/* list node within the pause list *\/$/;"	m	struct:client
pauserehash	dict.h	/^    int16_t pauserehash; \/* If >0 rehashing is paused (<0 indicates coding error) *\/$/;"	m	struct:dict
pc	sentinel.c	/^    redisAsyncContext *pc; \/* Hiredis context for Pub \/ Sub. *\/$/;"	m	struct:instanceLink	file:
pc_conn_time	sentinel.c	/^    mstime_t pc_conn_time; \/* pc connection time. *\/$/;"	m	struct:instanceLink	file:
pc_last_activity	sentinel.c	/^    mstime_t pc_last_activity; \/* Last time we received any message. *\/$/;"	m	struct:instanceLink	file:
peak_allocated	server.h	/^    size_t peak_allocated;$/;"	m	struct:redisMemOverhead
peak_perc	server.h	/^    float peak_perc;$/;"	m	struct:redisMemOverhead
peerid	server.h	/^    sds peerid;             \/* Cached peer ID. *\/$/;"	m	struct:client
peerid	slowlog.h	/^    sds peerid;         \/* Client network address. *\/$/;"	m	struct:slowlogEntry
pel	stream.h	/^    rax *pel;                   \/* Consumer specific pending entries list: all$/;"	m	struct:streamConsumer
pel	stream.h	/^    rax *pel;               \/* Pending entries list. This is a radix tree that$/;"	m	struct:streamCG
pending	redis-benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	struct:_client	file:
pending_commands	sentinel.c	/^    int pending_commands;  \/* Number of commands sent waiting for a reply. *\/$/;"	m	struct:instanceLink	file:
pending_fds	ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	struct:aeApiState	file:
pending_list	tls.c	/^static list *pending_list = NULL;$/;"	v	file:
pending_list_node	tls.c	/^    listNode *pending_list_node;$/;"	m	struct:tls_connection	file:
pending_masks	ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	struct:aeApiState	file:
pending_querybuf	server.h	/^    sds pending_querybuf;   \/* If this client is flagged as master, this buffer$/;"	m	struct:client
percentDecode	redis-cli.c	/^static sds percentDecode(const char *pe, size_t len) {$/;"	f	file:
performEvictions	evict.c	/^int performEvictions(void) {$/;"	f
period	latency.h	/^    time_t period;          \/* Number of seconds since first event and now. *\/$/;"	m	struct:latencyStats
persist	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
persistCommand	expire.c	/^void persistCommand(client *c) {$/;"	f
pexpire	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
pexpireCommand	expire.c	/^void pexpireCommand(client *c) {$/;"	f
pexpireCommand	server.h	/^                        *expireCommand, *pexpireCommand, *xclaimCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
pexpireat	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
pexpireatCommand	expire.c	/^void pexpireatCommand(client *c) {$/;"	f
pfaddCommand	hyperloglog.c	/^void pfaddCommand(client *c) {$/;"	f
pfcountCommand	hyperloglog.c	/^void pfcountCommand(client *c) {$/;"	f
pfdebugCommand	hyperloglog.c	/^void pfdebugCommand(client *c) {$/;"	f
pfmergeCommand	hyperloglog.c	/^void pfmergeCommand(client *c) {$/;"	f
pfselftestCommand	hyperloglog.c	/^void pfselftestCommand(client *c) {$/;"	f
pid	sentinel.c	/^    pid_t pid;              \/* Script execution pid. *\/$/;"	m	struct:sentinelScriptJob	file:
pid	server.h	/^    pid_t pid;                  \/* Main process pid. *\/$/;"	m	struct:redisServer
pidfile	server.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	struct:redisServer
ping	cluster.h	/^    } ping;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon7
ping	server.h	/^    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,$/;"	m	struct:sharedObjectsStruct
pingCommand	server.c	/^void pingCommand(client *c) {$/;"	f
ping_recv	redis-cli.c	/^    time_t ping_recv;$/;"	m	struct:clusterManagerNode	file:
ping_sent	cluster.h	/^    mstime_t ping_sent;      \/* Unix time we sent latest ping *\/$/;"	m	struct:clusterNode
ping_sent	cluster.h	/^    uint32_t ping_sent;$/;"	m	struct:__anon2
ping_sent	redis-cli.c	/^    time_t ping_sent;$/;"	m	struct:clusterManagerNode	file:
pipeMode	redis-cli.c	/^static void pipeMode(void) {$/;"	f	file:
pipe_mode	redis-cli.c	/^    int pipe_mode;$/;"	m	struct:config	file:
pipe_timeout	redis-cli.c	/^    int pipe_timeout;$/;"	m	struct:config	file:
pipeline	redis-benchmark.c	/^    int pipeline;$/;"	m	struct:config	file:
pipeline	redis-cli.c	/^    int pipeline;$/;"	m	struct:clusterManagerCommand	file:
pixels	lolwut.h	/^    char *pixels;$/;"	m	struct:lwCanvas
plus	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
pmessagebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
pointer	server.h	/^    unsigned long pointer;$/;"	m	struct:redisFunctionSym
pong	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
pong_received	cluster.h	/^    mstime_t pong_received;  \/* Unix time we received the pong *\/$/;"	m	struct:clusterNode
pong_received	cluster.h	/^    uint32_t pong_received;$/;"	m	struct:__anon2
poolAllocRelease	module.c	/^void poolAllocRelease(RedisModuleCtx *ctx) {$/;"	f
pop	ziplist.c	/^static unsigned char *pop(unsigned char *zl, int where) {$/;"	f	file:
popGenericCommand	t_list.c	/^void popGenericCommand(client *c, int where) {$/;"	f
populateCommandTable	server.c	/^void populateCommandTable(void) {$/;"	f
populateCommandTableParseFlags	server.c	/^int populateCommandTableParseFlags(struct redisCommand *c, char *strflags) {$/;"	f
port	cluster.h	/^    int port;                   \/* Latest known clients port (TLS or plain). *\/$/;"	m	struct:clusterNode
port	cluster.h	/^    uint16_t port;              \/* base port last time it was seen *\/$/;"	m	struct:__anon2
port	cluster.h	/^    uint16_t port;      \/* TCP base port number. *\/$/;"	m	struct:__anon12
port	module.c	/^    int port;$/;"	m	struct:moduleClusterNodeInfo	file:
port	redis-benchmark.c	/^    int port;$/;"	m	struct:clusterNode	file:
port	redis-cli.c	/^    int port;$/;"	m	struct:clusterManagerNode	file:
port	redismodule.h	/^    uint16_t port;          \/* TCP port. *\/$/;"	m	struct:RedisModuleClientInfo
port	sentinel.c	/^    int port;$/;"	m	struct:sentinelAddr	file:
port	server.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	struct:redisServer
portfd	ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	struct:aeApiState	file:
pos	rio.h	/^            off_t pos;    \/* pos in buf that was returned *\/$/;"	m	struct:_rio::__anon37::__anon40
pos	rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon37::__anon38
pos	rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon37::__anon41
post_monitor_cfg	server.h	/^    list *post_monitor_cfg;$/;"	m	struct:sentinelConfig
postponeClientRead	networking.c	/^int postponeClientRead(client *c) {$/;"	f
postponed_arrays	module.c	/^    void **postponed_arrays;        \/* To set with RM_ReplySetArrayLength(). *\/$/;"	m	struct:RedisModuleCtx	file:
postponed_arrays_count	module.c	/^    int postponed_arrays_count;     \/* Number of entries in postponed_arrays. *\/$/;"	m	struct:RedisModuleCtx	file:
powerLawRand	redis-cli.c	/^long long powerLawRand(long long min, long long max, double alpha) {$/;"	f
pport	cluster.h	/^    int pport;                  \/* Latest known clients plaintext port. Only used$/;"	m	struct:clusterNode
pport	cluster.h	/^    uint16_t pport;             \/* plaintext-port, when base port is TLS *\/$/;"	m	struct:__anon2
pport	cluster.h	/^    uint16_t pport;      \/* Sender TCP plaintext port, if base port is TLS *\/$/;"	m	struct:__anon12
pqsort	pqsort.c	/^pqsort(void *a, size_t n, size_t es,$/;"	f
preMonitorCfgName	sentinel.c	/^const char *preMonitorCfgName[] = { $/;"	v
pre_monitor_cfg	server.h	/^    list *pre_monitor_cfg;$/;"	m	struct:sentinelConfig
pre_multi_dbnum	redis-cli.c	/^    int pre_multi_dbnum;$/;"	m	struct:config	file:
precision	redis-benchmark.c	/^    int precision;$/;"	m	struct:config	file:
pref	redis-cli.c	/^static struct pref {$/;"	s	file:
pref	redis-cli.c	/^} pref;$/;"	v	typeref:struct:pref	file:
prefer_server_ciphers	server.h	/^    int prefer_server_ciphers;$/;"	m	struct:redisTLSContextConfig
prefix_pending	redis-benchmark.c	/^    int prefix_pending;     \/* If non-zero, number of pending prefix commands. Commands$/;"	m	struct:_client	file:
prefixlen	redis-benchmark.c	/^    int prefixlen;          \/* Size in bytes of the pending prefix commands *\/$/;"	m	struct:_client	file:
prepareClientToWrite	networking.c	/^int prepareClientToWrite(client *c) {$/;"	f
prepareForShutdown	server.c	/^int prepareForShutdown(int flags) {$/;"	f
prepareLuaClient	scripting.c	/^void prepareLuaClient(void) {$/;"	f
prev	adlist.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
prev	ae.h	/^    struct aeTimeEvent *prev;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
prev	quicklist.h	/^    struct quicklistNode *prev;$/;"	m	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode
preventCommandAOF	server.c	/^void preventCommandAOF(client *c) {$/;"	f
preventCommandLogging	server.c	/^void preventCommandLogging(client *c) {$/;"	f
preventCommandPropagation	server.c	/^void preventCommandPropagation(client *c) {$/;"	f
preventCommandReplication	server.c	/^void preventCommandReplication(client *c) {$/;"	f
previous_requests_finished	redis-benchmark.c	/^    redisAtomic int previous_requests_finished;$/;"	m	struct:config	file:
previous_tick	redis-benchmark.c	/^    long long previous_tick;$/;"	m	struct:config	file:
previous_time	sentinel.c	/^    mstime_t previous_time;         \/* Last time we ran the time handler. *\/$/;"	m	struct:sentinelState	file:
prevrawlen	ziplist.c	/^    unsigned int prevrawlen;     \/* Previous entry len. *\/$/;"	m	struct:zlentry	file:
prevrawlensize	ziplist.c	/^    unsigned int prevrawlensize; \/* Bytes used to encode the previous entry len*\/$/;"	m	struct:zlentry	file:
printBits	bitops.c	/^void printBits(unsigned char *p, unsigned long count) {$/;"	f
printCrashReport	debug.c	/^void printCrashReport(void) {$/;"	f
private_data	connection.h	/^    void *private_data;$/;"	m	struct:connection
privdata	dict.h	/^    void *privdata;$/;"	m	struct:dict
privdata	module.c	/^    void *privdata;     \/* Module private data that may be used by the reply$/;"	m	struct:RedisModuleBlockedClient	file:
proc	redis-cli.c	/^    clusterManagerCommandProc *proc;$/;"	m	struct:clusterManagerCommandDef	file:
proc	server.c	/^    redisTestProc *proc;$/;"	m	struct:redisTest	file:
proc	server.h	/^    redisCommandProc *proc;$/;"	m	struct:redisCommand
proc_title_template	server.h	/^    char *proc_title_template;      \/* Process title template format *\/$/;"	m	struct:redisServer
process	redis-check-aof.c	/^off_t process(FILE *fp) {$/;"	f
processClientsWaitingReplicas	replication.c	/^void processClientsWaitingReplicas(void) {$/;"	f
processCommand	server.c	/^int processCommand(client *c) {$/;"	f
processCommandAndResetClient	networking.c	/^int processCommandAndResetClient(client *c) {$/;"	f
processEventsWhileBlocked	networking.c	/^void processEventsWhileBlocked(void) {$/;"	f
processGopherRequest	gopher.c	/^void processGopherRequest(client *c) {$/;"	f
processInlineBuffer	networking.c	/^int processInlineBuffer(client *c) {$/;"	f
processInputBuffer	networking.c	/^void processInputBuffer(client *c) {$/;"	f
processModuleLoadingProgressEvent	module.c	/^void processModuleLoadingProgressEvent(int is_aof) {$/;"	f
processMultibulkBuffer	networking.c	/^int processMultibulkBuffer(client *c) {$/;"	f
processPendingCommandsAndResetClient	networking.c	/^int processPendingCommandsAndResetClient(client *c) {$/;"	f
processTimeEvents	ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
processUnblockedClients	blocked.c	/^void processUnblockedClients(void) {$/;"	f
process_rss	server.h	/^    size_t process_rss;$/;"	m	struct:malloc_stats
processed_bytes	rio.h	/^    size_t processed_bytes;$/;"	m	struct:_rio
progress	childinfo.c	/^    double progress;$/;"	m	struct:__anon1	file:
progress	redismodule.h	/^    int32_t progress;       \/* Approximate progress between 0 and 1024, or -1$/;"	m	struct:RedisModuleLoadingProgressInfo
progress_full	memtest.c	/^size_t progress_full; \/* How many chars to write to fill the progress bar. *\/$/;"	v
progress_printed	memtest.c	/^size_t progress_printed; \/* Printed chars in screen-wide progress bar. *\/$/;"	v
promoted_slave	sentinel.c	/^    struct sentinelRedisInstance *promoted_slave; \/* Promoted slave instance. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:
prompt	redis-cli.c	/^    char prompt[128];$/;"	m	struct:config	file:
propagate	server.c	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f
propagateExpire	db.c	/^void propagateExpire(redisDb *db, robj *key, int lazy) {$/;"	f
propagate_in_transaction	server.h	/^    int propagate_in_transaction;  \/* Make sure we don't propagate nested MULTI\/EXEC *\/$/;"	m	struct:redisServer
protectClient	networking.c	/^void protectClient(client *c) {$/;"	f
protected_mode	server.h	/^    int protected_mode;         \/* Don't accept external connections. *\/$/;"	m	struct:redisServer
proto	module.c	/^    char *proto;    \/* Raw reply protocol. An SDS string at top-level object. *\/$/;"	m	struct:RedisModuleCallReply	file:
proto_max_bulk_len	server.h	/^    long long proto_max_bulk_len;   \/* Protocol bulk length maximum size. *\/$/;"	m	struct:redisServer
protocols	server.h	/^    char *protocols;$/;"	m	struct:redisTLSContextConfig
protolen	module.c	/^    size_t protolen;\/* Length of protocol. *\/$/;"	m	struct:RedisModuleCallReply	file:
psetexCommand	t_string.c	/^void psetexCommand(client *c) {$/;"	f
psubscribeCommand	pubsub.c	/^void psubscribeCommand(client *c) {$/;"	f
psubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	struct:sharedObjectsStruct
psync_initial_offset	server.h	/^    long long psync_initial_offset; \/* FULLRESYNC reply offset other slaves$/;"	m	struct:client
ptr	module.c	/^    void *ptr;$/;"	m	struct:AutoMemEntry	file:
ptr	rio.h	/^            sds ptr;$/;"	m	struct:_rio::__anon37::__anon38
ptr	server.h	/^    void *ptr;$/;"	m	struct:redisObject
pttlCommand	expire.c	/^void pttlCommand(client *c) {$/;"	f
publish	cluster.h	/^    } publish;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon9
publishCommand	pubsub.c	/^void publishCommand(client *c) {$/;"	f
pubsubCommand	pubsub.c	/^void pubsubCommand(client *c) {$/;"	f
pubsubPublishMessage	pubsub.c	/^int pubsubPublishMessage(robj *channel, robj *message) {$/;"	f
pubsubSubscribeChannel	pubsub.c	/^int pubsubSubscribeChannel(client *c, robj *channel) {$/;"	f
pubsubSubscribePattern	pubsub.c	/^int pubsubSubscribePattern(client *c, robj *pattern) {$/;"	f
pubsubUnsubscribeAllChannels	pubsub.c	/^int pubsubUnsubscribeAllChannels(client *c, int notify) {$/;"	f
pubsubUnsubscribeAllPatterns	pubsub.c	/^int pubsubUnsubscribeAllPatterns(client *c, int notify) {$/;"	f
pubsubUnsubscribeChannel	pubsub.c	/^int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {$/;"	f
pubsubUnsubscribePattern	pubsub.c	/^int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {$/;"	f
pubsub_channels	server.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	struct:redisServer
pubsub_channels	server.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:client
pubsub_mode	redis-cli.c	/^    int pubsub_mode;$/;"	m	struct:config	file:
pubsub_patterns	server.h	/^    dict *pubsub_patterns;  \/* A dict of pubsub_patterns *\/$/;"	m	struct:redisServer
pubsub_patterns	server.h	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:client
punsubscribeCommand	pubsub.c	/^void punsubscribeCommand(client *c) {$/;"	f
punsubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	struct:sharedObjectsStruct
pushGenericCommand	t_list.c	/^void pushGenericCommand(client *c, int where, int xx) {$/;"	f
push_output	redis-cli.c	/^    int push_output; \/* Should we display spontaneous PUSH replies *\/$/;"	m	struct:config	file:
putSlaveOnline	replication.c	/^void putSlaveOnline(client *slave) {$/;"	f
px	server.h	/^    *time, *pxat, *px, *retrycount, *force, *justid, $/;"	m	struct:sharedObjectsStruct
pxat	server.h	/^    *time, *pxat, *px, *retrycount, *force, *justid, $/;"	m	struct:sharedObjectsStruct
qb_pos	server.h	/^    size_t qb_pos;          \/* The position we have read in querybuf. *\/$/;"	m	struct:client
ql_info	quicklist.c	/^static void ql_info(quicklist *ql) {$/;"	f	file:
ql_verify	quicklist.c	1604;"	d	file:
qsortCompareSetsByCardinality	t_set.c	/^int qsortCompareSetsByCardinality(const void *s1, const void *s2) {$/;"	f
qsortCompareSetsByRevCardinality	t_set.c	/^int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {$/;"	f
querybuf	server.h	/^    sds querybuf;           \/* Buffer we use to accumulate client queries. *\/$/;"	m	struct:client
querybuf_peak	server.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size. *\/$/;"	m	struct:client
queueClientForReprocessing	blocked.c	/^void queueClientForReprocessing(client *c) {$/;"	f
queueLoadModule	config.c	/^void queueLoadModule(sds path, sds *argv, int argc) {$/;"	f
queueMultiCommand	multi.c	/^void queueMultiCommand(client *c) {$/;"	f
queueSentinelConfig	sentinel.c	/^void queueSentinelConfig(sds *argv, int argc, int linenum, sds line) {$/;"	f
queued	server.h	/^    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],$/;"	m	struct:sharedObjectsStruct
quicklist	quicklist.h	/^    const quicklist *quicklist;$/;"	m	struct:quicklistEntry
quicklist	quicklist.h	/^    const quicklist *quicklist;$/;"	m	struct:quicklistIter
quicklist	quicklist.h	/^typedef struct quicklist {$/;"	s
quicklist	quicklist.h	/^} quicklist;$/;"	t	typeref:struct:quicklist
quicklistAllowsCompression	quicklist.c	261;"	d	file:
quicklistAppendValuesFromZiplist	quicklist.c	/^quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,$/;"	f
quicklistAppendZiplist	quicklist.c	/^void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {$/;"	f
quicklistBookmark	quicklist.h	/^typedef struct quicklistBookmark {$/;"	s
quicklistBookmark	quicklist.h	/^} quicklistBookmark;$/;"	t	typeref:struct:quicklistBookmark
quicklistBookmarkCreate	quicklist.c	/^int quicklistBookmarkCreate(quicklist **ql_ref, const char *name, quicklistNode *node) {$/;"	f
quicklistBookmarkDelete	quicklist.c	/^int quicklistBookmarkDelete(quicklist *ql, const char *name) {$/;"	f
quicklistBookmarkFind	quicklist.c	/^quicklistNode *quicklistBookmarkFind(quicklist *ql, const char *name) {$/;"	f
quicklistBookmarksClear	quicklist.c	/^void quicklistBookmarksClear(quicklist *ql) {$/;"	f
quicklistCompare	quicklist.c	/^int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {$/;"	f
quicklistCompress	quicklist.c	335;"	d	file:
quicklistCompressNode	quicklist.c	208;"	d	file:
quicklistCount	quicklist.c	/^unsigned long quicklistCount(const quicklist *ql) { return ql->count; }$/;"	f
quicklistCreate	quicklist.c	/^quicklist *quicklistCreate(void) {$/;"	f
quicklistCreateFromZiplist	quicklist.c	/^quicklist *quicklistCreateFromZiplist(int fill, int compress,$/;"	f
quicklistCreateNode	quicklist.c	/^REDIS_STATIC quicklistNode *quicklistCreateNode(void) {$/;"	f
quicklistDecompressNode	quicklist.c	236;"	d	file:
quicklistDecompressNodeForUse	quicklist.c	244;"	d	file:
quicklistDelEntry	quicklist.c	/^void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {$/;"	f
quicklistDelIndex	quicklist.c	/^REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,$/;"	f
quicklistDelRange	quicklist.c	/^int quicklistDelRange(quicklist *quicklist, const long start,$/;"	f
quicklistDeleteIfEmpty	quicklist.c	574;"	d	file:
quicklistDup	quicklist.c	/^quicklist *quicklistDup(quicklist *orig) {$/;"	f
quicklistEntry	quicklist.h	/^typedef struct quicklistEntry {$/;"	s
quicklistEntry	quicklist.h	/^} quicklistEntry;$/;"	t	typeref:struct:quicklistEntry
quicklistGetIterator	quicklist.c	/^quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction) {$/;"	f
quicklistGetIteratorAtIdx	quicklist.c	/^quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,$/;"	f
quicklistGetLzf	quicklist.c	/^size_t quicklistGetLzf(const quicklistNode *node, void **data) {$/;"	f
quicklistIndex	quicklist.c	/^int quicklistIndex(const quicklist *quicklist, const long long idx,$/;"	f
quicklistInsertAfter	quicklist.c	/^void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,$/;"	f
quicklistInsertBefore	quicklist.c	/^void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,$/;"	f
quicklistIter	quicklist.h	/^typedef struct quicklistIter {$/;"	s
quicklistIter	quicklist.h	/^} quicklistIter;$/;"	t	typeref:struct:quicklistIter
quicklistLZF	quicklist.h	/^typedef struct quicklistLZF {$/;"	s
quicklistLZF	quicklist.h	/^} quicklistLZF;$/;"	t	typeref:struct:quicklistLZF
quicklistNew	quicklist.c	/^quicklist *quicklistNew(int fill, int compress) {$/;"	f
quicklistNext	quicklist.c	/^int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {$/;"	f
quicklistNode	quicklist.h	/^typedef struct quicklistNode {$/;"	s
quicklistNode	quicklist.h	/^} quicklistNode;$/;"	t	typeref:struct:quicklistNode
quicklistNodeIsCompressed	quicklist.h	148;"	d
quicklistNodeUpdateSz	quicklist.c	474;"	d	file:
quicklistPop	quicklist.c	/^int quicklistPop(quicklist *quicklist, int where, unsigned char **data,$/;"	f
quicklistPopCustom	quicklist.c	/^int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,$/;"	f
quicklistPush	quicklist.c	/^void quicklistPush(quicklist *quicklist, void *value, const size_t sz,$/;"	f
quicklistPushHead	quicklist.c	/^int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {$/;"	f
quicklistPushTail	quicklist.c	/^int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {$/;"	f
quicklistRecompressOnly	quicklist.c	344;"	d	file:
quicklistRelease	quicklist.c	/^void quicklistRelease(quicklist *quicklist) {$/;"	f
quicklistReleaseIterator	quicklist.c	/^void quicklistReleaseIterator(quicklistIter *iter) {$/;"	f
quicklistReplaceAtIndex	quicklist.c	/^int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,$/;"	f
quicklistRotate	quicklist.c	/^void quicklistRotate(quicklist *quicklist) {$/;"	f
quicklistSetCompressDepth	quicklist.c	/^void quicklistSetCompressDepth(quicklist *quicklist, int compress) {$/;"	f
quicklistSetFill	quicklist.c	/^void quicklistSetFill(quicklist *quicklist, int fill) {$/;"	f
quicklistSetOptions	quicklist.c	/^void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {$/;"	f
quicklistTest	quicklist.c	/^int quicklistTest(int argc, char *argv[], int accurate) {$/;"	f
quiet	redis-benchmark.c	/^    int quiet;$/;"	m	struct:config	file:
quorum	sentinel.c	/^    unsigned int quorum;\/* Number of sentinels that need to agree on failure. *\/$/;"	m	struct:sentinelRedisInstance	file:
quoted_input	redis-cli.c	/^    int quoted_input;   \/* Force input args to be treated as quoted strings *\/$/;"	m	struct:config	file:
r	geohash.h	/^        } r;$/;"	m	union:__anon24::__anon25	typeref:struct:__anon24::__anon25::__anon26
rad_deg	geohash_helper.c	/^static inline double rad_deg(double ang) { return ang \/ D_R; }$/;"	f	file:
radius	geohash.h	/^        double radius;$/;"	m	union:__anon24::__anon25
randfree	redis-benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	struct:_client	file:
randlen	redis-benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	struct:_client	file:
randomULong	dict.h	158;"	d
randomULong	dict.h	160;"	d
randomizeClientKey	redis-benchmark.c	/^static void randomizeClientKey(client c) {$/;"	f	file:
randomkeyCommand	db.c	/^void randomkeyCommand(client *c) {$/;"	f
randomkeys	redis-benchmark.c	/^    int randomkeys;$/;"	m	struct:config	file:
randomkeys_keyspacelen	redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	struct:config	file:
randptr	redis-benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	struct:_client	file:
randstring	ziplist.c	/^static int randstring(char *target, unsigned int min, unsigned int max) {$/;"	f	file:
rax	module.c	/^    rax *rax;                       \/* The radix tree. *\/$/;"	m	struct:RedisModuleDict	file:
rax	module.c	/^    rax *rax;                       \/* parsed info data. *\/$/;"	m	struct:RedisModuleServerInfoData	file:
rax	rax.h	/^typedef struct rax {$/;"	s
rax	rax.h	/^} rax;$/;"	t	typeref:struct:rax
rax	stream.h	/^    rax *rax;               \/* The radix tree holding the stream. *\/$/;"	m	struct:stream
raxAddChild	rax.c	/^raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {$/;"	f
raxCompare	rax.c	/^int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len) {$/;"	f
raxCompressNode	rax.c	/^raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {$/;"	f
raxDebugMsg	rax.c	/^static int raxDebugMsg = 1;$/;"	v	file:
raxDebugShowNode	rax.c	/^void raxDebugShowNode(const char *msg, raxNode *n) {$/;"	f
raxDefragFunction	defrag.c	/^typedef void *(raxDefragFunction)(raxIterator *ri, void *privdata, long *defragged);$/;"	t	file:
raxEOF	rax.c	/^int raxEOF(raxIterator *it) {$/;"	f
raxFind	rax.c	/^void *raxFind(rax *rax, unsigned char *s, size_t len) {$/;"	f
raxFindParentLink	rax.c	/^raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {$/;"	f
raxFree	rax.c	/^void raxFree(rax *rax) {$/;"	f
raxFreeWithCallback	rax.c	/^void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {$/;"	f
raxGenericInsert	rax.c	/^int raxGenericInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old, int overwrite) {$/;"	f
raxGetData	rax.c	/^void *raxGetData(raxNode *n) {$/;"	f
raxInsert	rax.c	/^int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {$/;"	f
raxIterator	rax.h	/^typedef struct raxIterator {$/;"	s
raxIterator	rax.h	/^} raxIterator;$/;"	t	typeref:struct:raxIterator
raxIteratorAddChars	rax.c	/^int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {$/;"	f
raxIteratorDelChars	rax.c	/^void raxIteratorDelChars(raxIterator *it, size_t count) {$/;"	f
raxIteratorNextStep	rax.c	/^int raxIteratorNextStep(raxIterator *it, int noup) {$/;"	f
raxIteratorPrevStep	rax.c	/^int raxIteratorPrevStep(raxIterator *it, int noup) {$/;"	f
raxLowWalk	rax.c	/^static inline size_t raxLowWalk(rax *rax, unsigned char *s, size_t len, raxNode **stopnode, raxNode ***plink, int *splitpos, raxStack *ts) {$/;"	f	file:
raxNew	rax.c	/^rax *raxNew(void) {$/;"	f
raxNewNode	rax.c	/^raxNode *raxNewNode(size_t children, int datafield) {$/;"	f
raxNext	rax.c	/^int raxNext(raxIterator *it) {$/;"	f
raxNode	rax.h	/^typedef struct raxNode {$/;"	s
raxNode	rax.h	/^} raxNode;$/;"	t	typeref:struct:raxNode
raxNodeCallback	rax.h	/^typedef int (*raxNodeCallback)(raxNode **noderef);$/;"	t
raxNodeCurrentLength	rax.c	177;"	d	file:
raxNodeFirstChildPtr	rax.c	169;"	d	file:
raxNodeLastChildPtr	rax.c	161;"	d	file:
raxNotFound	rax.c	/^void *raxNotFound = (void*)"rax-not-found-pointer";$/;"	v
raxPadding	rax.c	157;"	d	file:
raxPrev	rax.c	/^int raxPrev(raxIterator *it) {$/;"	f
raxRandomWalk	rax.c	/^int raxRandomWalk(raxIterator *it, size_t steps) {$/;"	f
raxReallocForData	rax.c	/^raxNode *raxReallocForData(raxNode *n, void *data) {$/;"	f
raxRecursiveFree	rax.c	/^void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {$/;"	f
raxRecursiveShow	rax.c	/^void raxRecursiveShow(int level, int lpad, raxNode *n) {$/;"	f
raxRemove	rax.c	/^int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {$/;"	f
raxRemoveChild	rax.c	/^raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {$/;"	f
raxSeek	rax.c	/^int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {$/;"	f
raxSeekGreatest	rax.c	/^int raxSeekGreatest(raxIterator *it) {$/;"	f
raxSetData	rax.c	/^void raxSetData(raxNode *n, void *data) {$/;"	f
raxSetDebugMsg	rax.c	/^void raxSetDebugMsg(int onoff) {$/;"	f
raxShow	rax.c	/^void raxShow(rax *rax) {$/;"	f
raxSize	rax.c	/^uint64_t raxSize(rax *rax) {$/;"	f
raxStack	rax.h	/^typedef struct raxStack {$/;"	s
raxStack	rax.h	/^} raxStack;$/;"	t	typeref:struct:raxStack
raxStackFree	rax.c	/^static inline void raxStackFree(raxStack *ts) {$/;"	f	file:
raxStackInit	rax.c	/^static inline void raxStackInit(raxStack *ts) {$/;"	f	file:
raxStackPeek	rax.c	/^static inline void *raxStackPeek(raxStack *ts) {$/;"	f	file:
raxStackPop	rax.c	/^static inline void *raxStackPop(raxStack *ts) {$/;"	f	file:
raxStackPush	rax.c	/^static inline int raxStackPush(raxStack *ts, void *ptr) {$/;"	f	file:
raxStart	rax.c	/^void raxStart(raxIterator *it, rax *rt) {$/;"	f
raxStop	rax.c	/^void raxStop(raxIterator *it) {$/;"	f
raxTouch	rax.c	/^unsigned long raxTouch(raxNode *n) {$/;"	f
raxTryInsert	rax.c	/^int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {$/;"	f
rax_free	rax_malloc.h	43;"	d
rax_malloc	rax_malloc.h	41;"	d
rax_realloc	rax_malloc.h	42;"	d
rcvbuf	cluster.h	/^    char *rcvbuf;               \/* Packet reception buffer *\/$/;"	m	struct:clusterLink
rcvbuf_alloc	cluster.h	/^    size_t rcvbuf_alloc;        \/* Allocated size of rcvbuf *\/$/;"	m	struct:clusterLink
rcvbuf_len	cluster.h	/^    size_t rcvbuf_len;          \/* Used size of rcvbuf *\/$/;"	m	struct:clusterLink
rdbCheckError	redis-check-rdb.c	/^void rdbCheckError(const char *fmt, ...) {$/;"	f
rdbCheckHandleCrash	redis-check-rdb.c	/^void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {$/;"	f
rdbCheckInfo	redis-check-rdb.c	/^void rdbCheckInfo(const char *fmt, ...) {$/;"	f
rdbCheckMode	redis-check-rdb.c	/^int rdbCheckMode = 0;$/;"	v
rdbCheckSetError	redis-check-rdb.c	/^void rdbCheckSetError(const char *fmt, ...) {$/;"	f
rdbCheckSetupSignals	redis-check-rdb.c	/^void rdbCheckSetupSignals(void) {$/;"	f
rdbEncodeInteger	rdb.c	/^int rdbEncodeInteger(long long value, unsigned char *enc) {$/;"	f
rdbFileBeingLoaded	rdb.c	/^char* rdbFileBeingLoaded = NULL; \/* used for rdb checking on read error *\/$/;"	v
rdbGenericLoadStringObject	rdb.c	/^void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {$/;"	f
rdbIsObjectType	rdb.h	97;"	d
rdbLoad	rdb.c	/^int rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {$/;"	f
rdbLoadBinaryDoubleValue	rdb.c	/^int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {$/;"	f
rdbLoadBinaryFloatValue	rdb.c	/^int rdbLoadBinaryFloatValue(rio *rdb, float *val) {$/;"	f
rdbLoadCheckModuleValue	rdb.c	/^robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {$/;"	f
rdbLoadDoubleValue	rdb.c	/^int rdbLoadDoubleValue(rio *rdb, double *val) {$/;"	f
rdbLoadEncodedStringObject	rdb.c	/^robj *rdbLoadEncodedStringObject(rio *rdb) {$/;"	f
rdbLoadIntegerObject	rdb.c	/^void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {$/;"	f
rdbLoadLen	rdb.c	/^uint64_t rdbLoadLen(rio *rdb, int *isencoded) {$/;"	f
rdbLoadLenByRef	rdb.c	/^int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {$/;"	f
rdbLoadLzfStringObject	rdb.c	/^void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {$/;"	f
rdbLoadMillisecondTime	rdb.c	/^long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {$/;"	f
rdbLoadObject	rdb.c	/^robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {$/;"	f
rdbLoadObjectType	rdb.c	/^int rdbLoadObjectType(rio *rdb) {$/;"	f
rdbLoadProgressCallback	rdb.c	/^void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {$/;"	f
rdbLoadRio	rdb.c	/^int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {$/;"	f
rdbLoadStringObject	rdb.c	/^robj *rdbLoadStringObject(rio *rdb) {$/;"	f
rdbLoadTime	rdb.c	/^time_t rdbLoadTime(rio *rdb) {$/;"	f
rdbLoadType	rdb.c	/^int rdbLoadType(rio *rdb) {$/;"	f
rdbPipeReadHandler	replication.c	/^void rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask) {$/;"	f
rdbPipeWriteHandler	replication.c	/^void rdbPipeWriteHandler(struct connection *conn) {$/;"	f
rdbPipeWriteHandlerConnRemoved	replication.c	/^void rdbPipeWriteHandlerConnRemoved(struct connection *conn) {$/;"	f
rdbPopulateSaveInfo	rdb.c	/^rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {$/;"	f
rdbRemoveTempFile	rdb.c	/^void rdbRemoveTempFile(pid_t childpid, int from_signal) {$/;"	f
rdbReportCorruptRDB	rdb.c	47;"	d	file:
rdbReportError	rdb.c	/^void rdbReportError(int corruption_error, int linenum, char *reason, ...) {$/;"	f
rdbReportReadError	rdb.c	49;"	d	file:
rdbSave	rdb.c	/^int rdbSave(char *filename, rdbSaveInfo *rsi) {$/;"	f
rdbSaveAuxField	rdb.c	/^ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {$/;"	f
rdbSaveAuxFieldStrInt	rdb.c	/^ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {$/;"	f
rdbSaveAuxFieldStrStr	rdb.c	/^ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {$/;"	f
rdbSaveBackground	rdb.c	/^int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {$/;"	f
rdbSaveBinaryDoubleValue	rdb.c	/^int rdbSaveBinaryDoubleValue(rio *rdb, double val) {$/;"	f
rdbSaveBinaryFloatValue	rdb.c	/^int rdbSaveBinaryFloatValue(rio *rdb, float val) {$/;"	f
rdbSaveDoubleValue	rdb.c	/^int rdbSaveDoubleValue(rio *rdb, double val) {$/;"	f
rdbSaveInfo	server.h	/^typedef struct rdbSaveInfo {$/;"	s
rdbSaveInfo	server.h	/^} rdbSaveInfo;$/;"	t	typeref:struct:rdbSaveInfo
rdbSaveInfoAuxFields	rdb.c	/^int rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {$/;"	f
rdbSaveKeyValuePair	rdb.c	/^int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {$/;"	f
rdbSaveLen	rdb.c	/^int rdbSaveLen(rio *rdb, uint64_t len) {$/;"	f
rdbSaveLongLongAsStringObject	rdb.c	/^ssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {$/;"	f
rdbSaveLzfBlob	rdb.c	/^ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,$/;"	f
rdbSaveLzfStringObject	rdb.c	/^ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {$/;"	f
rdbSaveMillisecondTime	rdb.c	/^int rdbSaveMillisecondTime(rio *rdb, long long t) {$/;"	f
rdbSaveModulesAux	module.c	/^ssize_t rdbSaveModulesAux(rio *rdb, int when) {$/;"	f
rdbSaveObject	rdb.c	/^ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {$/;"	f
rdbSaveObjectType	rdb.c	/^int rdbSaveObjectType(rio *rdb, robj *o) {$/;"	f
rdbSaveRawString	rdb.c	/^ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {$/;"	f
rdbSaveRio	rdb.c	/^int rdbSaveRio(rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) {$/;"	f
rdbSaveRioWithEOFMark	rdb.c	/^int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {$/;"	f
rdbSaveSingleModuleAux	rdb.c	/^ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {$/;"	f
rdbSaveStreamConsumers	rdb.c	/^size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {$/;"	f
rdbSaveStreamPEL	rdb.c	/^ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {$/;"	f
rdbSaveStringObject	rdb.c	/^ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {$/;"	f
rdbSaveToSlavesSockets	rdb.c	/^int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {$/;"	f
rdbSaveType	rdb.c	/^int rdbSaveType(rio *rdb, unsigned char type) {$/;"	f
rdbSavedObjectLen	rdb.c	/^size_t rdbSavedObjectLen(robj *o, robj *key) {$/;"	f
rdbShowGenericInfo	redis-check-rdb.c	/^void rdbShowGenericInfo(void) {$/;"	f
rdbTryIntegerEncoding	rdb.c	/^int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {$/;"	f
rdbWriteRaw	rdb.c	/^static ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len) {$/;"	f	file:
rdb_bgsave_scheduled	server.h	/^    int rdb_bgsave_scheduled;       \/* BGSAVE when possible if true. *\/$/;"	m	struct:redisServer
rdb_check_doing_string	redis-check-rdb.c	/^char *rdb_check_doing_string[] = {$/;"	v
rdb_checksum	server.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	struct:redisServer
rdb_child_exit_pipe	server.h	/^    int rdb_child_exit_pipe;        \/* Used by the diskless parent allow child exit. *\/$/;"	m	struct:redisServer
rdb_child_type	server.h	/^    int rdb_child_type;             \/* Type of save by active child. *\/$/;"	m	struct:redisServer
rdb_compression	server.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	struct:redisServer
rdb_del_sync_files	server.h	/^    int rdb_del_sync_files;         \/* Remove RDB files used only for SYNC if$/;"	m	struct:redisServer
rdb_filename	redis-cli.c	/^    char *rdb_filename;$/;"	m	struct:config	file:
rdb_filename	server.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	struct:redisServer
rdb_fsync_range	config.h	117;"	d
rdb_fsync_range	config.h	119;"	d
rdb_key_save_delay	server.h	/^    int rdb_key_save_delay;         \/* Delay in microseconds between keys while$/;"	m	struct:redisServer
rdb_load	redismodule.h	/^    RedisModuleTypeLoadFunc rdb_load;$/;"	m	struct:RedisModuleTypeMethods
rdb_load	server.h	/^    moduleTypeLoadFunc rdb_load;$/;"	m	struct:RedisModuleType
rdb_pipe_buff	server.h	/^    char *rdb_pipe_buff;            \/* In diskless replication, this buffer holds data *\/$/;"	m	struct:redisServer
rdb_pipe_bufflen	server.h	/^    int rdb_pipe_bufflen;           \/* that was read from the the rdb pipe. *\/$/;"	m	struct:redisServer
rdb_pipe_conns	server.h	/^    connection **rdb_pipe_conns;    \/* Connections which are currently the *\/$/;"	m	struct:redisServer
rdb_pipe_numconns	server.h	/^    int rdb_pipe_numconns;          \/* target of diskless rdb fork child. *\/$/;"	m	struct:redisServer
rdb_pipe_numconns_writing	server.h	/^    int rdb_pipe_numconns_writing;  \/* Number of rdb conns with pending writes. *\/$/;"	m	struct:redisServer
rdb_pipe_read	server.h	/^    int rdb_pipe_read;              \/* RDB pipe used to transfer the rdb data *\/$/;"	m	struct:redisServer
rdb_save	redismodule.h	/^    RedisModuleTypeSaveFunc rdb_save;$/;"	m	struct:RedisModuleTypeMethods
rdb_save	server.h	/^    moduleTypeSaveFunc rdb_save;$/;"	m	struct:RedisModuleType
rdb_save_incremental_fsync	server.h	/^    int rdb_save_incremental_fsync;   \/* fsync incrementally while rdb saving? *\/$/;"	m	struct:redisServer
rdb_save_time_last	server.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	struct:redisServer
rdb_save_time_start	server.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	struct:redisServer
rdb_type_string	redis-check-rdb.c	/^char *rdb_type_string[] = {$/;"	v
rdbstate	redis-check-rdb.c	/^} rdbstate;$/;"	v	typeref:struct:__anon34
read	connection.h	/^    int (*read)(struct connection *conn, void *buf, size_t buf_len);$/;"	m	struct:ConnectionType
read	rio.h	/^    size_t (*read)(struct _rio *, void *buf, size_t len);$/;"	m	struct:_rio
readArgFromStdin	redis-cli.c	/^static sds readArgFromStdin(void) {$/;"	f	file:
readArgc	redis-check-aof.c	/^int readArgc(FILE *fp, long *target) {$/;"	f
readBytes	redis-check-aof.c	/^int readBytes(FILE *fp, char *target, long length) {$/;"	f
readChildInfo	childinfo.c	/^int readChildInfo(childInfoType *information_type, size_t *cow, monotime *cow_updated, size_t *keys, double* progress) {$/;"	f
readConn	redis-cli.c	/^static ssize_t readConn(redisContext *c, char *buf, size_t len)$/;"	f	file:
readHandler	redis-benchmark.c	/^static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
readLong	redis-check-aof.c	/^int readLong(FILE *fp, char prefix, long *target) {$/;"	f
readOOMScoreAdj	server.c	/^static void readOOMScoreAdj(void) {$/;"	f	file:
readQueryFromClient	networking.c	/^void readQueryFromClient(connection *conn) {$/;"	f
readString	redis-check-aof.c	/^int readString(FILE *fp, char** target) {$/;"	f
readSyncBulkPayload	replication.c	/^void readSyncBulkPayload(connection *conn) {$/;"	f
read_handler	connection.h	/^    ConnectionCallbackFunc read_handler;$/;"	m	struct:connection
read_limit	rio.h	/^            size_t read_limit;  \/* don't allow to buffer\/read more than that *\/$/;"	m	struct:_rio::__anon37::__anon40
read_reploff	server.h	/^    long long read_reploff; \/* Read replication offset if this is a master. *\/$/;"	m	struct:client
read_so_far	rio.h	/^            size_t read_so_far; \/* amount of data read from the rio (not buffered) *\/$/;"	m	struct:_rio::__anon37::__anon40
reading	sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:
readonlyCommand	cluster.c	/^void readonlyCommand(client *c) {$/;"	f
readwriteCommand	cluster.c	/^void readwriteCommand(client *c) {$/;"	f
readyList	server.h	/^typedef struct readyList {$/;"	s
readyList	server.h	/^} readyList;$/;"	t	typeref:struct:readyList
ready_keys	server.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	struct:redisDb
ready_keys	server.h	/^    list *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	struct:redisServer
realloc	zmalloc.c	72;"	d	file:
realloc	zmalloc.c	77;"	d	file:
reason	acl.c	/^    int reason;         \/* Reason for denying the command. ACL_DENIED_*. *\/$/;"	m	struct:ACLLogEntry	file:
receiveChildInfo	childinfo.c	/^void receiveChildInfo(void) {$/;"	f
receiveSynchronousResponse	replication.c	/^char *receiveSynchronousResponse(connection *conn) {$/;"	f
recompress	quicklist.h	/^    unsigned int recompress : 1; \/* was this node previous compressed? *\/$/;"	m	struct:quicklistNode
reconnectingRedisCommand	redis-cli.c	/^static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {$/;"	f	file:
redisAeAddRead	sentinel.c	/^static void redisAeAddRead(void *privdata) {$/;"	f	file:
redisAeAddWrite	sentinel.c	/^static void redisAeAddWrite(void *privdata) {$/;"	f	file:
redisAeAttach	sentinel.c	/^static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {$/;"	f	file:
redisAeCleanup	sentinel.c	/^static void redisAeCleanup(void *privdata) {$/;"	f	file:
redisAeDelRead	sentinel.c	/^static void redisAeDelRead(void *privdata) {$/;"	f	file:
redisAeDelWrite	sentinel.c	/^static void redisAeDelWrite(void *privdata) {$/;"	f	file:
redisAeEvents	sentinel.c	/^typedef struct redisAeEvents {$/;"	s	file:
redisAeEvents	sentinel.c	/^} redisAeEvents;$/;"	t	typeref:struct:redisAeEvents	file:
redisAeReadEvent	sentinel.c	/^static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
redisAeWriteEvent	sentinel.c	/^static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
redisAsciiArt	server.c	/^void redisAsciiArt(void) {$/;"	f
redisAtomic	atomicvar.h	59;"	d
redisAtomic	atomicvar.h	87;"	d
redisAtomic	atomicvar.h	88;"	d
redisBitpos	bitops.c	/^long redisBitpos(void *s, unsigned long count, int bit) {$/;"	f
redisBuildId	release.c	/^uint64_t redisBuildId(void) {$/;"	f
redisBuildIdString	release.c	/^char *redisBuildIdString(void) {$/;"	f
redisCommand	server.h	/^struct redisCommand {$/;"	s
redisCommandProc	server.h	/^typedef void redisCommandProc(client *c);$/;"	t
redisCommandTable	server.c	/^struct redisCommand redisCommandTable[] = {$/;"	v	typeref:struct:redisCommand
redisCommunicateSystemd	server.c	/^int redisCommunicateSystemd(const char *sd_notify_msg) {$/;"	f
redisConfig	redis-benchmark.c	/^typedef struct redisConfig {$/;"	s	file:
redisConfig	redis-benchmark.c	/^} redisConfig;$/;"	t	typeref:struct:redisConfig	file:
redisDb	server.h	/^typedef struct redisDb {$/;"	s
redisDb	server.h	/^} redisDb;$/;"	t	typeref:struct:redisDb
redisDebug	server.h	2744;"	d
redisDebugMark	server.h	2746;"	d
redisError	server.h	/^struct redisError {$/;"	s
redisFork	server.c	/^int redisFork(int purpose) {$/;"	f
redisFunctionSym	server.h	/^struct redisFunctionSym {$/;"	s
redisGetKeysProc	server.h	/^typedef int redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);$/;"	t
redisGitDirty	release.c	/^char *redisGitDirty(void) {$/;"	f
redisGitSHA1	release.c	/^char *redisGitSHA1(void) {$/;"	f
redisIsSupervised	server.c	/^int redisIsSupervised(int mode) {$/;"	f
redisLrand48	rand.c	/^int32_t redisLrand48() {$/;"	f
redisMemOverhead	server.h	/^struct redisMemOverhead {$/;"	s
redisNodeFlags	cluster.c	/^struct redisNodeFlags {$/;"	s	file:
redisNodeFlagsTable	cluster.c	/^static struct redisNodeFlags redisNodeFlagsTable[] = {$/;"	v	typeref:struct:redisNodeFlags	file:
redisObject	server.h	/^typedef struct redisObject {$/;"	s
redisOp	server.h	/^typedef struct redisOp {$/;"	s
redisOp	server.h	/^} redisOp;$/;"	t	typeref:struct:redisOp
redisOpArray	server.h	/^typedef struct redisOpArray {$/;"	s
redisOpArray	server.h	/^} redisOpArray;$/;"	t	typeref:struct:redisOpArray
redisOpArrayAppend	server.c	/^int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,$/;"	f
redisOpArrayFree	server.c	/^void redisOpArrayFree(redisOpArray *oa) {$/;"	f
redisOpArrayInit	server.c	/^void redisOpArrayInit(redisOpArray *oa) {$/;"	f
redisOutOfMemoryHandler	server.c	/^void redisOutOfMemoryHandler(size_t allocation_size) {$/;"	f
redisPopcount	bitops.c	/^size_t redisPopcount(void *s, long count) {$/;"	f
redisProcTitleGetVariable	server.c	/^static sds redisProcTitleGetVariable(const sds varname, void *arg)$/;"	f	file:
redisProtocolToLuaType	scripting.c	/^char *redisProtocolToLuaType(lua_State *lua, char* reply) {$/;"	f
redisProtocolToLuaType_Aggregate	scripting.c	/^char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {$/;"	f
redisProtocolToLuaType_Bool	scripting.c	/^char *redisProtocolToLuaType_Bool(lua_State *lua, char *reply, int tf) {$/;"	f
redisProtocolToLuaType_Bulk	scripting.c	/^char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Double	scripting.c	/^char *redisProtocolToLuaType_Double(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Error	scripting.c	/^char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Int	scripting.c	/^char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Null	scripting.c	/^char *redisProtocolToLuaType_Null(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Status	scripting.c	/^char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {$/;"	f
redisServer	server.h	/^struct redisServer {$/;"	s
redisSetCpuAffinity	server.c	/^void redisSetCpuAffinity(const char *cpulist) {$/;"	f
redisSetProcTitle	server.c	/^int redisSetProcTitle(char *title) {$/;"	f
redisSortObject	server.h	/^} redisSortObject;$/;"	t	typeref:struct:_redisSortObject
redisSortOperation	server.h	/^} redisSortOperation;$/;"	t	typeref:struct:_redisSortOperation
redisSrand48	rand.c	/^void redisSrand48(int32_t seedval) {$/;"	f
redisSupervisedSystemd	server.c	/^static int redisSupervisedSystemd(void) {$/;"	f	file:
redisSupervisedUpstart	server.c	/^static int redisSupervisedUpstart(void) {$/;"	f	file:
redisTLSContextConfig	server.h	/^typedef struct redisTLSContextConfig {$/;"	s
redisTLSContextConfig	server.h	/^} redisTLSContextConfig;$/;"	t	typeref:struct:redisTLSContextConfig
redisTest	server.c	/^struct redisTest {$/;"	s	file:
redisTestProc	server.c	/^typedef int redisTestProc(int argc, char **argv, int accurate);$/;"	t	file:
redisTests	server.c	/^} redisTests[] = {$/;"	v	typeref:struct:redisTest
redis_check_aof_main	redis-check-aof.c	/^int redis_check_aof_main(int argc, char **argv) {$/;"	f
redis_check_rdb	redis-check-rdb.c	/^int redis_check_rdb(char *rdbfilename, FILE *fp) {$/;"	f
redis_check_rdb_main	redis-check-rdb.c	/^int redis_check_rdb_main(int argc, char **argv, FILE *fp) {$/;"	f
redis_config	redis-benchmark.c	/^    struct redisConfig *redis_config;$/;"	m	struct:clusterNode	typeref:struct:clusterNode::redisConfig	file:
redis_config	redis-benchmark.c	/^    struct redisConfig *redis_config;$/;"	m	struct:config	typeref:struct:config::redisConfig	file:
redis_fstat	config.h	43;"	d
redis_fstat	config.h	46;"	d
redis_fsync	config.h	95;"	d
redis_fsync	config.h	97;"	d
redis_math_random	scripting.c	/^int redis_math_random (lua_State *L) {$/;"	f
redis_math_randomseed	scripting.c	/^int redis_math_randomseed (lua_State *L) {$/;"	f
redis_set_thread_title	config.h	238;"	d
redis_set_thread_title	config.h	242;"	d
redis_set_thread_title	config.h	245;"	d
redis_set_thread_title	config.h	248;"	d
redis_set_thread_title	config.h	253;"	d
redis_set_thread_title	config.h	255;"	d
redis_stat	config.h	44;"	d
redis_stat	config.h	47;"	d
redis_tls_client_ctx	tls.c	/^SSL_CTX *redis_tls_client_ctx = NULL;$/;"	v
redis_tls_ctx	tls.c	/^SSL_CTX *redis_tls_ctx = NULL;$/;"	v
redis_unreachable	config.h	101;"	d
redis_unreachable	config.h	103;"	d
rediscmd	module.c	/^    struct redisCommand *rediscmd;$/;"	m	struct:RedisModuleCommandProxy	typeref:struct:RedisModuleCommandProxy::redisCommand	file:
refcount	ae.h	/^    int refcount; \/* refcount to prevent timer events from being$/;"	m	struct:aeTimeEvent
refcount	sentinel.c	/^    int refcount;          \/* Number of sentinelRedisInstance owners. *\/$/;"	m	struct:instanceLink	file:
refcount	server.h	/^    int refcount;$/;"	m	struct:redisObject
refreshGoodSlavesCount	replication.c	/^void refreshGoodSlavesCount(void) {$/;"	f
refs	connection.h	/^    short int refs;$/;"	m	struct:connection
registerSSLEvent	tls.c	/^void registerSSLEvent(tls_connection *conn, WantIOType want) {$/;"	f
registers	hyperloglog.c	/^    uint8_t registers[]; \/* Data bytes. *\/$/;"	m	struct:hllhdr	file:
rehashidx	dict.h	/^    long rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	struct:dict
rejectCommand	server.c	/^void rejectCommand(client *c, robj *reply) {$/;"	f
rejectCommandFormat	server.c	/^void rejectCommandFormat(client *c, const char *fmt, ...) {$/;"	f
rejected_calls	server.h	/^    long long microseconds, calls, rejected_calls, failed_calls;$/;"	m	struct:redisCommand
releaseInstanceLink	sentinel.c	/^instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)$/;"	f
releaseSentinelAddr	sentinel.c	/^void releaseSentinelAddr(sentinelAddr *sa) {$/;"	f
releaseSentinelRedisInstance	sentinel.c	/^void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {$/;"	f
release_hdr	Makefile	/^release_hdr := $(shell sh -c '.\/mkreleasehdr.sh')$/;"	m
rememberSlaveKeyWithExpire	expire.c	/^void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {$/;"	f
removeClientFromTimeoutTable	timeout.c	/^void removeClientFromTimeoutTable(client *c) {$/;"	f
removeExpire	db.c	/^int removeExpire(redisDb *db, robj *key) {$/;"	f
removeMatchingSentinelFromMaster	sentinel.c	/^int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {$/;"	f
removeRDBUsedToSyncReplicas	replication.c	/^void removeRDBUsedToSyncReplicas(void) {$/;"	f
removeSignalHandlers	server.c	/^void removeSignalHandlers(void) {$/;"	f
renameCommand	db.c	/^void renameCommand(client *c) {$/;"	f
renameGenericCommand	db.c	/^void renameGenericCommand(client *c, int nx) {$/;"	f
renamedCommandsDictType	sentinel.c	/^dictType renamedCommandsDictType = {$/;"	v
renamed_commands	sentinel.c	/^    dict *renamed_commands;     \/* Commands renamed in this instance:$/;"	m	struct:sentinelRedisInstance	file:
renamenxCommand	db.c	/^void renamenxCommand(client *c) {$/;"	f
renderCanvas	lolwut5.c	/^static sds renderCanvas(lwCanvas *canvas) {$/;"	f	file:
renderCanvas	lolwut6.c	/^static sds renderCanvas(lwCanvas *canvas) {$/;"	f	file:
repeat	redis-cli.c	/^    long repeat;$/;"	m	struct:config	file:
repl	redis-cli.c	/^static void repl(void) {$/;"	f	file:
repl1_offset	redismodule.h	/^    uint64_t repl1_offset;  \/* Main replication offset *\/$/;"	m	struct:RedisModuleReplicationInfo
repl2_offset	redismodule.h	/^    uint64_t repl2_offset;  \/* Offset of replid2 validity *\/$/;"	m	struct:RedisModuleReplicationInfo
replScriptCacheDictType	server.c	/^dictType replScriptCacheDictType = {$/;"	v
repl_ack_off	server.h	/^    long long repl_ack_off; \/* Replication ack offset, if this is a slave. *\/$/;"	m	struct:client
repl_ack_time	server.h	/^    long long repl_ack_time;\/* Replication ack time, if this is a slave. *\/$/;"	m	struct:client
repl_backlog	server.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	struct:redisServer
repl_backlog	server.h	/^    size_t repl_backlog;$/;"	m	struct:redisMemOverhead
repl_backlog_histlen	server.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	struct:redisServer
repl_backlog_idx	server.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset,$/;"	m	struct:redisServer
repl_backlog_off	server.h	/^    long long repl_backlog_off;     \/* Replication "master offset" of first$/;"	m	struct:redisServer
repl_backlog_size	server.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	struct:redisServer
repl_backlog_time_limit	server.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	struct:redisServer
repl_disable_tcp_nodelay	server.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	struct:redisServer
repl_diskless_load	server.h	/^    int repl_diskless_load;         \/* Slave parse RDB directly from the socket.$/;"	m	struct:redisServer
repl_diskless_load_enum	config.c	/^configEnum repl_diskless_load_enum[] = {$/;"	v
repl_diskless_sync	server.h	/^    int repl_diskless_sync;         \/* Master send RDB to slaves sockets directly. *\/$/;"	m	struct:redisServer
repl_diskless_sync_delay	server.h	/^    int repl_diskless_sync_delay;   \/* Delay to start a diskless repl BGSAVE. *\/$/;"	m	struct:redisServer
repl_down_since	server.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	struct:redisServer
repl_good_slaves_count	server.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	struct:redisServer
repl_id	server.h	/^    char repl_id[CONFIG_RUN_ID_SIZE+1];     \/* Replication ID. *\/$/;"	m	struct:rdbSaveInfo
repl_id_is_set	server.h	/^    int repl_id_is_set;  \/* True if repl_id field is set. *\/$/;"	m	struct:rdbSaveInfo
repl_last_partial_write	server.h	/^    long long repl_last_partial_write; \/* The last time the server did a partial write from the RDB child pipe to this replica  *\/$/;"	m	struct:client
repl_min_slaves_max_lag	server.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	struct:redisServer
repl_min_slaves_to_write	server.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	struct:redisServer
repl_no_slaves_since	server.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	struct:redisServer
repl_offset	cluster.h	/^    long long repl_offset;      \/* Last known repl offset for this node. *\/$/;"	m	struct:clusterNode
repl_offset	server.h	/^    long long repl_offset;                  \/* Replication offset. *\/$/;"	m	struct:rdbSaveInfo
repl_offset_time	cluster.h	/^    mstime_t repl_offset_time;  \/* Unix time we received offset for this node *\/$/;"	m	struct:clusterNode
repl_ping_slave_period	server.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	struct:redisServer
repl_put_online_on_ack	server.h	/^    int repl_put_online_on_ack; \/* Install slave write handler on first ACK. *\/$/;"	m	struct:client
repl_scriptcache_dict	server.h	/^    dict *repl_scriptcache_dict;        \/* SHA1 all slaves are aware of. *\/$/;"	m	struct:redisServer
repl_scriptcache_fifo	server.h	/^    list *repl_scriptcache_fifo;        \/* First in, first out LRU eviction. *\/$/;"	m	struct:redisServer
repl_scriptcache_size	server.h	/^    unsigned int repl_scriptcache_size; \/* Max number of elements. *\/$/;"	m	struct:redisServer
repl_serve_stale_data	server.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	struct:redisServer
repl_slave_ignore_maxmemory	server.h	/^    int repl_slave_ignore_maxmemory;    \/* If true slaves do not evict. *\/$/;"	m	struct:redisServer
repl_slave_lazy_flush	server.h	/^    int repl_slave_lazy_flush;          \/* Lazy FLUSHALL before loading DB? *\/$/;"	m	struct:redisServer
repl_slave_ro	server.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	struct:redisServer
repl_state	server.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	struct:redisServer
repl_state	server.h	/^} repl_state;$/;"	t	typeref:enum:__anon42
repl_stream_db	server.h	/^    int repl_stream_db;  \/* DB to select in server.master client. *\/$/;"	m	struct:rdbSaveInfo
repl_syncio_timeout	server.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	struct:redisServer
repl_timeout	server.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	struct:redisServer
repl_transfer_fd	server.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	struct:redisServer
repl_transfer_last_fsync_off	server.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	struct:redisServer
repl_transfer_lastio	server.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	struct:redisServer
repl_transfer_read	server.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	struct:redisServer
repl_transfer_s	server.h	/^    connection *repl_transfer_s;     \/* Slave -> Master SYNC connection *\/$/;"	m	struct:redisServer
repl_transfer_size	server.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	struct:redisServer
repl_transfer_tmpfile	server.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	struct:redisServer
replaceClientCommandVector	networking.c	/^void replaceClientCommandVector(client *c, int argc, robj **argv) {$/;"	f
replaceSatelliteDictKeyPtrAndOrDefragDictEntry	defrag.c	/^dictEntry* replaceSatelliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, uint64_t hash, long *defragged) {$/;"	f
replconf	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
replconfCommand	replication.c	/^void replconfCommand(client *c) {$/;"	f
repldbfd	server.h	/^    int repldbfd;           \/* Replication DB file descriptor. *\/$/;"	m	struct:client
repldboff	server.h	/^    off_t repldboff;        \/* Replication DB file offset. *\/$/;"	m	struct:client
repldbsize	server.h	/^    off_t repldbsize;       \/* Replication DB file size. *\/$/;"	m	struct:client
replica_announced	sentinel.c	/^    int replica_announced; \/* Replica announcing according to its INFO output. *\/$/;"	m	struct:sentinelRedisInstance	file:
replica_announced	server.h	/^    int replica_announced;          \/* If true, replica is announced by Sentinel *\/$/;"	m	struct:redisServer
replicaofCommand	replication.c	/^void replicaofCommand(client *c) {$/;"	f
replicas	redis-cli.c	/^    int replicas;$/;"	m	struct:clusterManagerCommand	file:
replicas_count	redis-benchmark.c	/^    int replicas_count;$/;"	m	struct:clusterNode	file:
replicas_count	redis-cli.c	/^    int replicas_count;$/;"	m	struct:clusterManagerNode	file:
replicate	redis-benchmark.c	/^    sds replicate;  \/* Master ID if node is a slave *\/$/;"	m	struct:clusterNode	file:
replicate	redis-cli.c	/^    sds replicate;  \/* Master ID if node is a slave *\/$/;"	m	struct:clusterManagerNode	file:
replicationAbortSyncTransfer	replication.c	/^void replicationAbortSyncTransfer(void) {$/;"	f
replicationCacheMaster	replication.c	/^void replicationCacheMaster(client *c) {$/;"	f
replicationCacheMasterUsingMyself	replication.c	/^void replicationCacheMasterUsingMyself(void) {$/;"	f
replicationCountAcksByOffset	replication.c	/^int replicationCountAcksByOffset(long long offset) {$/;"	f
replicationCreateMasterClient	replication.c	/^void replicationCreateMasterClient(connection *conn, int dbid) {$/;"	f
replicationCron	replication.c	/^void replicationCron(void) {$/;"	f
replicationDiscardCachedMaster	replication.c	/^void replicationDiscardCachedMaster(void) {$/;"	f
replicationEmptyDbCallback	replication.c	/^void replicationEmptyDbCallback(void *privdata) {$/;"	f
replicationFeedMonitors	replication.c	/^void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {$/;"	f
replicationFeedSlaves	replication.c	/^void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {$/;"	f
replicationFeedSlavesFromMasterStream	replication.c	/^void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen) {$/;"	f
replicationGetSlaveName	replication.c	/^char *replicationGetSlaveName(client *c) {$/;"	f
replicationGetSlaveOffset	replication.c	/^long long replicationGetSlaveOffset(void) {$/;"	f
replicationHandleMasterDisconnection	replication.c	/^void replicationHandleMasterDisconnection(void) {$/;"	f
replicationRequestAckFromSlaves	replication.c	/^void replicationRequestAckFromSlaves(void) {$/;"	f
replicationResurrectCachedMaster	replication.c	/^void replicationResurrectCachedMaster(connection *conn) {$/;"	f
replicationScriptCacheAdd	replication.c	/^void replicationScriptCacheAdd(sds sha1) {$/;"	f
replicationScriptCacheExists	replication.c	/^int replicationScriptCacheExists(sds sha1) {$/;"	f
replicationScriptCacheFlush	replication.c	/^void replicationScriptCacheFlush(void) {$/;"	f
replicationScriptCacheInit	replication.c	/^void replicationScriptCacheInit(void) {$/;"	f
replicationSendAck	replication.c	/^void replicationSendAck(void) {$/;"	f
replicationSendNewlineToMaster	replication.c	/^void replicationSendNewlineToMaster(void) {$/;"	f
replicationSetMaster	replication.c	/^void replicationSetMaster(char *ip, int port) {$/;"	f
replicationSetupSlaveForFullResync	replication.c	/^int replicationSetupSlaveForFullResync(client *slave, long long offset) {$/;"	f
replicationStartPendingFork	replication.c	/^void replicationStartPendingFork(void) {$/;"	f
replicationUnsetMaster	replication.c	/^void replicationUnsetMaster(void) {$/;"	f
replication_allowed	server.h	/^    int replication_allowed;        \/* Are we allowed to replicate? *\/$/;"	m	struct:redisServer
replid	server.h	/^    char replid[CONFIG_RUN_ID_SIZE+1];  \/* My current replication ID. *\/$/;"	m	struct:redisServer
replid	server.h	/^    char replid[CONFIG_RUN_ID_SIZE+1]; \/* Master replication ID (if master). *\/$/;"	m	struct:client
replid1	redismodule.h	/^    char *replid1;          \/* Main replication ID *\/$/;"	m	struct:RedisModuleReplicationInfo
replid2	redismodule.h	/^    char *replid2;          \/* Secondary replication ID *\/$/;"	m	struct:RedisModuleReplicationInfo
replid2	server.h	/^    char replid2[CONFIG_RUN_ID_SIZE+1]; \/* replid inherited from master*\/$/;"	m	struct:redisServer
reploff	server.h	/^    long long reploff;      \/* Applied replication offset if this is a master. *\/$/;"	m	struct:client
reploffset	server.h	/^    long long reploffset;   \/* Replication offset to reach. *\/$/;"	m	struct:blockingState
replpreamble	server.h	/^    sds replpreamble;       \/* Replication DB preamble. *\/$/;"	m	struct:client
replstate	server.h	/^    int replstate;          \/* Replication state if this is a slave. *\/$/;"	m	struct:client
reply	server.h	/^    list *reply;            \/* List of reply objects to send to the client. *\/$/;"	m	struct:client
replyToBlockedClientTimedOut	blocked.c	/^void replyToBlockedClientTimedOut(client *c) {$/;"	f
reply_bytes	server.h	/^    unsigned long long reply_bytes; \/* Tot bytes of objects in reply list. *\/$/;"	m	struct:client
reply_callback	module.c	/^    RedisModuleCmdFunc reply_callback; \/* Reply callback on normal completion.*\/$/;"	m	struct:RedisModuleBlockedClient	file:
reply_client	module.c	/^    client *reply_client;           \/* Fake client used to accumulate replies$/;"	m	struct:RedisModuleBlockedClient	file:
representClusterNodeFlags	cluster.c	/^sds representClusterNodeFlags(sds ci, uint16_t flags) {$/;"	f
reqtype	server.h	/^    int reqtype;            \/* Request protocol type: PROTO_REQ_* *\/$/;"	m	struct:client
requested_section	module.c	/^    const char *requested_section;$/;"	m	struct:RedisModuleInfoCtx	file:
requests	redis-benchmark.c	/^    int requests;$/;"	m	struct:config	file:
requests_finished	redis-benchmark.c	/^    redisAtomic int requests_finished;$/;"	m	struct:config	file:
requests_issued	redis-benchmark.c	/^    redisAtomic int requests_issued;$/;"	m	struct:config	file:
requirepass	server.h	/^    sds requirepass;              \/* Remember the cleartext password set with$/;"	m	struct:redisServer
reset	setproctitle.c	/^	_Bool reset;$/;"	m	struct:__anon56	file:
resetChildState	server.c	/^void resetChildState() {$/;"	f
resetClient	networking.c	/^void resetClient(client *c) {$/;"	f
resetClient	redis-benchmark.c	/^static void resetClient(client c) {$/;"	f	file:
resetCommand	networking.c	/^void resetCommand(client *c) {$/;"	f
resetCommandTableStats	server.c	/^void resetCommandTableStats(void) {$/;"	f
resetErrorTableStats	server.c	/^void resetErrorTableStats(void) {$/;"	f
resetLuaClient	scripting.c	/^void resetLuaClient(void) {$/;"	f
resetManualFailover	cluster.c	/^void resetManualFailover(void) {$/;"	f
resetServerSaveParams	config.c	/^void resetServerSaveParams(void) {$/;"	f
resetServerStats	server.c	/^void resetServerStats(void) {$/;"	f
resizeReplicationBacklog	replication.c	/^void resizeReplicationBacklog(long long newsize) {$/;"	f
resolve_hostnames	sentinel.c	/^    int resolve_hostnames;       \/* Support use of hostnames, assuming DNS is well configured. *\/$/;"	m	struct:sentinelState	file:
resp	server.h	/^    int resp;               \/* RESP protocol version. Can be 2 or 3. *\/$/;"	m	struct:client
resp3	redis-cli.c	/^    int resp3;$/;"	m	struct:config	file:
restartAOFAfterSYNC	replication.c	/^void restartAOFAfterSYNC() {$/;"	f
restartServer	server.c	/^int restartServer(int flags, mstime_t delay) {$/;"	f
restoreCommand	cluster.c	/^void restoreCommand(client *c) {$/;"	f
restoreDbBackup	db.c	/^void restoreDbBackup(dbBackup *buckup) {$/;"	f
retainOriginalCommandVector	networking.c	/^static void retainOriginalCommandVector(client *c) {$/;"	f	file:
retry_num	sentinel.c	/^    int retry_num;          \/* Number of times we tried to execute it. *\/$/;"	m	struct:sentinelScriptJob	file:
retrycount	server.h	/^    *time, *pxat, *px, *retrycount, *force, *justid, $/;"	m	struct:sharedObjectsStruct
rev	dict.c	/^static unsigned long rev(unsigned long v) {$/;"	f	file:
rev	stream.h	/^    int rev;                \/* True if iterating end to start (reverse). *\/$/;"	m	struct:streamIterator
rev8	crcspeed.c	/^static inline uint64_t rev8(uint64_t a) {$/;"	f	file:
revokeClientAuthentication	module.c	/^void revokeClientAuthentication(client *c) {$/;"	f
rewrite	config.c	/^    void (*rewrite)(typeData data, const char *name, struct rewriteConfigState *state);$/;"	m	struct:typeInterface	file:
rewriteAppendOnlyFile	aof.c	/^int rewriteAppendOnlyFile(char *filename) {$/;"	f
rewriteAppendOnlyFileBackground	aof.c	/^int rewriteAppendOnlyFileBackground(void) {$/;"	f
rewriteAppendOnlyFileRio	aof.c	/^int rewriteAppendOnlyFileRio(rio *aof) {$/;"	f
rewriteClientCommandArgument	networking.c	/^void rewriteClientCommandArgument(client *c, int i, robj *newval) {$/;"	f
rewriteClientCommandVector	networking.c	/^void rewriteClientCommandVector(client *c, int argc, ...) {$/;"	f
rewriteConfigSentinelOption	sentinel.c	/^void rewriteConfigSentinelOption(struct rewriteConfigState *state) {$/;"	f
rewriteHashObject	aof.c	/^int rewriteHashObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteListObject	aof.c	/^int rewriteListObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteModuleObject	aof.c	/^int rewriteModuleObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteSetObject	aof.c	/^int rewriteSetObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteSortedSetObject	aof.c	/^int rewriteSortedSetObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteStreamObject	aof.c	/^int rewriteStreamObject(rio *r, robj *key, robj *o) {$/;"	f
rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
ri	module.c	/^    raxIterator ri;$/;"	m	struct:RedisModuleDictIter	file:
ri	stream.h	/^    raxIterator ri;         \/* Rax iterator. *\/$/;"	m	struct:streamIterator
right	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
rio	redis-check-rdb.c	/^    rio *rio;$/;"	m	struct:__anon34	file:
rio	rio.h	/^typedef struct _rio rio;$/;"	t	typeref:struct:_rio
rio	server.h	/^    rio *rio;           \/* Rio stream. *\/$/;"	m	struct:RedisModuleIO
rioBufferFlush	rio.c	/^static int rioBufferFlush(rio *r) {$/;"	f	file:
rioBufferIO	rio.c	/^static const rio rioBufferIO = {$/;"	v	file:
rioBufferRead	rio.c	/^static size_t rioBufferRead(rio *r, void *buf, size_t len) {$/;"	f	file:
rioBufferTell	rio.c	/^static off_t rioBufferTell(rio *r) {$/;"	f	file:
rioBufferWrite	rio.c	/^static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:
rioClearErrors	rio.h	/^static inline void rioClearErrors(rio *r) {$/;"	f
rioConnFlush	rio.c	/^static int rioConnFlush(rio *r) {$/;"	f	file:
rioConnIO	rio.c	/^static const rio rioConnIO = {$/;"	v	file:
rioConnRead	rio.c	/^static size_t rioConnRead(rio *r, void *buf, size_t len) {$/;"	f	file:
rioConnTell	rio.c	/^static off_t rioConnTell(rio *r) {$/;"	f	file:
rioConnWrite	rio.c	/^static size_t rioConnWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:
rioFdFlush	rio.c	/^static int rioFdFlush(rio *r) {$/;"	f	file:
rioFdIO	rio.c	/^static const rio rioFdIO = {$/;"	v	file:
rioFdRead	rio.c	/^static size_t rioFdRead(rio *r, void *buf, size_t len) {$/;"	f	file:
rioFdTell	rio.c	/^static off_t rioFdTell(rio *r) {$/;"	f	file:
rioFdWrite	rio.c	/^static size_t rioFdWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:
rioFileFlush	rio.c	/^static int rioFileFlush(rio *r) {$/;"	f	file:
rioFileIO	rio.c	/^static const rio rioFileIO = {$/;"	v	file:
rioFileRead	rio.c	/^static size_t rioFileRead(rio *r, void *buf, size_t len) {$/;"	f	file:
rioFileTell	rio.c	/^static off_t rioFileTell(rio *r) {$/;"	f	file:
rioFileWrite	rio.c	/^static size_t rioFileWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:
rioFlush	rio.h	/^static inline int rioFlush(rio *r) {$/;"	f
rioFreeConn	rio.c	/^void rioFreeConn(rio *r, sds *remaining) {$/;"	f
rioFreeFd	rio.c	/^void rioFreeFd(rio *r) {$/;"	f
rioGenericUpdateChecksum	rio.c	/^void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {$/;"	f
rioGetReadError	rio.h	/^static inline int rioGetReadError(rio *r) {$/;"	f
rioGetWriteError	rio.h	/^static inline int rioGetWriteError(rio *r) {$/;"	f
rioInitWithBuffer	rio.c	/^void rioInitWithBuffer(rio *r, sds s) {$/;"	f
rioInitWithConn	rio.c	/^void rioInitWithConn(rio *r, connection *conn, size_t read_limit) {$/;"	f
rioInitWithFd	rio.c	/^void rioInitWithFd(rio *r, int fd) {$/;"	f
rioInitWithFile	rio.c	/^void rioInitWithFile(rio *r, FILE *fp) {$/;"	f
rioRead	rio.h	/^static inline size_t rioRead(rio *r, void *buf, size_t len) {$/;"	f
rioSetAutoSync	rio.c	/^void rioSetAutoSync(rio *r, off_t bytes) {$/;"	f
rioTell	rio.h	/^static inline off_t rioTell(rio *r) {$/;"	f
rioWrite	rio.h	/^static inline size_t rioWrite(rio *r, const void *buf, size_t len) {$/;"	f
rioWriteBulkCount	rio.c	/^size_t rioWriteBulkCount(rio *r, char prefix, long count) {$/;"	f
rioWriteBulkDouble	rio.c	/^size_t rioWriteBulkDouble(rio *r, double d) {$/;"	f
rioWriteBulkLongLong	rio.c	/^size_t rioWriteBulkLongLong(rio *r, long long l) {$/;"	f
rioWriteBulkObject	aof.c	/^int rioWriteBulkObject(rio *r, robj *obj) {$/;"	f
rioWriteBulkStreamID	aof.c	/^int rioWriteBulkStreamID(rio *r,streamID *id) {$/;"	f
rioWriteBulkString	rio.c	/^size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {$/;"	f
rioWriteHashIteratorCursor	aof.c	/^static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {$/;"	f	file:
rioWriteStreamEmptyConsumer	aof.c	/^int rioWriteStreamEmptyConsumer(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer) {$/;"	f
rioWriteStreamPendingEntry	aof.c	/^int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {$/;"	f
robj	server.h	/^} robj;$/;"	t	typeref:struct:redisObject
rol	sha1.c	31;"	d	file:
roleCommand	replication.c	/^void roleCommand(client *c) {$/;"	f
role_reported	sentinel.c	/^    int role_reported;$/;"	m	struct:sentinelRedisInstance	file:
role_reported_time	sentinel.c	/^    mstime_t role_reported_time;$/;"	m	struct:sentinelRedisInstance	file:
roslaveerr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
rpop	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
rpopCommand	server.h	/^                        *lpopCommand, *rpopCommand, *zpopminCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
rpopCommand	t_list.c	/^void rpopCommand(client *c) {$/;"	f
rpoplpush	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
rpoplpushCommand	server.h	/^                        *xgroupCommand, *rpoplpushCommand, *lmoveCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
rpoplpushCommand	t_list.c	/^void rpoplpushCommand(client *c) {$/;"	f
rpushCommand	t_list.c	/^void rpushCommand(client *c) {$/;"	f
rpushxCommand	t_list.c	/^void rpushxCommand(client *c) {$/;"	f
rs	module.c	/^            zrangespec rs;         \/* Score range. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
rss_extra	server.h	/^    float rss_extra;$/;"	m	struct:redisMemOverhead
rss_extra_bytes	server.h	/^    size_t rss_extra_bytes;$/;"	m	struct:redisMemOverhead
rt	rax.h	/^    rax *rt;                \/* Radix tree we are iterating. *\/$/;"	m	struct:raxIterator
run_with_period	server.h	494;"	d
runid	sentinel.c	/^    char *runid;    \/* Run ID of this instance, or unique ID if is a Sentinel.*\/$/;"	m	struct:sentinelRedisInstance	file:
runid	sentinel.c	/^    char *runid;$/;"	m	struct:sentinelLeader	file:
runid	server.h	/^    char runid[CONFIG_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	struct:redisServer
running_scripts	sentinel.c	/^    int running_scripts;    \/* Number of scripts in execution right now. *\/$/;"	m	struct:sentinelState	file:
s64	dict.h	/^        int64_t s64;$/;"	m	union:dictEntry::__anon18
s_down_since_time	sentinel.c	/^    mstime_t s_down_since_time; \/* Subjectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:
s_free	sdsalloc.h	47;"	d
s_free_usable	sdsalloc.h	52;"	d
s_malloc	sdsalloc.h	43;"	d
s_malloc_usable	sdsalloc.h	48;"	d
s_realloc	sdsalloc.h	44;"	d
s_realloc_usable	sdsalloc.h	49;"	d
s_trymalloc	sdsalloc.h	45;"	d
s_trymalloc_usable	sdsalloc.h	50;"	d
s_tryrealloc	sdsalloc.h	46;"	d
s_tryrealloc_usable	sdsalloc.h	51;"	d
saddCommand	t_set.c	/^void saddCommand(client *c) {$/;"	f
safe	dict.h	/^    int table, safe;$/;"	m	struct:dictIterator
sameobjecterr	server.h	/^    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
sample	sparkline.h	/^struct sample {$/;"	s
samples	latency.h	/^    struct latencySample samples[LATENCY_TS_LEN]; \/* Latest history. *\/$/;"	m	struct:latencyTimeSeries	typeref:struct:latencyTimeSeries::latencySample
samples	latency.h	/^    uint32_t samples;       \/* Number of non-zero samples. *\/$/;"	m	struct:latencyStats
samples	server.h	/^        long long samples[STATS_METRIC_SAMPLES];$/;"	m	struct:redisServer::__anon47
samples	sparkline.h	/^    struct sample *samples;$/;"	m	struct:sequence	typeref:struct:sequence::sample
sanitize_dump_payload	server.h	/^    int sanitize_dump_payload;      \/* Enables deep sanitization for ziplist and listpack in RDB and RESTORE. *\/$/;"	m	struct:redisServer
sanitize_dump_payload_enum	config.c	/^configEnum sanitize_dump_payload_enum[] = {$/;"	v
save	redis-benchmark.c	/^    sds save;$/;"	m	struct:redisConfig	file:
saveCommand	rdb.c	/^void saveCommand(client *c) {$/;"	f
saved_oparray	module.c	/^    redisOpArray saved_oparray;    \/* When propagating commands in a callback$/;"	m	struct:RedisModuleCtx	file:
saveparam	server.h	/^struct saveparam {$/;"	s
saveparams	server.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::saveparam
saveparamslen	server.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	struct:redisServer
scanCallback	db.c	/^void scanCallback(void *privdata, const dictEntry *de) {$/;"	f
scanCommand	db.c	/^void scanCommand(client *c) {$/;"	f
scanDatabaseForReadyLists	db.c	/^void scanDatabaseForReadyLists(redisDb *db) {$/;"	f
scanGenericCommand	db.c	/^void scanGenericCommand(client *c, robj *o, unsigned long cursor) {$/;"	f
scanLaterHash	defrag.c	/^long scanLaterHash(robj *ob, unsigned long *cursor) {$/;"	f
scanLaterHashCallback	defrag.c	/^void scanLaterHashCallback(void *privdata, const dictEntry *_de) {$/;"	f
scanLaterList	defrag.c	/^long scanLaterList(robj *ob, unsigned long *cursor, long long endtime, long long *defragged) {$/;"	f
scanLaterSet	defrag.c	/^long scanLaterSet(robj *ob, unsigned long *cursor) {$/;"	f
scanLaterSetCallback	defrag.c	/^void scanLaterSetCallback(void *privdata, const dictEntry *_de) {$/;"	f
scanLaterStreamListpacks	defrag.c	/^int scanLaterStreamListpacks(robj *ob, unsigned long *cursor, long long endtime, long long *defragged) {$/;"	f
scanLaterZset	defrag.c	/^long scanLaterZset(robj *ob, unsigned long *cursor) {$/;"	f
scanLaterZsetCallback	defrag.c	/^void scanLaterZsetCallback(void *privdata, const dictEntry *_de) {$/;"	f
scanLaterZsetData	defrag.c	/^} scanLaterZsetData;$/;"	t	typeref:struct:__anon16	file:
scanMode	redis-cli.c	/^static void scanMode(void) {$/;"	f	file:
scan_mode	redis-cli.c	/^    int scan_mode;$/;"	m	struct:config	file:
scardCommand	t_set.c	/^void scardCommand(client *c) {$/;"	f
score	geo.h	/^    double score;$/;"	m	struct:geoPoint
score	server.h	/^        double score;$/;"	m	union:_redisSortObject::__anon49
score	server.h	/^    double score;$/;"	m	struct:zskiplistNode
score	t_zset.c	/^    double score;$/;"	m	struct:__anon67	file:
scoresOfGeoHashBox	geo.c	/^void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) {$/;"	f
script	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
scriptCommand	scripting.c	/^void scriptCommand(client *c) {$/;"	f
scriptingEnableGlobalsProtection	scripting.c	/^void scriptingEnableGlobalsProtection(lua_State *lua) {$/;"	f
scriptingInit	scripting.c	/^void scriptingInit(int setup) {$/;"	f
scriptingRelease	scripting.c	/^void scriptingRelease(int async) {$/;"	f
scriptingReset	scripting.c	/^void scriptingReset(int async) {$/;"	f
scripts_queue	sentinel.c	/^    list *scripts_queue;            \/* Queue of user scripts to execute. *\/$/;"	m	struct:sentinelState	file:
sdiffCommand	t_set.c	/^void sdiffCommand(client *c) {$/;"	f
sdiffstoreCommand	t_set.c	/^void sdiffstoreCommand(client *c) {$/;"	f
sdigits10	util.c	/^uint32_t sdigits10(int64_t v) {$/;"	f
sds	config.c	/^    sdsConfigData sds;$/;"	m	union:typeData	file:
sds	sds.h	/^typedef char *sds;$/;"	t
sdsAllocPtr	sds.c	/^void *sdsAllocPtr(sds s) {$/;"	f
sdsAllocSize	sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsCatColorizedLdbReply	redis-cli.c	/^sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {$/;"	f
sdsConfigData	config.c	/^typedef struct sdsConfigData {$/;"	s	file:
sdsConfigData	config.c	/^} sdsConfigData;$/;"	t	typeref:struct:sdsConfigData	file:
sdsEncodedObject	server.h	2007;"	d
sdsHdrSize	sds.c	/^static inline int sdsHdrSize(char type) {$/;"	f	file:
sdsIncrLen	sds.c	/^void sdsIncrLen(sds s, ssize_t incr) {$/;"	f
sdsMakeRoomFor	sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsReplyDictType	server.c	/^dictType sdsReplyDictType = {$/;"	v
sdsReqType	sds.c	/^static inline char sdsReqType(size_t string_size) {$/;"	f	file:
sdsTest	sds.c	/^int sdsTest(int argc, char **argv, int accurate) {$/;"	f
sdsTestTemplateCallback	sds.c	/^static sds sdsTestTemplateCallback(sds varname, void *arg) {$/;"	f	file:
sdsTypeMaxSize	sds.c	/^static inline size_t sdsTypeMaxSize(char type) {$/;"	f	file:
sdsZmallocSize	networking.c	/^size_t sdsZmallocSize(sds s) {$/;"	f
sds_free	sds.c	/^void sds_free(void *ptr) { s_free(ptr); }$/;"	f
sds_malloc	sds.c	/^void *sds_malloc(size_t size) { return s_malloc(size); }$/;"	f
sds_realloc	sds.c	/^void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }$/;"	f
sdsalloc	sds.h	/^static inline size_t sdsalloc(const sds s) {$/;"	f
sdsavail	sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatcolor	redis-cli.c	/^sds sdscatcolor(sds o, char *s, size_t len, char *color) {$/;"	f
sdscatfmt	sds.c	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f
sdscatlen	sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	sds.c	/^void sdsclear(sds s) {$/;"	f
sdscmp	sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscmplex	t_zset.c	/^int sdscmplex(sds a, sds b) {$/;"	f
sdscpy	sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	sds.c	/^sds sdsempty(void) {$/;"	f
sdsfree	sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr16	sds.h	/^struct __attribute__ ((__packed__)) sdshdr16 {$/;"	s
sdshdr32	sds.h	/^struct __attribute__ ((__packed__)) sdshdr32 {$/;"	s
sdshdr5	sds.h	/^struct __attribute__ ((__packed__)) sdshdr5 {$/;"	s
sdshdr64	sds.h	/^struct __attribute__ ((__packed__)) sdshdr64 {$/;"	s
sdshdr8	sds.h	/^struct __attribute__ ((__packed__)) sdshdr8 {$/;"	s
sdsinclen	sds.h	/^static inline void sdsinclen(sds s, size_t inc) {$/;"	f
sdsjoin	sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdsjoinsds	sds.c	/^sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {$/;"	f
sdslen	sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsll2str	sds.c	/^int sdsll2str(char *s, long long value) {$/;"	f
sdsmapchars	sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	sds.c	/^void sdsrange(sds s, ssize_t start, ssize_t end) {$/;"	f
sdssetalloc	sds.h	/^static inline void sdssetalloc(sds s, size_t newlen) {$/;"	f
sdssetlen	sds.h	/^static inline void sdssetlen(sds s, size_t newlen) {$/;"	f
sdssplitargs	sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	sds.c	/^sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {$/;"	f
sdstemplate	sds.c	/^sds sdstemplate(const char *template, sdstemplate_callback_t cb_func, void *cb_arg)$/;"	f
sdstemplate_callback_t	sds.h	/^typedef sds (*sdstemplate_callback_t)(const sds variable, void *arg);$/;"	t
sdstolower	sds.c	/^void sdstolower(sds s) {$/;"	f
sdstoupper	sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstrim	sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdstrynewlen	sds.c	/^sds sdstrynewlen(const void *init, size_t initlen) {$/;"	f
sdsull2str	sds.c	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f
sdsupdatelen	sds.c	/^void sdsupdatelen(sds s) {$/;"	f
searchPreMonitorCfgName	sentinel.c	/^int searchPreMonitorCfgName(const char *name) {$/;"	f
second_replid_offset	server.h	/^    long long second_replid_offset; \/* Accept offsets up to this for replid2. *\/$/;"	m	struct:redisServer
seconds	server.h	/^    time_t seconds;$/;"	m	struct:saveparam
section_doc	modules/gendoc.rb	/^def section_doc(src, i)$/;"	f
section_name_to_id	modules/gendoc.rb	/^def section_name_to_id(name)$/;"	f
sections	module.c	/^    int sections;       \/* number of sections we collected so far *\/$/;"	m	struct:RedisModuleInfoCtx	file:
securityWarningCommand	networking.c	/^void securityWarningCommand(client *c) {$/;"	f
seen_time	stream.h	/^    mstime_t seen_time;         \/* Last time this consumer was active. *\/$/;"	m	struct:streamConsumer
select	server.h	/^    *select[PROTO_SHARED_SELECT_CMDS],$/;"	m	struct:sharedObjectsStruct
selectCommand	db.c	/^void selectCommand(client *c) {$/;"	f
selectDb	db.c	/^int selectDb(client *c, int id) {$/;"	f
sendBulkToSlave	replication.c	/^void sendBulkToSlave(connection *conn) {$/;"	f
sendCapa	redis-cli.c	/^void sendCapa() {$/;"	f
sendChildCowInfo	server.c	/^void sendChildCowInfo(childInfoType info_type, char *pname) {$/;"	f
sendChildInfo	server.c	/^void sendChildInfo(childInfoType info_type, size_t keys, char *pname) {$/;"	f
sendChildInfoGeneric	childinfo.c	/^void sendChildInfoGeneric(childInfoType info_type, size_t keys, double progress, char *pname) {$/;"	f
sendCommand	replication.c	/^char *sendCommand(connection *conn, ...) {$/;"	f
sendCommandArgv	replication.c	/^char *sendCommandArgv(connection *conn, int argc, char **argv, size_t *argv_lens) {$/;"	f
sendCommandRaw	replication.c	/^char* sendCommandRaw(connection *conn, sds cmd) {$/;"	f
sendRdbOnly	redis-cli.c	/^void sendRdbOnly(void) {$/;"	f
sendReplconf	redis-cli.c	/^void sendReplconf(const char* arg1, const char* arg2) {$/;"	f
sendReplyToClient	networking.c	/^void sendReplyToClient(connection *conn) {$/;"	f
sendScan	redis-cli.c	/^static redisReply *sendScan(unsigned long long *it) {$/;"	f	file:
sendSync	redis-cli.c	/^unsigned long long sendSync(redisContext *c, char *out_eof) {$/;"	f
sendTrackingMessage	tracking.c	/^void sendTrackingMessage(client *c, char *keyname, size_t keylen, int proto) {$/;"	f
sender	cluster.h	/^    char sender[CLUSTER_NAMELEN]; \/* Name of the sender node *\/$/;"	m	struct:__anon12
sentinel	sentinel.c	/^} sentinel;$/;"	v	typeref:struct:sentinelState
sentinelAbortFailover	sentinel.c	/^void sentinelAbortFailover(sentinelRedisInstance *ri) {$/;"	f
sentinelAddFlagsToDictOfRedisInstances	sentinel.c	/^void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f
sentinelAddr	sentinel.c	/^typedef struct sentinelAddr {$/;"	s	file:
sentinelAddr	sentinel.c	/^} sentinelAddr;$/;"	t	typeref:struct:sentinelAddr	file:
sentinelAddrEqualsHostname	sentinel.c	/^int sentinelAddrEqualsHostname(sentinelAddr *a, char *hostname) {$/;"	f
sentinelAddrIsEqual	sentinel.c	/^int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {$/;"	f
sentinelAskMasterStateToOtherSentinels	sentinel.c	/^void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {$/;"	f
sentinelCallClientReconfScript	sentinel.c	/^void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {$/;"	f
sentinelCheckConfigFile	sentinel.c	/^void sentinelCheckConfigFile(void) {$/;"	f
sentinelCheckCreateInstanceErrors	sentinel.c	/^const char *sentinelCheckCreateInstanceErrors(int role) {$/;"	f
sentinelCheckObjectivelyDown	sentinel.c	/^void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {$/;"	f
sentinelCheckSubjectivelyDown	sentinel.c	/^void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {$/;"	f
sentinelCheckTiltCondition	sentinel.c	/^void sentinelCheckTiltCondition(void) {$/;"	f
sentinelCollectTerminatedScripts	sentinel.c	/^void sentinelCollectTerminatedScripts(void) {$/;"	f
sentinelCommand	sentinel.c	/^void sentinelCommand(client *c) {$/;"	f
sentinelConfig	server.h	/^struct sentinelConfig {$/;"	s
sentinelConfigGetCommand	sentinel.c	/^void sentinelConfigGetCommand(client *c) {$/;"	f
sentinelConfigSetCommand	sentinel.c	/^void sentinelConfigSetCommand(client *c) {$/;"	f
sentinelDelFlagsToDictOfRedisInstances	sentinel.c	/^void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f
sentinelDiscardReplyCallback	sentinel.c	/^void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelDisconnectCallback	sentinel.c	/^void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {$/;"	f
sentinelDropConnections	sentinel.c	/^int sentinelDropConnections(void) {$/;"	f
sentinelEvent	sentinel.c	/^void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,$/;"	f
sentinelFailoverDetectEnd	sentinel.c	/^void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {$/;"	f
sentinelFailoverReconfNextSlave	sentinel.c	/^void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {$/;"	f
sentinelFailoverSelectSlave	sentinel.c	/^void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverSendSlaveOfNoOne	sentinel.c	/^void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverStateMachine	sentinel.c	/^void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverStateStr	sentinel.c	/^const char *sentinelFailoverStateStr(int state) {$/;"	f
sentinelFailoverSwitchToPromotedSlave	sentinel.c	/^void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {$/;"	f
sentinelFailoverWaitPromotion	sentinel.c	/^void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverWaitStart	sentinel.c	/^void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {$/;"	f
sentinelFlushConfig	sentinel.c	/^void sentinelFlushConfig(void) {$/;"	f
sentinelForceHelloUpdateDictOfRedisInstances	sentinel.c	/^void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {$/;"	f
sentinelForceHelloUpdateForMaster	sentinel.c	/^int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {$/;"	f
sentinelGenerateInitialMonitorEvents	sentinel.c	/^void sentinelGenerateInitialMonitorEvents(void) {$/;"	f
sentinelGetCurrentMasterAddress	sentinel.c	/^sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {$/;"	f
sentinelGetLeader	sentinel.c	/^char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {$/;"	f
sentinelGetMasterByName	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByName(char *name) {$/;"	f
sentinelGetMasterByNameOrReplyError	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,$/;"	f
sentinelGetScriptListNodeByPid	sentinel.c	/^listNode *sentinelGetScriptListNodeByPid(pid_t pid) {$/;"	f
sentinelHandleConfiguration	sentinel.c	/^const char *sentinelHandleConfiguration(char **argv, int argc) {$/;"	f
sentinelHandleDictOfRedisInstances	sentinel.c	/^void sentinelHandleDictOfRedisInstances(dict *instances) {$/;"	f
sentinelHandleRedisInstance	sentinel.c	/^void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {$/;"	f
sentinelInfoCommand	sentinel.c	/^void sentinelInfoCommand(client *c) {$/;"	f
sentinelInfoReplyCallback	sentinel.c	/^void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelInstanceMapCommand	sentinel.c	/^char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {$/;"	f
sentinelIsQuorumReachable	sentinel.c	/^int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {$/;"	f
sentinelIsRunning	sentinel.c	/^void sentinelIsRunning(void) {$/;"	f
sentinelKillTimedoutScripts	sentinel.c	/^void sentinelKillTimedoutScripts(void) {$/;"	f
sentinelLeader	sentinel.c	/^struct sentinelLeader {$/;"	s	file:
sentinelLeaderIncr	sentinel.c	/^int sentinelLeaderIncr(dict *counters, char *runid) {$/;"	f
sentinelLinkEstablishedCallback	sentinel.c	/^void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {$/;"	f
sentinelLoadQueueEntry	server.h	/^struct sentinelLoadQueueEntry {$/;"	s
sentinelMasterLooksSane	sentinel.c	/^int sentinelMasterLooksSane(sentinelRedisInstance *master) {$/;"	f
sentinelPendingScriptsCommand	sentinel.c	/^void sentinelPendingScriptsCommand(client *c) {$/;"	f
sentinelPingReplyCallback	sentinel.c	/^void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelProcessHelloMessage	sentinel.c	/^void sentinelProcessHelloMessage(char *hello, int hello_len) {$/;"	f
sentinelPropagateDownAfterPeriod	sentinel.c	/^void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {$/;"	f
sentinelPublishCommand	sentinel.c	/^void sentinelPublishCommand(client *c) {$/;"	f
sentinelPublishReplyCallback	sentinel.c	/^void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelReceiveHelloMessages	sentinel.c	/^void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelReceiveIsMasterDownReply	sentinel.c	/^void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelReconnectInstance	sentinel.c	/^void sentinelReconnectInstance(sentinelRedisInstance *ri) {$/;"	f
sentinelRedisInstance	sentinel.c	/^typedef struct sentinelRedisInstance {$/;"	s	file:
sentinelRedisInstance	sentinel.c	/^} sentinelRedisInstance;$/;"	t	typeref:struct:sentinelRedisInstance	file:
sentinelRedisInstanceLookupSlave	sentinel.c	/^sentinelRedisInstance *sentinelRedisInstanceLookupSlave($/;"	f
sentinelRedisInstanceNoDownFor	sentinel.c	/^int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {$/;"	f
sentinelRedisInstanceTypeStr	sentinel.c	/^const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {$/;"	f
sentinelRefreshInstanceInfo	sentinel.c	/^void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {$/;"	f
sentinelReleaseScriptJob	sentinel.c	/^void sentinelReleaseScriptJob(sentinelScriptJob *sj) {$/;"	f
sentinelResetMaster	sentinel.c	/^void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {$/;"	f
sentinelResetMasterAndChangeAddress	sentinel.c	/^int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *hostname, int port) {$/;"	f
sentinelResetMastersByPattern	sentinel.c	/^int sentinelResetMastersByPattern(char *pattern, int flags) {$/;"	f
sentinelRoleCommand	sentinel.c	/^void sentinelRoleCommand(client *c) {$/;"	f
sentinelRunPendingScripts	sentinel.c	/^void sentinelRunPendingScripts(void) {$/;"	f
sentinelScheduleScriptExecution	sentinel.c	/^void sentinelScheduleScriptExecution(char *path, ...) {$/;"	f
sentinelScriptJob	sentinel.c	/^typedef struct sentinelScriptJob {$/;"	s	file:
sentinelScriptJob	sentinel.c	/^} sentinelScriptJob;$/;"	t	typeref:struct:sentinelScriptJob	file:
sentinelScriptRetryDelay	sentinel.c	/^mstime_t sentinelScriptRetryDelay(int retry_num) {$/;"	f
sentinelSelectSlave	sentinel.c	/^sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {$/;"	f
sentinelSendAuthIfNeeded	sentinel.c	/^void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {$/;"	f
sentinelSendHello	sentinel.c	/^int sentinelSendHello(sentinelRedisInstance *ri) {$/;"	f
sentinelSendPeriodicCommands	sentinel.c	/^void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {$/;"	f
sentinelSendPing	sentinel.c	/^int sentinelSendPing(sentinelRedisInstance *ri) {$/;"	f
sentinelSendSlaveOf	sentinel.c	/^int sentinelSendSlaveOf(sentinelRedisInstance *ri, const sentinelAddr *addr) {$/;"	f
sentinelSetClientName	sentinel.c	/^void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {$/;"	f
sentinelSetCommand	sentinel.c	/^void sentinelSetCommand(client *c) {$/;"	f
sentinelSimFailureCrash	sentinel.c	/^void sentinelSimFailureCrash(void) {$/;"	f
sentinelStartFailover	sentinel.c	/^void sentinelStartFailover(sentinelRedisInstance *master) {$/;"	f
sentinelStartFailoverIfNeeded	sentinel.c	/^int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {$/;"	f
sentinelState	sentinel.c	/^struct sentinelState {$/;"	s	file:
sentinelTimer	sentinel.c	/^void sentinelTimer(void) {$/;"	f
sentinelTryConnectionSharing	sentinel.c	/^int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {$/;"	f
sentinelUpdateSentinelAddressInAllMasters	sentinel.c	/^int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {$/;"	f
sentinelVoteLeader	sentinel.c	/^char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {$/;"	f
sentinel_auth_pass	sentinel.c	/^    char *sentinel_auth_pass;    \/* Password to use for AUTH against other sentinel *\/$/;"	m	struct:sentinelState	file:
sentinel_auth_user	sentinel.c	/^    char *sentinel_auth_user;    \/* Username for ACLs AUTH against other sentinel. *\/$/;"	m	struct:sentinelState	file:
sentinel_config	server.h	/^    struct sentinelConfig *sentinel_config; \/* sentinel config to load at startup time. *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::sentinelConfig
sentinel_mode	server.h	/^    int sentinel_mode;          \/* True if this instance is a Sentinel. *\/$/;"	m	struct:redisServer
sentinelcmds	sentinel.c	/^struct redisCommand sentinelcmds[] = {$/;"	v	typeref:struct:redisCommand
sentinels	sentinel.c	/^    dict *sentinels;    \/* Other sentinels monitoring the same master. *\/$/;"	m	struct:sentinelRedisInstance	file:
sentlen	server.h	/^    size_t sentlen;         \/* Amount of bytes already sent in the current$/;"	m	struct:client
seq	redismodule.h	/^    uint64_t seq;$/;"	m	struct:RedisModuleStreamID
seq	stream.h	/^    uint64_t seq;       \/* Sequence number. *\/$/;"	m	struct:streamID
sequence	sparkline.h	/^struct sequence {$/;"	s
serveClientBlockedOnList	t_list.c	/^int serveClientBlockedOnList(client *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int wherefrom, int whereto)$/;"	f
serveClientsBlockedOnKeyByModule	blocked.c	/^void serveClientsBlockedOnKeyByModule(readyList *rl) {$/;"	f
serveClientsBlockedOnListKey	blocked.c	/^void serveClientsBlockedOnListKey(robj *o, readyList *rl) {$/;"	f
serveClientsBlockedOnSortedSetKey	blocked.c	/^void serveClientsBlockedOnSortedSetKey(robj *o, readyList *rl) {$/;"	f
serveClientsBlockedOnStreamKey	blocked.c	/^void serveClientsBlockedOnStreamKey(robj *o, readyList *rl) {$/;"	f
server	server.c	/^struct redisServer server; \/* Server global state *\/$/;"	v	typeref:struct:redisServer
serverAssert	server.h	498;"	d
serverAssertWithInfo	server.h	497;"	d
serverCron	server.c	/^int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f
serverLog	server.h	2734;"	d
serverLogFromHandler	server.c	/^void serverLogFromHandler(int level, const char *msg) {$/;"	f
serverLogHexDump	debug.c	/^void serverLogHexDump(int level, char *descr, void *value, size_t len) {$/;"	f
serverLogObjectDebugInfo	debug.c	/^void serverLogObjectDebugInfo(const robj *o) {$/;"	f
serverLogRaw	server.c	/^void serverLogRaw(int level, const char *msg) {$/;"	f
serverPanic	server.h	499;"	d
server_cpulist	server.h	/^    char *server_cpulist; \/* cpu affinity list of redis server main\/io thread. *\/$/;"	m	struct:redisServer
session_cache_size	server.h	/^    int session_cache_size;$/;"	m	struct:redisTLSContextConfig
session_cache_timeout	server.h	/^    int session_cache_timeout;$/;"	m	struct:redisTLSContextConfig
session_caching	server.h	/^    int session_caching;$/;"	m	struct:redisTLSContextConfig
set	config.c	/^    int (*set)(typeData data, sds value, int update, const char **err);$/;"	m	struct:typeInterface	file:
set	server.h	/^    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, $/;"	m	struct:sharedObjectsStruct
set	t_zset.c	/^        } set;$/;"	m	union:__anon61::__anon62	typeref:union:__anon61::__anon62::_iterset	file:
setAccumulatorDictType	t_zset.c	/^dictType setAccumulatorDictType = {$/;"	v
setBlockingTimeout	tls.c	/^static void setBlockingTimeout(tls_connection *conn, long long timeout) {$/;"	f	file:
setClusterKeyHashTag	redis-benchmark.c	/^static void setClusterKeyHashTag(client c) {$/;"	f	file:
setCommand	t_string.c	/^void setCommand(client *c) {$/;"	f
setDeferredAggregateLen	networking.c	/^void setDeferredAggregateLen(client *c, void *node, long length, char prefix) {$/;"	f
setDeferredArrayLen	networking.c	/^void setDeferredArrayLen(client *c, void *node, long length) {$/;"	f
setDeferredAttributeLen	networking.c	/^void setDeferredAttributeLen(client *c, void *node, long length) {$/;"	f
setDeferredMapLen	networking.c	/^void setDeferredMapLen(client *c, void *node, long length) {$/;"	f
setDeferredPushLen	networking.c	/^void setDeferredPushLen(client *c, void *node, long length) {$/;"	f
setDeferredReply	networking.c	/^void setDeferredReply(client *c, void *node, const char *s, size_t length) {$/;"	f
setDeferredReplyBulkSds	networking.c	/^void setDeferredReplyBulkSds(client *c, void *node, sds s) {$/;"	f
setDeferredReplyStreamID	t_stream.c	/^void setDeferredReplyStreamID(client *c, void *dr, streamID *id) {$/;"	f
setDeferredSetLen	networking.c	/^void setDeferredSetLen(client *c, void *node, long length) {$/;"	f
setDictType	server.c	/^dictType setDictType = {$/;"	v
setExpire	db.c	/^void setExpire(client *c, redisDb *db, robj *key, long long when) {$/;"	f
setGenericCommand	t_string.c	/^void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {$/;"	f
setIOPendingCount	networking.c	/^static inline void setIOPendingCount(int i, unsigned long count) {$/;"	f	file:
setKey	db.c	/^void setKey(client *c, redisDb *db, robj *key, robj *val) {$/;"	f
setOOMScoreAdj	server.c	/^int setOOMScoreAdj(int process_class) {$/;"	f
setProtocolError	networking.c	/^static void setProtocolError(const char *errstr, client *c) {$/;"	f	file:
setSignedBitfield	bitops.c	/^void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {$/;"	f
setTypeAdd	t_set.c	/^int setTypeAdd(robj *subject, sds value) {$/;"	f
setTypeConvert	t_set.c	/^void setTypeConvert(robj *setobj, int enc) {$/;"	f
setTypeCreate	t_set.c	/^robj *setTypeCreate(sds value) {$/;"	f
setTypeDup	t_set.c	/^robj *setTypeDup(robj *o) {$/;"	f
setTypeInitIterator	t_set.c	/^setTypeIterator *setTypeInitIterator(robj *subject) {$/;"	f
setTypeIsMember	t_set.c	/^int setTypeIsMember(robj *subject, sds value) {$/;"	f
setTypeIterator	server.h	/^} setTypeIterator;$/;"	t	typeref:struct:__anon52
setTypeNext	t_set.c	/^int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {$/;"	f
setTypeNextObject	t_set.c	/^sds setTypeNextObject(setTypeIterator *si) {$/;"	f
setTypeRandomElement	t_set.c	/^int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {$/;"	f
setTypeReleaseIterator	t_set.c	/^void setTypeReleaseIterator(setTypeIterator *si) {$/;"	f
setTypeRemove	t_set.c	/^int setTypeRemove(robj *setobj, sds value) {$/;"	f
setTypeSize	t_set.c	/^unsigned long setTypeSize(const robj *subject) {$/;"	f
setUnsignedBitfield	bitops.c	/^void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {$/;"	f
set_errcode	redis-cli.c	/^    int set_errcode;$/;"	m	struct:config	file:
set_jemalloc_bg_thread	zmalloc.c	/^void set_jemalloc_bg_thread(int enable) {$/;"	f
set_max_intset_entries	server.h	/^    size_t set_max_intset_entries;$/;"	m	struct:redisServer
set_proc_title	server.h	/^    int set_proc_title;             \/* True if change proc title *\/$/;"	m	struct:redisServer
set_read_handler	connection.h	/^    int (*set_read_handler)(struct connection *conn, ConnectionCallbackFunc handler);$/;"	m	struct:ConnectionType
set_write_handler	connection.h	/^    int (*set_write_handler)(struct connection *conn, ConnectionCallbackFunc handler, int barrier);$/;"	m	struct:ConnectionType
setbitCommand	bitops.c	/^void setbitCommand(client *c) {$/;"	f
setcpuaffinity	setcpuaffinity.c	/^void setcpuaffinity(const char *cpulist) {$/;"	f
setexCommand	t_string.c	/^void setexCommand(client *c) {$/;"	f
setid	server.h	/^    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,$/;"	m	struct:sharedObjectsStruct
setnxCommand	t_string.c	/^void setnxCommand(client *c) {$/;"	f
setproctitle	setproctitle.c	/^void setproctitle(const char *fmt, ...) {$/;"	f
setrangeCommand	t_string.c	/^void setrangeCommand(client *c) {$/;"	f
setsize	ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	struct:aeEventLoop
setupChildSignalHandlers	server.c	/^void setupChildSignalHandlers(void) {$/;"	f
setupSignalHandlers	server.c	/^void setupSignalHandlers(void) {$/;"	f
sflags	server.h	/^    char *sflags;   \/* Flags as string representation, one char per flag. *\/$/;"	m	struct:redisCommand
sha1Test	sha1.c	/^int sha1Test(int argc, char **argv, int accurate)$/;"	f
sha1hex	scripting.c	/^void sha1hex(char *digest, char *script, size_t len) {$/;"	f
sha256_final	sha256.c	/^void sha256_final(SHA256_CTX *ctx, BYTE hash[])$/;"	f
sha256_init	sha256.c	/^void sha256_init(SHA256_CTX *ctx)$/;"	f
sha256_transform	sha256.c	/^void sha256_transform(SHA256_CTX *ctx, const BYTE data[])$/;"	f
sha256_update	sha256.c	/^void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)$/;"	f
shaScriptObjectDictType	server.c	/^dictType shaScriptObjectDictType = {$/;"	v
shared	server.c	/^struct sharedObjectsStruct shared;$/;"	v	typeref:struct:sharedObjectsStruct
sharedObjectsStruct	server.h	/^struct sharedObjectsStruct {$/;"	s
sharedapi	server.h	/^    dict *sharedapi;            \/* Like moduleapi but containing the APIs that$/;"	m	struct:redisServer
shiftReplicationId	replication.c	/^void shiftReplicationId(void) {$/;"	f
should_emit_array_length	t_zset.c	/^    int                                  should_emit_array_length;$/;"	m	struct:zrange_result_handler	file:
showLatencyDistLegend	redis-cli.c	/^void showLatencyDistLegend(void) {$/;"	f
showLatencyDistSamples	redis-cli.c	/^void showLatencyDistSamples(struct distsamples *samples, long long tot) {$/;"	f
showLatencyReport	redis-benchmark.c	/^static void showLatencyReport(void) {$/;"	f	file:
showLatestBacklog	replication.c	/^void showLatestBacklog(void) {$/;"	f
showThroughput	redis-benchmark.c	/^int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f
shutdown	redis-cli.c	/^    int shutdown;$/;"	m	struct:config	file:
shutdownCommand	db.c	/^void shutdownCommand(client *c) {$/;"	f
shutdown_asap	server.h	/^    volatile sig_atomic_t shutdown_asap; \/* SHUTDOWN needed ASAP *\/$/;"	m	struct:redisServer
sig	cluster.h	/^    char sig[4];        \/* Signature "RCmb" (Redis Cluster message bus). *\/$/;"	m	struct:__anon12
sigKillChildHandler	server.c	/^static void sigKillChildHandler(int sig) {$/;"	f	file:
sigShutdownHandler	server.c	/^static void sigShutdownHandler(int sig) {$/;"	f	file:
sigcontext_t	debug.c	/^typedef ucontext_t sigcontext_t;$/;"	t	file:
sign	bitops.c	/^    int sign;           \/* True if signed, otherwise unsigned op. *\/$/;"	m	struct:bitfieldOp	file:
signalFlushedDb	db.c	/^void signalFlushedDb(int dbid, int async) {$/;"	f
signalKeyAsReady	blocked.c	/^void signalKeyAsReady(redisDb *db, robj *key, int type) {$/;"	f
signalModifiedKey	db.c	/^void signalModifiedKey(client *c, redisDb *db, robj *key) {$/;"	f
signalready	module.c	/^            int signalready;       \/* Flag that signalKeyAsReady() is needed. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon30	file:
sigsegvHandler	debug.c	/^void sigsegvHandler(int sig, siginfo_t *info, void *secret) {$/;"	f
simfailure_flags	sentinel.c	/^    unsigned long simfailure_flags; \/* Failures simulation. *\/$/;"	m	struct:sentinelState	file:
since	help.h	/^  char *since;$/;"	m	struct:commandHelp
sinterCommand	t_set.c	/^void sinterCommand(client *c) {$/;"	f
sinterGenericCommand	t_set.c	/^void sinterGenericCommand(client *c, robj **setkeys,$/;"	f
sinterstoreCommand	t_set.c	/^void sinterstoreCommand(client *c) {$/;"	f
siphash	siphash.c	/^uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {$/;"	f
siphash_nocase	siphash.c	/^uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)$/;"	f
siphash_test	siphash.c	/^int siphash_test(void) {$/;"	f
siptlw	siphash.c	/^int siptlw(int c) {$/;"	f
sismemberCommand	t_set.c	/^void sismemberCommand(client *c) {$/;"	f
size	cluster.h	/^    int size;             \/* Num of master nodes with at least one slot *\/$/;"	m	struct:clusterState
size	dict.h	/^    unsigned long size;$/;"	m	struct:dictht
size	module.c	/^    uint32_t size;$/;"	m	struct:RedisModulePoolAllocBlock	file:
size	rax.h	/^    uint32_t size:29;     \/* Number of children, or compressed string len. *\/$/;"	m	struct:raxNode
size	server.h	/^    int size;                           \/* Available array size *\/$/;"	m	struct:__anon48
size	server.h	/^    size_t size, used;$/;"	m	struct:clientReplyBlock
sizeMeetsSafetyLimit	quicklist.c	421;"	d	file:
sizecmd	redis-cli.c	/^    char *sizecmd;$/;"	m	struct:__anon36	file:
sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	struct:dictht
sizeunit	redis-cli.c	/^    char *sizeunit;$/;"	m	struct:__anon36	file:
skip_cert_verify	cli_common.h	/^    int skip_cert_verify;$/;"	m	struct:cliSSLconfig
skip_checksum_validation	server.h	/^    int skip_checksum_validation;   \/* Disables checksum validateion for RDB and RESTORE payload. *\/$/;"	m	struct:redisServer
skyscraper	lolwut6.c	/^struct skyscraper {$/;"	s	file:
sl	t_zset.c	/^            } sl;$/;"	m	union:__anon61::__anon62::_iterzset	typeref:struct:__anon61::__anon62::_iterzset::__anon66	file:
slaveIsInHandshakeState	replication.c	/^int slaveIsInHandshakeState(void) {$/;"	f
slaveKeysWithExpire	expire.c	/^dict *slaveKeysWithExpire = NULL;$/;"	v
slaveMode	redis-cli.c	/^static void slaveMode(void) {$/;"	f	file:
slaveTryPartialResynchronization	replication.c	/^int slaveTryPartialResynchronization(connection *conn, int read_reply) {$/;"	f
slave_addr	server.h	/^    char *slave_addr;       \/* Optionally given by REPLCONF ip-address *\/$/;"	m	struct:client
slave_announce_ip	server.h	/^    char *slave_announce_ip;        \/* Give the master this ip address. *\/$/;"	m	struct:redisServer
slave_announce_port	server.h	/^    int slave_announce_port;        \/* Give the master this listening port. *\/$/;"	m	struct:redisServer
slave_capa	server.h	/^    int slave_capa;         \/* Slave capabilities: SLAVE_CAPA_* bitwise OR. *\/$/;"	m	struct:client
slave_conf_change_time	sentinel.c	/^    mstime_t slave_conf_change_time; \/* Last time slave master addr changed. *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_listening_port	server.h	/^    int slave_listening_port; \/* As configured with: REPLCONF listening-port *\/$/;"	m	struct:client
slave_master_host	sentinel.c	/^    char *slave_master_host;    \/* Master host as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_master_link_status	sentinel.c	/^    int slave_master_link_status; \/* Master link status as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_master_port	sentinel.c	/^    int slave_master_port;      \/* Master port as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_mode	redis-cli.c	/^    int slave_mode;$/;"	m	struct:config	file:
slave_priority	sentinel.c	/^    int slave_priority; \/* Slave priority according to its INFO output. *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_priority	server.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	struct:redisServer
slave_reconf_sent_time	sentinel.c	/^    mstime_t slave_reconf_sent_time; \/* Time at which we sent SLAVE OF <new> *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_repl_offset	sentinel.c	/^    unsigned long long slave_repl_offset; \/* Slave replication offset. *\/$/;"	m	struct:sentinelRedisInstance	file:
slaveof	cluster.h	/^    char slaveof[CLUSTER_NAMELEN];$/;"	m	struct:__anon12
slaveof	cluster.h	/^    struct clusterNode *slaveof; \/* pointer to the master node. Note that it$/;"	m	struct:clusterNode	typeref:struct:clusterNode::clusterNode
slaves	cluster.h	/^    struct clusterNode **slaves; \/* pointers to slave nodes *\/$/;"	m	struct:clusterNode	typeref:struct:clusterNode::clusterNode
slaves	sentinel.c	/^    dict *slaves;       \/* Slaves for this master instance. *\/$/;"	m	struct:sentinelRedisInstance	file:
slaves	server.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer
slaveseldb	server.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	struct:redisServer
slen	ziplist.h	/^    unsigned int slen;$/;"	m	struct:__anon72
slot	redis-cli.c	/^    int slot;$/;"	m	struct:clusterManagerReshardTableItem	file:
slotToKeyAdd	db.c	/^void slotToKeyAdd(sds key) {$/;"	f
slotToKeyDel	db.c	/^void slotToKeyDel(sds key) {$/;"	f
slotToKeyFlush	db.c	/^void slotToKeyFlush(int async) {$/;"	f
slotToKeyUpdateKey	db.c	/^void slotToKeyUpdateKey(sds key, int add) {$/;"	f
slots	cluster.h	/^    clusterNode *slots[CLUSTER_SLOTS];$/;"	m	struct:clusterState
slots	cluster.h	/^    unsigned char slots[CLUSTER_SLOTS\/8]; \/* Slots bitmap. *\/$/;"	m	struct:__anon5
slots	cluster.h	/^    unsigned char slots[CLUSTER_SLOTS\/8]; \/* slots handled by this node *\/$/;"	m	struct:clusterNode
slots	redis-benchmark.c	/^    int *slots;$/;"	m	struct:clusterNode	file:
slots	redis-cli.c	/^    int slots;$/;"	m	struct:clusterManagerCommand	file:
slots	redis-cli.c	/^    uint8_t slots[CLUSTER_MANAGER_SLOTS];$/;"	m	struct:clusterManagerNode	file:
slots_count	redis-benchmark.c	/^    int slots_count;$/;"	m	struct:clusterNode	file:
slots_count	redis-cli.c	/^    int slots_count;$/;"	m	struct:clusterManagerNode	file:
slots_info	cluster.h	/^    sds slots_info; \/* Slots info represented by string. *\/$/;"	m	struct:clusterNode
slots_keys_count	cluster.h	/^    uint64_t slots_keys_count[CLUSTER_SLOTS];$/;"	m	struct:clusterState
slots_keys_count	db.c	/^    uint64_t slots_keys_count[CLUSTER_SLOTS];$/;"	m	struct:dbBackup	file:
slots_last_update	redis-benchmark.c	/^    int slots_last_update;$/;"	m	struct:_client	file:
slots_last_update	redis-benchmark.c	/^    redisAtomic int slots_last_update;$/;"	m	struct:config	file:
slots_to_keys	cluster.h	/^    rax *slots_to_keys;$/;"	m	struct:clusterState
slots_to_keys	db.c	/^    rax *slots_to_keys;$/;"	m	struct:dbBackup	file:
slowlog	server.h	/^    list *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	m	struct:redisServer
slowlogCommand	slowlog.c	/^void slowlogCommand(client *c) {$/;"	f
slowlogCreateEntry	slowlog.c	/^slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {$/;"	f
slowlogEntry	slowlog.h	/^typedef struct slowlogEntry {$/;"	s
slowlogEntry	slowlog.h	/^} slowlogEntry;$/;"	t	typeref:struct:slowlogEntry
slowlogFreeEntry	slowlog.c	/^void slowlogFreeEntry(void *septr) {$/;"	f
slowlogInit	slowlog.c	/^void slowlogInit(void) {$/;"	f
slowlogPushCurrentCommand	server.c	/^void slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration) {$/;"	f
slowlogPushEntryIfNeeded	slowlog.c	/^void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {$/;"	f
slowlogReset	slowlog.c	/^void slowlogReset(void) {$/;"	f
slowlog_entry_id	server.h	/^    long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	m	struct:redisServer
slowlog_log_slower_than	server.h	/^    long long slowlog_log_slower_than; \/* SLOWLOG time limit (to get logged) *\/$/;"	m	struct:redisServer
slowlog_max_len	server.h	/^    unsigned long slowlog_max_len;     \/* SLOWLOG max number of items logged *\/$/;"	m	struct:redisServer
slowscripterr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
smapsGetSharedDirty	server.c	/^static int smapsGetSharedDirty(unsigned long addr) {$/;"	f	file:
smismemberCommand	t_set.c	/^void smismemberCommand(client *c) {$/;"	f
smoveCommand	t_set.c	/^void smoveCommand(client *c) {$/;"	f
sndbuf	cluster.h	/^    sds sndbuf;                 \/* Packet send buffer *\/$/;"	m	struct:clusterLink
sni	cli_common.h	/^    char *sni;$/;"	m	struct:cliSSLconfig
socketFds	server.h	/^typedef struct socketFds {$/;"	s
socketFds	server.h	/^} socketFds;$/;"	t	typeref:struct:socketFds
sockname	server.h	/^    sds sockname;           \/* Cached connection target address. *\/$/;"	m	struct:client
sofd	server.h	/^    int sofd;                   \/* Unix socket file descriptor *\/$/;"	m	struct:redisServer
soft_limit_bytes	server.h	/^    unsigned long long soft_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig
soft_limit_seconds	server.h	/^    time_t soft_limit_seconds;$/;"	m	struct:clientBufferLimitsConfig
sortCommand	sort.c	/^void sortCommand(client *c) {$/;"	f
sortCompare	sort.c	/^int sortCompare(const void *s1, const void *s2) {$/;"	f
sortGetKeys	db.c	/^int sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
sort_alpha	server.h	/^    int sort_alpha;$/;"	m	struct:redisServer
sort_bypattern	server.h	/^    int sort_bypattern;$/;"	m	struct:redisServer
sort_desc	server.h	/^    int sort_desc;$/;"	m	struct:redisServer
sort_gp_asc	geo.c	/^static int sort_gp_asc(const void *a, const void *b) {$/;"	f	file:
sort_gp_desc	geo.c	/^static int sort_gp_desc(const void *a, const void *b) {$/;"	f	file:
sort_store	server.h	/^    int sort_store;$/;"	m	struct:redisServer
source	redis-cli.c	/^    clusterManagerNode *source;$/;"	m	struct:clusterManagerReshardTableItem	file:
south	geohash.h	/^    GeoHashBits south;$/;"	m	struct:__anon23
south_east	geohash.h	/^    GeoHashBits south_east;$/;"	m	struct:__anon23
south_west	geohash.h	/^    GeoHashBits south_west;$/;"	m	struct:__anon23
space	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
span	server.h	/^        unsigned long span;$/;"	m	struct:zskiplistNode::zskiplistLevel
sparklineRender	sparkline.c	/^sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {$/;"	f
sparklineRenderRange	sparkline.c	/^sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {$/;"	f
sparklineSequenceAddSample	sparkline.c	/^void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {$/;"	f
special_asterick	server.h	/^    *getack, *special_asterick, *special_equals, *default_username,$/;"	m	struct:sharedObjectsStruct
special_equals	server.h	/^    *getack, *special_asterick, *special_equals, *default_username,$/;"	m	struct:sharedObjectsStruct
spectrum_palette	redis-cli.c	/^int *spectrum_palette;$/;"	v
spectrum_palette_color	redis-cli.c	/^int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};$/;"	v
spectrum_palette_color_size	redis-cli.c	/^int spectrum_palette_color_size = 19;$/;"	v
spectrum_palette_mono	redis-cli.c	/^int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};$/;"	v
spectrum_palette_mono_size	redis-cli.c	/^int spectrum_palette_mono_size = 13;$/;"	v
spectrum_palette_size	redis-cli.c	/^int spectrum_palette_size;$/;"	v
spopCommand	t_set.c	/^void spopCommand(client *c) {$/;"	f
spopWithCountCommand	t_set.c	/^void spopWithCountCommand(client *c) {$/;"	f
spt_clearenv	setproctitle.c	/^int spt_clearenv(void) {$/;"	f
spt_copyargs	setproctitle.c	/^static int spt_copyargs(int argc, char *argv[]) {$/;"	f	file:
spt_copyenv	setproctitle.c	/^static int spt_copyenv(int envc, char *oldenv[]) {$/;"	f	file:
spt_init	setproctitle.c	/^void spt_init(int argc, char *argv[]) {$/;"	f
spt_min	setproctitle.c	/^static inline size_t spt_min(size_t a, size_t b) {$/;"	f	file:
sptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon61::__anon62::_iterzset::__anon65	file:
srandmemberCommand	t_set.c	/^void srandmemberCommand(client *c) {$/;"	f
srandmemberWithCountCommand	t_set.c	/^void srandmemberWithCountCommand(client *c) {$/;"	f
src	scripting.c	/^    sds *src;   \/* Lua script source code split by line. *\/$/;"	m	struct:ldbState	file:
srem	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
sremCommand	server.h	/^                        *zpopmaxCommand, *sremCommand, *execCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
sremCommand	t_set.c	/^void sremCommand(client *c) {$/;"	f
sscanCommand	t_set.c	/^void sscanCommand(client *c) {$/;"	f
ssl	tls.c	/^    SSL *ssl;$/;"	m	struct:tls_connection	file:
sslLockingCallback	tls.c	/^static void sslLockingCallback(int mode, int lock_id, const char *f, int line) {$/;"	f	file:
ssl_error	tls.c	/^    char *ssl_error;$/;"	m	struct:tls_connection	file:
sslconfig	redis-benchmark.c	/^    struct cliSSLconfig sslconfig;$/;"	m	struct:config	typeref:struct:config::cliSSLconfig	file:
sslconfig	redis-cli.c	/^    cliSSLconfig sslconfig;$/;"	m	struct:config	file:
sst	config.c	/^        ssize_t *sst;$/;"	m	union:numericConfigData::__anon14	file:
st	config.c	/^        size_t *st;$/;"	m	union:numericConfigData::__anon14	file:
stack	rax.h	/^    raxStack stack;         \/* Stack used for unsafe iteration. *\/$/;"	m	struct:raxIterator
stack	rax.h	/^    void **stack; \/* Points to static_items or an heap allocated array. *\/$/;"	m	struct:raxStack
stagfree	redis-benchmark.c	/^    size_t stagfree;        \/* Number of unused pointers in client->stagptr *\/$/;"	m	struct:_client	file:
staglen	redis-benchmark.c	/^    size_t staglen;         \/* Number of pointers in client->stagptr *\/$/;"	m	struct:_client	file:
stagptr	redis-benchmark.c	/^    char **stagptr;         \/* Pointers to slot hashtags (cluster mode only) *\/$/;"	m	struct:_client	file:
standardConfig	config.c	/^typedef struct standardConfig {$/;"	s	file:
standardConfig	config.c	/^} standardConfig;$/;"	t	typeref:struct:standardConfig	file:
start	module.c	/^            uint32_t start;        \/* Start pos for positional ranges. *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
start	redis-benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	struct:_client	file:
start	redis-benchmark.c	/^    long long start;$/;"	m	struct:config	file:
startAppendOnly	aof.c	/^int startAppendOnly(void) {$/;"	f
startBenchmarkThreads	redis-benchmark.c	/^static void startBenchmarkThreads() {$/;"	f	file:
startBgsaveForReplication	replication.c	/^int startBgsaveForReplication(int mincapa) {$/;"	f
startLoading	rdb.c	/^void startLoading(size_t size, int rdbflags) {$/;"	f
startLoadingFile	rdb.c	/^void startLoadingFile(FILE *fp, char* filename, int rdbflags) {$/;"	f
startSaving	rdb.c	/^void startSaving(int rdbflags) {$/;"	f
startThreadedIO	networking.c	/^void startThreadedIO(void) {$/;"	f
start_benchmark	dict.c	1218;"	d	file:
start_key	stream.h	/^    uint64_t start_key[2];  \/* Start key as 128 bit big endian. *\/$/;"	m	struct:streamIterator
start_time	sentinel.c	/^    mstime_t start_time;    \/* Script execution time if the script is running,$/;"	m	struct:sentinelScriptJob	file:
startup_allocated	server.h	/^    size_t startup_allocated;$/;"	m	struct:redisMemOverhead
statMode	redis-cli.c	/^static void statMode(void) {$/;"	f	file:
stat_active_defrag_hits	server.h	/^    long long stat_active_defrag_hits;      \/* number of allocations moved *\/$/;"	m	struct:redisServer
stat_active_defrag_key_hits	server.h	/^    long long stat_active_defrag_key_hits;  \/* number of keys with moved allocations *\/$/;"	m	struct:redisServer
stat_active_defrag_key_misses	server.h	/^    long long stat_active_defrag_key_misses;\/* number of keys scanned and not moved *\/$/;"	m	struct:redisServer
stat_active_defrag_misses	server.h	/^    long long stat_active_defrag_misses;    \/* number of allocations scanned but not moved *\/$/;"	m	struct:redisServer
stat_active_defrag_scanned	server.h	/^    long long stat_active_defrag_scanned;   \/* number of dictEntries scanned *\/$/;"	m	struct:redisServer
stat_aof_cow_bytes	server.h	/^    size_t stat_aof_cow_bytes;      \/* Copy on write bytes during AOF rewrite. *\/$/;"	m	struct:redisServer
stat_clients_type_memory	server.h	/^    uint64_t stat_clients_type_memory[CLIENT_TYPE_COUNT];\/* Mem usage by type *\/$/;"	m	struct:redisServer
stat_current_cow_bytes	server.h	/^    size_t stat_current_cow_bytes;  \/* Copy on write bytes while child is active. *\/$/;"	m	struct:redisServer
stat_current_cow_updated	server.h	/^    monotime stat_current_cow_updated;  \/* Last update time of stat_current_cow_bytes *\/$/;"	m	struct:redisServer
stat_current_save_keys_processed	server.h	/^    size_t stat_current_save_keys_processed;  \/* Processed keys while child is active. *\/$/;"	m	struct:redisServer
stat_current_save_keys_total	server.h	/^    size_t stat_current_save_keys_total;  \/* Number of keys when child started. *\/$/;"	m	struct:redisServer
stat_dump_payload_sanitizations	server.h	/^    long long stat_dump_payload_sanitizations; \/* Number deep dump payloads integrity validations. *\/$/;"	m	struct:redisServer
stat_evictedkeys	server.h	/^    long long stat_evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	struct:redisServer
stat_expire_cycle_time_used	server.h	/^    long long stat_expire_cycle_time_used; \/* Cumulative microseconds used. *\/$/;"	m	struct:redisServer
stat_expired_stale_perc	server.h	/^    double stat_expired_stale_perc; \/* Percentage of keys probably expired *\/$/;"	m	struct:redisServer
stat_expired_time_cap_reached_count	server.h	/^    long long stat_expired_time_cap_reached_count; \/* Early expire cylce stops.*\/$/;"	m	struct:redisServer
stat_expiredkeys	server.h	/^    long long stat_expiredkeys;     \/* Number of expired keys *\/$/;"	m	struct:redisServer
stat_fork_rate	server.h	/^    double stat_fork_rate;          \/* Fork rate in GB\/sec. *\/$/;"	m	struct:redisServer
stat_fork_time	server.h	/^    long long stat_fork_time;       \/* Time needed to perform latest fork() *\/$/;"	m	struct:redisServer
stat_io_reads_processed	server.h	/^    long long stat_io_reads_processed; \/* Number of read events processed by IO \/ Main threads *\/$/;"	m	struct:redisServer
stat_io_writes_processed	server.h	/^    long long stat_io_writes_processed; \/* Number of write events processed by IO \/ Main threads *\/$/;"	m	struct:redisServer
stat_keyspace_hits	server.h	/^    long long stat_keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	struct:redisServer
stat_keyspace_misses	server.h	/^    long long stat_keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	struct:redisServer
stat_mode	redis-cli.c	/^    int stat_mode;$/;"	m	struct:config	file:
stat_module_cow_bytes	server.h	/^    size_t stat_module_cow_bytes;   \/* Copy on write bytes during module fork. *\/$/;"	m	struct:redisServer
stat_module_progress	server.h	/^    double stat_module_progress;   \/* Module save progress. *\/$/;"	m	struct:redisServer
stat_net_input_bytes	server.h	/^    redisAtomic long long stat_net_input_bytes; \/* Bytes read from network. *\/$/;"	m	struct:redisServer
stat_net_output_bytes	server.h	/^    redisAtomic long long stat_net_output_bytes; \/* Bytes written to network. *\/$/;"	m	struct:redisServer
stat_numcommands	server.h	/^    long long stat_numcommands;     \/* Number of processed commands *\/$/;"	m	struct:redisServer
stat_numconnections	server.h	/^    long long stat_numconnections;  \/* Number of connections received *\/$/;"	m	struct:redisServer
stat_peak_memory	server.h	/^    size_t stat_peak_memory;        \/* Max used memory record *\/$/;"	m	struct:redisServer
stat_rdb_cow_bytes	server.h	/^    size_t stat_rdb_cow_bytes;      \/* Copy on write bytes during RDB saving. *\/$/;"	m	struct:redisServer
stat_rejected_conn	server.h	/^    long long stat_rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	struct:redisServer
stat_starttime	server.h	/^    time_t stat_starttime;          \/* Server start time *\/$/;"	m	struct:redisServer
stat_sync_full	server.h	/^    long long stat_sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	struct:redisServer
stat_sync_partial_err	server.h	/^    long long stat_sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	struct:redisServer
stat_sync_partial_ok	server.h	/^    long long stat_sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	struct:redisServer
stat_total_error_replies	server.h	/^    long long stat_total_error_replies; \/* Total number of issued error replies ( command + rejected errors ) *\/$/;"	m	struct:redisServer
stat_total_forks	server.h	/^    long long stat_total_forks;     \/* Total count of fork. *\/$/;"	m	struct:redisServer
stat_total_reads_processed	server.h	/^    redisAtomic long long stat_total_reads_processed; \/* Total number of read events processed *\/$/;"	m	struct:redisServer
stat_total_writes_processed	server.h	/^    redisAtomic long long stat_total_writes_processed; \/* Total number of write events processed *\/$/;"	m	struct:redisServer
stat_unexpected_error_replies	server.h	/^    long long stat_unexpected_error_replies; \/* Number of unexpected (aof-loading, replica to master, etc.) error replies *\/$/;"	m	struct:redisServer
state	cluster.h	/^    int state;            \/* CLUSTER_OK, CLUSTER_FAIL, ... *\/$/;"	m	struct:clusterState
state	cluster.h	/^    unsigned char state; \/* Cluster state from the POV of the sender *\/$/;"	m	struct:__anon12
state	connection.h	/^    ConnectionState state;$/;"	m	struct:connection
state	sha1.h	/^    uint32_t state[5];$/;"	m	struct:__anon57
state	sha256.h	/^	WORD state[8];$/;"	m	struct:__anon58
static_items	rax.h	/^    void *static_items[RAX_STACK_STATIC_ITEMS];$/;"	m	struct:raxStack
stats_bus_messages_received	cluster.h	/^    long long stats_bus_messages_received[CLUSTERMSG_TYPE_COUNT];$/;"	m	struct:clusterState
stats_bus_messages_sent	cluster.h	/^    long long stats_bus_messages_sent[CLUSTERMSG_TYPE_COUNT];$/;"	m	struct:clusterState
stats_pfail_nodes	cluster.h	/^    long long stats_pfail_nodes;    \/* Number of nodes in PFAIL status,$/;"	m	struct:clusterState
stdinarg	redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	struct:config	file:
step	geohash.h	/^    uint8_t step;$/;"	m	struct:__anon20
step	scripting.c	/^    int step;   \/* Stop at next line regardless of breakpoints. *\/$/;"	m	struct:ldbState	file:
stop	ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
stopAppendOnly	aof.c	/^void stopAppendOnly(void) {$/;"	f
stopLoading	rdb.c	/^void stopLoading(int success) {$/;"	f
stopSaving	rdb.c	/^void stopSaving(int success) {$/;"	f
stopThreadedIO	networking.c	/^void stopThreadedIO(void) {$/;"	f
stopThreadedIOIfNeeded	networking.c	/^int stopThreadedIOIfNeeded(void) {$/;"	f
stop_writes_on_bgsave_err	server.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	struct:redisServer
str	module.c	/^        const char *str; \/* String pointer for string and error replies. This$/;"	m	union:RedisModuleCallReply::__anon31	file:
strChildType	server.c	/^const char *strChildType(int type) {$/;"	f
strEncoding	object.c	/^char *strEncoding(int encoding) {$/;"	f
strEntryBytesLarge	ziplist.c	/^static size_t strEntryBytesLarge(size_t slen) {$/;"	f	file:
strEntryBytesSmall	ziplist.c	/^static size_t strEntryBytesSmall(size_t slen) {$/;"	f	file:
stralgoCommand	t_string.c	/^void stralgoCommand(client *c) {$/;"	f
stralgoLCS	t_string.c	/^void stralgoLCS(client *c) {$/;"	f
stream	module.c	/^        } stream;$/;"	m	union:RedisModuleKey::__anon28	typeref:struct:RedisModuleKey::__anon28::__anon30	file:
stream	stream.h	/^    stream *stream;         \/* The stream we are iterating. *\/$/;"	m	struct:streamIterator
stream	stream.h	/^typedef struct stream {$/;"	s
stream	stream.h	/^} stream;$/;"	t	typeref:struct:stream
streamAddTrimArgs	t_stream.c	/^} streamAddTrimArgs;$/;"	t	typeref:struct:__anon59	file:
streamAppendItem	t_stream.c	/^int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {$/;"	f
streamCG	stream.h	/^typedef struct streamCG {$/;"	s
streamCG	stream.h	/^} streamCG;$/;"	t	typeref:struct:streamCG
streamCompareID	t_stream.c	/^int streamCompareID(streamID *a, streamID *b) {$/;"	f
streamConsumer	stream.h	/^typedef struct streamConsumer {$/;"	s
streamConsumer	stream.h	/^} streamConsumer;$/;"	t	typeref:struct:streamConsumer
streamCreateCG	t_stream.c	/^streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {$/;"	f
streamCreateNACK	t_stream.c	/^streamNACK *streamCreateNACK(streamConsumer *consumer) {$/;"	f
streamDecodeID	t_stream.c	/^void streamDecodeID(void *buf, streamID *id) {$/;"	f
streamDecrID	t_stream.c	/^int streamDecrID(streamID *id) {$/;"	f
streamDelConsumer	t_stream.c	/^uint64_t streamDelConsumer(streamCG *cg, sds name) {$/;"	f
streamDeleteItem	t_stream.c	/^int streamDeleteItem(stream *s, streamID *id) {$/;"	f
streamDup	t_stream.c	/^robj *streamDup(robj *o) {$/;"	f
streamEncodeID	t_stream.c	/^void streamEncodeID(void *buf, streamID *id) {$/;"	f
streamFreeCG	t_stream.c	/^void streamFreeCG(streamCG *cg) {$/;"	f
streamFreeConsumer	t_stream.c	/^void streamFreeConsumer(streamConsumer *sc) {$/;"	f
streamFreeNACK	t_stream.c	/^void streamFreeNACK(streamNACK *na) {$/;"	f
streamGenericParseIDOrReply	t_stream.c	/^int streamGenericParseIDOrReply(client *c, const robj *o, streamID *id, uint64_t missing_seq, int strict) {$/;"	f
streamGetEdgeID	t_stream.c	/^void streamGetEdgeID(stream *s, int first, streamID *edge_id)$/;"	f
streamID	stream.h	/^typedef struct streamID {$/;"	s
streamID	stream.h	/^} streamID;$/;"	t	typeref:struct:streamID
streamIncrID	t_stream.c	/^int streamIncrID(streamID *id) {$/;"	f
streamIterator	stream.h	/^typedef struct streamIterator {$/;"	s
streamIterator	stream.h	/^} streamIterator;$/;"	t	typeref:struct:streamIterator
streamIteratorGetField	t_stream.c	/^void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {$/;"	f
streamIteratorGetID	t_stream.c	/^int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {$/;"	f
streamIteratorRemoveEntry	t_stream.c	/^void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {$/;"	f
streamIteratorStart	t_stream.c	/^void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {$/;"	f
streamIteratorStop	t_stream.c	/^void streamIteratorStop(streamIterator *si) {$/;"	f
streamLastValidID	t_stream.c	/^void streamLastValidID(stream *s, streamID *maxid)$/;"	f
streamLength	t_stream.c	/^unsigned long streamLength(const robj *subject) {$/;"	f
streamLogListpackContent	t_stream.c	/^void streamLogListpackContent(unsigned char *lp) {$/;"	f
streamLookupCG	t_stream.c	/^streamCG *streamLookupCG(stream *s, sds groupname) {$/;"	f
streamLookupConsumer	t_stream.c	/^streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags, int *created) {$/;"	f
streamNACK	stream.h	/^typedef struct streamNACK {$/;"	s
streamNACK	stream.h	/^} streamNACK;$/;"	t	typeref:struct:streamNACK
streamNew	t_stream.c	/^stream *streamNew(void) {$/;"	f
streamNextID	t_stream.c	/^void streamNextID(streamID *last_id, streamID *new_id) {$/;"	f
streamParseAddOrTrimArgsOrReply	t_stream.c	/^static int streamParseAddOrTrimArgsOrReply(client *c, streamAddTrimArgs *args, int xadd) {$/;"	f	file:
streamParseID	t_stream.c	/^int streamParseID(const robj *o, streamID *id) {$/;"	f
streamParseIDOrReply	t_stream.c	/^int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {$/;"	f
streamParseIntervalIDOrReply	t_stream.c	/^int streamParseIntervalIDOrReply(client *c, robj *o, streamID *id, int *exclude, uint64_t missing_seq) {$/;"	f
streamParseStrictIDOrReply	t_stream.c	/^int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {$/;"	f
streamPropInfo	stream.h	/^typedef struct streamPropInfo {$/;"	s
streamPropInfo	stream.h	/^} streamPropInfo;$/;"	t	typeref:struct:streamPropInfo
streamPropagateConsumerCreation	t_stream.c	/^void streamPropagateConsumerCreation(client *c, robj *key, robj *groupname, sds consumername) {$/;"	f
streamPropagateGroupID	t_stream.c	/^void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {$/;"	f
streamPropagateXCLAIM	t_stream.c	/^void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {$/;"	f
streamRadixTreeMemoryUsage	object.c	/^size_t streamRadixTreeMemoryUsage(rax *rax) {$/;"	f
streamReplyWithRange	t_stream.c	/^size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {$/;"	f
streamReplyWithRangeFromConsumerPEL	t_stream.c	/^size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {$/;"	f
streamRewriteApproxSpecifier	t_stream.c	/^void streamRewriteApproxSpecifier(client *c, int idx) {$/;"	f
streamRewriteTrimArgument	t_stream.c	/^void streamRewriteTrimArgument(client *c, stream *s, int trim_strategy, int idx) {$/;"	f
streamTrim	t_stream.c	/^int64_t streamTrim(stream *s, streamAddTrimArgs *args) {$/;"	f
streamTrimByID	t_stream.c	/^int64_t streamTrimByID(stream *s, streamID minid, int approx) {$/;"	f
streamTrimByLength	t_stream.c	/^int64_t streamTrimByLength(stream *s, long long maxlen, int approx) {$/;"	f
streamTypeLookupWriteOrCreate	t_stream.c	/^robj *streamTypeLookupWriteOrCreate(client *c, robj *key, int no_create) {$/;"	f
streamValidateListpackIntegrity	t_stream.c	/^int streamValidateListpackIntegrity(unsigned char *lp, size_t size, int deep) {$/;"	f
stream_id	blocked.c	/^    streamID stream_id;     \/* Stream ID if we blocked in a stream. *\/$/;"	m	struct:bkinfo	file:
stream_node_max_bytes	server.h	/^    size_t stream_node_max_bytes;$/;"	m	struct:redisServer
stream_node_max_entries	server.h	/^    long long stream_node_max_entries;$/;"	m	struct:redisServer
stress	ziplist.c	/^static void stress(int pos, int num, int maxsize, int dnum) {$/;"	f	file:
string	config.c	/^    stringConfigData string;$/;"	m	union:typeData	file:
string2d	util.c	/^int string2d(const char *s, size_t slen, double *dp) {$/;"	f
string2l	util.c	/^int string2l(const char *s, size_t slen, long *lval) {$/;"	f
string2ld	util.c	/^int string2ld(const char *s, size_t slen, long double *dp) {$/;"	f
string2ll	util.c	/^int string2ll(const char *s, size_t slen, long long *value) {$/;"	f
string2ull	util.c	/^int string2ull(const char *s, unsigned long long *value) {$/;"	f
stringCheckPrefix	tracking.c	/^static int stringCheckPrefix(unsigned char *s1, size_t s1_len, unsigned char *s2, size_t s2_len) {$/;"	f	file:
stringConfigData	config.c	/^typedef struct stringConfigData {$/;"	s	file:
stringConfigData	config.c	/^} stringConfigData;$/;"	t	typeref:struct:stringConfigData	file:
stringFromLongLong	dict.c	/^char *stringFromLongLong(long long value) {$/;"	f
stringObjectLen	object.c	/^size_t stringObjectLen(robj *o) {$/;"	f
stringmatch	util.c	/^int stringmatch(const char *pattern, const char *string, int nocase) {$/;"	f
stringmatchlen	util.c	/^int stringmatchlen(const char *pattern, int patternLen,$/;"	f
stringmatchlen_fuzz_test	util.c	/^int stringmatchlen_fuzz_test(void) {$/;"	f
strlenCommand	t_string.c	/^void strlenCommand(client *c) {$/;"	f
strtold	object.c	36;"	d	file:
subject	server.h	/^    robj *subject;$/;"	m	struct:__anon50
subject	server.h	/^    robj *subject;$/;"	m	struct:__anon52
subject	server.h	/^    robj *subject;$/;"	m	struct:__anon53
subject	t_zset.c	/^    robj *subject;$/;"	m	struct:__anon61	file:
subscribeCommand	pubsub.c	/^void subscribeCommand(client *c) {$/;"	f
subscribebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
summary	help.h	/^  char *summary;$/;"	m	struct:commandHelp
sunionCommand	t_set.c	/^void sunionCommand(client *c) {$/;"	f
sunionDiffGenericCommand	t_set.c	/^void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,$/;"	f
sunionstoreCommand	t_set.c	/^void sunionstoreCommand(client *c) {$/;"	f
supervised	server.h	/^    int supervised;                 \/* 1 if supervised, 0 otherwise. *\/$/;"	m	struct:redisServer
supervised_mode	server.h	/^    int supervised_mode;            \/* See SUPERVISED_* *\/$/;"	m	struct:redisServer
supervised_mode_enum	config.c	/^configEnum supervised_mode_enum[] = {$/;"	v
sval	ziplist.h	/^    unsigned char *sval;$/;"	m	struct:__anon72
swap	pqsort.c	78;"	d	file:
swapcode	pqsort.c	54;"	d	file:
swapdbCommand	db.c	/^void swapdbCommand(client *c) {$/;"	f
swapfunc	pqsort.c	/^swapfunc(char *a, char *b, size_t n, int swaptype)$/;"	f	file:
sync	redismodule.h	/^    int32_t sync;           \/* Synchronous or threaded flush?. *\/$/;"	m	struct:RedisModuleFlushInfo
syncCommand	replication.c	/^void syncCommand(client *c) {$/;"	f
syncRead	syncio.c	/^ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f
syncReadLine	syncio.c	/^ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f
syncWithMaster	replication.c	/^void syncWithMaster(connection *conn) {$/;"	f
syncWrite	syncio.c	/^ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f
sync_read	connection.h	/^    ssize_t (*sync_read)(struct connection *conn, char *ptr, ssize_t size, long long timeout);$/;"	m	struct:ConnectionType
sync_readline	connection.h	/^    ssize_t (*sync_readline)(struct connection *conn, char *ptr, ssize_t size, long long timeout);$/;"	m	struct:ConnectionType
sync_write	connection.h	/^    ssize_t (*sync_write)(struct connection *conn, char *ptr, ssize_t size, long long timeout);$/;"	m	struct:ConnectionType
syntaxerr	server.h	/^    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
syslog_enabled	server.h	/^    int syslog_enabled;             \/* Is syslog enabled? *\/$/;"	m	struct:redisServer
syslog_facility	server.h	/^    int syslog_facility;            \/* Syslog facility *\/$/;"	m	struct:redisServer
syslog_facility_enum	config.c	/^configEnum syslog_facility_enum[] = {$/;"	v
syslog_ident	server.h	/^    char *syslog_ident;             \/* Syslog ident *\/$/;"	m	struct:redisServer
system_memory_size	server.h	/^    size_t system_memory_size;  \/* Total memory in system as reported by OS *\/$/;"	m	struct:redisServer
sz	quicklist.h	/^    unsigned int sz;             \/* ziplist size in bytes *\/$/;"	m	struct:quicklistNode
sz	quicklist.h	/^    unsigned int sz; \/* LZF size in bytes*\/$/;"	m	struct:quicklistLZF
sz	quicklist.h	/^    unsigned int sz;$/;"	m	struct:quicklistEntry
t	geohash.h	/^    } t;$/;"	m	struct:__anon24	typeref:union:__anon24::__anon25
table	dict.h	/^    dictEntry **table;$/;"	m	struct:dictht
table	dict.h	/^    int table, safe;$/;"	m	struct:dictIterator
tail	adlist.h	/^    listNode *tail;$/;"	m	struct:list
tail	quicklist.h	/^    quicklistNode *tail;$/;"	m	struct:quicklist
tail	server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::
target	server.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
target	server.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	struct:blockingState
target_replica_host	server.h	/^    char *target_replica_host; \/* Failover target host. If null during a$/;"	m	struct:redisServer
target_replica_port	server.h	/^    int target_replica_port; \/* Failover target port *\/$/;"	m	struct:redisServer
tcp_backlog	server.h	/^    int tcp_backlog;            \/* TCP listen() backlog *\/$/;"	m	struct:redisServer
tcpkeepalive	server.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	struct:redisServer
tell	rio.h	/^    off_t (*tell)(struct _rio *);$/;"	m	struct:_rio
test_cond	testhelp.h	44;"	d
test_is_selected	redis-benchmark.c	/^int test_is_selected(char *name) {$/;"	f
test_ll2string	util.c	/^static void test_ll2string(void) {$/;"	f	file:
test_report	testhelp.h	48;"	d
test_string2l	util.c	/^static void test_string2l(void) {$/;"	f	file:
test_string2ll	util.c	/^static void test_string2ll(void) {$/;"	f	file:
tests	redis-benchmark.c	/^    char *tests;$/;"	m	struct:config	file:
thread	redis-benchmark.c	/^    pthread_t thread;$/;"	m	struct:benchmarkThread	file:
thread_id	redis-benchmark.c	/^    int thread_id;$/;"	m	struct:_client	file:
threads	redis-benchmark.c	/^    struct benchmarkThread **threads;$/;"	m	struct:config	typeref:struct:config::benchmarkThread	file:
threshold	redis-cli.c	/^    float threshold;$/;"	m	struct:clusterManagerCommand	file:
tilt	sentinel.c	/^    int tilt;           \/* Are we in TILT mode? *\/$/;"	m	struct:sentinelState	file:
tilt_start_time	sentinel.c	/^    mstime_t tilt_start_time;       \/* When TITL started. *\/$/;"	m	struct:sentinelState	file:
time	bio.c	/^    time_t time; \/* Time at which the job was created. *\/$/;"	m	struct:bio_job	file:
time	cluster.h	/^    mstime_t time;             \/* Time of the last report from this node. *\/$/;"	m	struct:clusterNodeFailReport
time	latency.h	/^    int32_t time; \/* We don't use time_t to force 4 bytes usage everywhere. *\/$/;"	m	struct:latencySample
time	server.h	/^    *time, *pxat, *px, *retrycount, *force, *justid, $/;"	m	struct:sharedObjectsStruct
time	slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	struct:slowlogEntry
timeCommand	server.c	/^void timeCommand(client *c) {$/;"	f
timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeInMilliseconds	dict.c	/^long long timeInMilliseconds(void) {$/;"	f
timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
time_independent_strcmp	acl.c	/^int time_independent_strcmp(char *a, char *b) {$/;"	f
timeout	redis-cli.c	/^    int timeout;$/;"	m	struct:clusterManagerCommand	file:
timeout	server.h	/^    mstime_t timeout;       \/* Blocking operation timeout. If UNIX current time$/;"	m	struct:blockingState
timeout_callback	module.c	/^    RedisModuleCmdFunc timeout_callback; \/* Reply callback on timeout. *\/$/;"	m	struct:RedisModuleBlockedClient	file:
timerHandler	modules/hellotimer.c	/^void timerHandler(RedisModuleCtx *ctx, void *data) {$/;"	f
timezone	server.h	/^    time_t timezone;            \/* Cached timezone. As set by tzset(). *\/$/;"	m	struct:redisServer
title	redis-benchmark.c	/^    const char *title;$/;"	m	struct:config	file:
tls	redis-benchmark.c	/^    int tls;$/;"	m	struct:config	file:
tls	redis-cli.c	/^    int tls;$/;"	m	struct:config	file:
tlsCleanup	tls.c	/^void tlsCleanup(void) {$/;"	f
tlsConfigure	tls.c	/^int tlsConfigure(redisTLSContextConfig *ctx_config) {$/;"	f
tlsEventHandler	tls.c	/^static void tlsEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask) {$/;"	f	file:
tlsHandleEvent	tls.c	/^static void tlsHandleEvent(tls_connection *conn, int mask) {$/;"	f	file:
tlsHasPendingData	tls.c	/^int tlsHasPendingData() {$/;"	f
tlsInit	tls.c	/^void tlsInit(void) {$/;"	f
tlsPasswordCallback	tls.c	/^static int tlsPasswordCallback(char *buf, int size, int rwflag, void *u) {$/;"	f	file:
tlsProcessPendingData	tls.c	/^int tlsProcessPendingData() {$/;"	f
tls_auth_clients	server.h	/^    int tls_auth_clients;$/;"	m	struct:redisServer
tls_auth_clients_enum	config.c	/^configEnum tls_auth_clients_enum[] = {$/;"	v
tls_cluster	server.h	/^    int tls_cluster;$/;"	m	struct:redisServer
tls_connection	tls.c	/^typedef struct tls_connection {$/;"	s	file:
tls_connection	tls.c	/^} tls_connection;$/;"	t	typeref:struct:tls_connection	file:
tls_ctx_config	server.h	/^    redisTLSContextConfig tls_ctx_config;$/;"	m	struct:redisServer
tls_port	server.h	/^    int tls_port;               \/* TLS listening port *\/$/;"	m	struct:redisServer
tls_replication	server.h	/^    int tls_replication;$/;"	m	struct:redisServer
tlsfd	server.h	/^    socketFds tlsfd;            \/* TLS socket file descriptors *\/$/;"	m	struct:redisServer
to	redis-cli.c	/^    char *to;$/;"	m	struct:clusterManagerCommand	file:
todo_before_sleep	cluster.h	/^    int todo_before_sleep; \/* Things to do in clusterBeforeSleep(). *\/$/;"	m	struct:clusterState
total_allocated	server.h	/^    size_t total_allocated;$/;"	m	struct:redisMemOverhead
total_frag	server.h	/^    float total_frag;$/;"	m	struct:redisMemOverhead
total_frag_bytes	server.h	/^    ssize_t total_frag_bytes;$/;"	m	struct:redisMemOverhead
total_keys	server.h	/^    size_t total_keys;$/;"	m	struct:redisMemOverhead
totalsize	redis-cli.c	/^    unsigned long long totalsize;$/;"	m	struct:__anon36	file:
totlatency	redis-benchmark.c	/^    long long totlatency;$/;"	m	struct:config	file:
totlen	cluster.h	/^    uint32_t totlen;    \/* Total length of this message *\/$/;"	m	struct:__anon12
touchAllWatchedKeysInDb	multi.c	/^void touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with) {$/;"	f
touchCommand	expire.c	/^void touchCommand(client *c) {$/;"	f
touchWatchedKey	multi.c	/^void touchWatchedKey(redisDb *db, robj *key) {$/;"	f
traces	scripting.c	/^    list *traces; \/* Messages about Redis commands executed since last stop.*\/$/;"	m	struct:ldbState	file:
trackInstantaneousMetric	server.c	/^void trackInstantaneousMetric(int metric, long long current_reading) {$/;"	f
trackingBroadcastInvalidationMessages	tracking.c	/^void trackingBroadcastInvalidationMessages(void) {$/;"	f
trackingBuildBroadcastReply	tracking.c	/^sds trackingBuildBroadcastReply(client *c, rax *keys) {$/;"	f
trackingGetTotalItems	tracking.c	/^uint64_t trackingGetTotalItems(void) {$/;"	f
trackingGetTotalKeys	tracking.c	/^uint64_t trackingGetTotalKeys(void) {$/;"	f
trackingGetTotalPrefixes	tracking.c	/^uint64_t trackingGetTotalPrefixes(void) {$/;"	f
trackingInvalidateKey	tracking.c	/^void trackingInvalidateKey(client *c, robj *keyobj) {$/;"	f
trackingInvalidateKeyRaw	tracking.c	/^void trackingInvalidateKeyRaw(client *c, char *key, size_t keylen, int bcast) {$/;"	f
trackingInvalidateKeysOnFlush	tracking.c	/^void trackingInvalidateKeysOnFlush(int async) {$/;"	f
trackingLimitUsedSlots	tracking.c	/^void trackingLimitUsedSlots(void) {$/;"	f
trackingRememberKeyToBroadcast	tracking.c	/^void trackingRememberKeyToBroadcast(client *c, char *keyname, size_t keylen) {$/;"	f
trackingRememberKeys	tracking.c	/^void trackingRememberKeys(client *c) {$/;"	f
tracking_clients	server.h	/^    unsigned int tracking_clients;  \/* # of clients with tracking enabled.*\/$/;"	m	struct:redisServer
tracking_table_max_keys	server.h	/^    size_t tracking_table_max_keys; \/* Max number of keys in tracking table. *\/$/;"	m	struct:redisServer
trimReplyUnusedTailSpace	networking.c	/^void trimReplyUnusedTailSpace(client *c) {$/;"	f
trimStringObjectIfNeeded	object.c	/^void trimStringObjectIfNeeded(robj *o) {$/;"	f
trim_strategy	t_stream.c	/^    int trim_strategy; \/* TRIM_STRATEGY_* *\/$/;"	m	struct:__anon59	file:
trim_strategy_arg_idx	t_stream.c	/^    int trim_strategy_arg_idx; \/* Index of the count in MAXLEN\/MINID, for rewriting. *\/$/;"	m	struct:__anon59	file:
tryObjectEncoding	object.c	/^robj *tryObjectEncoding(robj *o) {$/;"	f
tryResizeHashTables	server.c	/^void tryResizeHashTables(int dbid) {$/;"	f
tt	config.c	/^        time_t *tt;$/;"	m	union:numericConfigData::__anon14	file:
ttlCommand	expire.c	/^void ttlCommand(client *c) {$/;"	f
ttlGenericCommand	expire.c	/^void ttlGenericCommand(client *c, int output_ms) {$/;"	f
type	cluster.h	/^    uint16_t type;      \/* Message type *\/$/;"	m	struct:__anon12
type	cluster.h	/^    uint8_t type;           \/* Type from 0 to 255. *\/$/;"	m	struct:__anon6
type	connection.h	/^    ConnectionType *type;$/;"	m	struct:connection
type	dict.h	/^    dictType *type;$/;"	m	struct:dict
type	geohash.h	/^    int type; \/* search type *\/$/;"	m	struct:__anon24
type	module.c	/^            uint32_t type;         \/* REDISMODULE_ZSET_RANGE_* *\/$/;"	m	struct:RedisModuleKey::__anon28::__anon29	file:
type	module.c	/^    int type;       \/* REDISMODULE_REPLY_... *\/$/;"	m	struct:RedisModuleCallReply	file:
type	module.c	/^    int type;$/;"	m	struct:AutoMemEntry	file:
type	redis-cli.c	/^    int type;$/;"	m	struct:__anon35	file:
type	server.h	/^    int type;$/;"	m	struct:_redisSortOperation
type	server.h	/^    moduleType *type;   \/* Module type doing the operation. *\/$/;"	m	struct:RedisModuleIO
type	server.h	/^    moduleType *type;$/;"	m	struct:moduleValue
type	server.h	/^    unsigned type:4;$/;"	m	struct:redisObject
type	t_zset.c	/^    int type; \/* Set, sorted set *\/$/;"	m	struct:__anon61	file:
type	t_zset.c	/^    zrange_consumer_type                 type;$/;"	m	struct:zrange_result_handler	file:
typeCommand	db.c	/^void typeCommand(client *c) {$/;"	f
typeData	config.c	/^typedef union typeData {$/;"	u	file:
typeData	config.c	/^} typeData;$/;"	t	typeref:union:typeData	file:
typeInterface	config.c	/^typedef struct typeInterface {$/;"	s	file:
typeInterface	config.c	/^} typeInterface;$/;"	t	typeref:struct:typeInterface	file:
type_free	redis-cli.c	/^void type_free(void* priv_data, void* val) {$/;"	f
type_hash	redis-cli.c	/^typeinfo type_hash = { "hash", "HLEN", "fields" };$/;"	v
type_list	redis-cli.c	/^typeinfo type_list = { "list", "LLEN", "items" };$/;"	v
type_other	redis-cli.c	/^typeinfo type_other = { "other", NULL, "?" };$/;"	v
type_set	redis-cli.c	/^typeinfo type_set = { "set", "SCARD", "members" };$/;"	v
type_stream	redis-cli.c	/^typeinfo type_stream = { "stream", "XLEN", "entries" };$/;"	v
type_string	redis-cli.c	/^typeinfo type_string = { "string", "STRLEN", "bytes" };$/;"	v
type_zset	redis-cli.c	/^typeinfo type_zset = { "zset", "ZCARD", "members" };$/;"	v
typeinfo	redis-cli.c	/^} typeinfo;$/;"	t	typeref:struct:__anon36	file:
typeinfoDictType	redis-cli.c	/^static dictType typeinfoDictType = {$/;"	v	file:
typeinfo_add	redis-cli.c	/^static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {$/;"	f	file:
types	module.c	/^    list *types;    \/* Module data types. *\/$/;"	m	struct:RedisModule	file:
u	module.c	/^    } u;$/;"	m	struct:RedisModuleKey	typeref:union:RedisModuleKey::__anon28	file:
u	server.h	/^    } u;$/;"	m	struct:_redisSortObject	typeref:union:_redisSortObject::__anon49
u16	lzfP.h	/^    typedef unsigned int u16;$/;"	t
u16	lzfP.h	/^    typedef unsigned short u16;$/;"	t
u64	dict.h	/^        uint64_t u64;$/;"	m	union:dictEntry::__anon18
u8	lzfP.h	/^typedef unsigned char u8;$/;"	t
u_int	solarisfixes.h	50;"	d
u_int32_t	solarisfixes.h	51;"	d
ui	config.c	/^        unsigned int *ui;$/;"	m	union:numericConfigData::__anon14	file:
uintCompare	ziplist.c	/^int uintCompare(const void *a, const void *b) {$/;"	f
ul	config.c	/^        unsigned long *ul;$/;"	m	union:numericConfigData::__anon14	file:
ull	config.c	/^        unsigned long long *ull;$/;"	m	union:numericConfigData::__anon14	file:
umask	server.h	/^    mode_t umask;               \/* The umask value of the process on startup *\/$/;"	m	struct:redisServer
uname_M	Makefile	/^uname_M := $(shell sh -c 'uname -m 2>\/dev\/null || echo not')$/;"	m
uname_S	Makefile	/^uname_S := $(shell sh -c 'uname -s 2>\/dev\/null || echo not')$/;"	m
uname_S	modules/Makefile	/^uname_S := $(shell sh -c 'uname -s 2>\/dev\/null || echo not')$/;"	m
unblockClient	blocked.c	/^void unblockClient(client *c) {$/;"	f
unblockClientFromModule	module.c	/^void unblockClientFromModule(client *c) {$/;"	f
unblockClientWaitingData	blocked.c	/^void unblockClientWaitingData(client *c) {$/;"	f
unblockClientWaitingReplicas	replication.c	/^void unblockClientWaitingReplicas(client *c) {$/;"	f
unblocked	module.c	/^    int unblocked;          \/* Already on the moduleUnblocked list. *\/$/;"	m	struct:RedisModuleBlockedClient	file:
unblocked_clients	server.h	/^    list *unblocked_clients; \/* list of clients to unblock before next loop *\/$/;"	m	struct:redisServer
undoConnectWithMaster	replication.c	/^void undoConnectWithMaster(void) {$/;"	f
unixsocket	server.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	struct:redisServer
unixsocketperm	server.h	/^    mode_t unixsocketperm;      \/* UNIX socket permission *\/$/;"	m	struct:redisServer
unixtime	server.h	/^    redisAtomic time_t unixtime; \/* Unix time sampled every cron cycle. *\/$/;"	m	struct:redisServer
unlikely	config.h	108;"	d
unlikely	config.h	111;"	d
unlink	redismodule.h	/^    RedisModuleTypeUnlinkFunc unlink;$/;"	m	struct:RedisModuleTypeMethods
unlink	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	struct:sharedObjectsStruct
unlink	server.h	/^    moduleTypeUnlinkFunc unlink;$/;"	m	struct:RedisModuleType
unlinkClient	networking.c	/^void unlinkClient(client *c) {$/;"	f
unlinkCommand	db.c	/^void unlinkCommand(client *c) {$/;"	f
unpauseClients	networking.c	/^void unpauseClients(void) {$/;"	f
unprotectClient	networking.c	/^void unprotectClient(client *c) {$/;"	f
unquoteCString	redis-cli.c	/^static sds unquoteCString(char *str) {$/;"	f	file:
unreachable_masters	redis-cli.c	/^    int unreachable_masters;    \/* Masters we are not able to reach. *\/$/;"	m	struct:clusterManager	file:
unsafe_info_chars	server.c	/^static char unsafe_info_chars[] = "#:\\n\\r";$/;"	v	file:
unsafe_info_chars_substs	server.c	/^static char unsafe_info_chars_substs[] = "____";   \/* Must be same length as above *\/$/;"	v	file:
unsetBlockingTimeout	tls.c	/^static void unsetBlockingTimeout(tls_connection *conn) {$/;"	f	file:
unsubscribeCommand	pubsub.c	/^void unsubscribeCommand(client *c) {$/;"	f
unsubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	struct:sharedObjectsStruct
unwatchAllKeys	multi.c	/^void unwatchAllKeys(client *c) {$/;"	f
unwatchCommand	multi.c	/^void unwatchCommand(client *c) {$/;"	f
update	cluster.h	/^    } update;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon10
updateAppendonly	config.c	/^static int updateAppendonly(int val, int prev, const char **err) {$/;"	f	file:
updateCachedTime	server.c	/^void updateCachedTime(int update_daylight_info) {$/;"	f
updateChildInfo	childinfo.c	/^void updateChildInfo(childInfoType information_type, size_t cow, monotime cow_updated, size_t keys, double progress) {$/;"	f
updateClusterSlotsConfiguration	redis-benchmark.c	/^static void updateClusterSlotsConfiguration() {$/;"	f	file:
updateDictResizePolicy	server.c	/^void updateDictResizePolicy(void) {$/;"	f
updateFailoverStatus	replication.c	/^void updateFailoverStatus(void) {$/;"	f
updateGoodSlaves	config.c	/^static int updateGoodSlaves(long long val, long long prev, const char **err) {$/;"	f	file:
updateHZ	config.c	/^static int updateHZ(long long val, long long prev, const char **err) {$/;"	f	file:
updateJemallocBgThread	config.c	/^static int updateJemallocBgThread(int val, int prev, const char **err) {$/;"	f	file:
updateLFU	db.c	/^void updateLFU(robj *val) {$/;"	f
updateMaxclients	config.c	/^static int updateMaxclients(long long val, long long prev, const char **err) {$/;"	f	file:
updateMaxmemory	config.c	/^static int updateMaxmemory(long long val, long long prev, const char **err) {$/;"	f	file:
updateOOMScoreAdj	config.c	/^static int updateOOMScoreAdj(int val, int prev, const char **err) {$/;"	f	file:
updateOOMScoreAdjValues	config.c	/^static int updateOOMScoreAdjValues(sds *args, const char **err, int apply) {$/;"	f	file:
updatePort	config.c	/^static int updatePort(long long val, long long prev, const char **err) {$/;"	f	file:
updateProcTitleTemplate	config.c	/^static int updateProcTitleTemplate(char *val, char *prev, const char **err) {$/;"	f	file:
updateReplBacklogSize	config.c	/^static int updateReplBacklogSize(long long val, long long prev, const char **err) {$/;"	f	file:
updateRequirePass	config.c	/^int updateRequirePass(sds val, sds prev, const char **err) {$/;"	f
updateSSLEvent	tls.c	/^void updateSSLEvent(tls_connection *conn) {$/;"	f
updateSighandlerEnabled	config.c	/^static int updateSighandlerEnabled(int val, int prev, const char **err) {$/;"	f	file:
updateSlavesWaitingBgsave	replication.c	/^void updateSlavesWaitingBgsave(int bgsaveerr, int type) {$/;"	f
updateStatsOnUnblock	blocked.c	/^void updateStatsOnUnblock(client *c, long blocked_us, long reply_us){$/;"	f
updateTLSError	tls.c	/^static void updateTLSError(tls_connection *conn) {$/;"	f	file:
updateTLSPort	config.c	/^static int updateTLSPort(long long val, long long prev, const char **err) {$/;"	f	file:
updateTlsCfg	config.c	/^static int updateTlsCfg(char *val, char *prev, const char **err) {$/;"	f	file:
updateTlsCfgBool	config.c	/^static int updateTlsCfgBool(int val, int prev, const char **err) {$/;"	f	file:
updateTlsCfgInt	config.c	/^static int updateTlsCfgInt(long long val, long long prev, const char **err) {$/;"	f	file:
update_cksum	rio.h	/^    void (*update_cksum)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio
update_fn	config.c	/^    int (*update_fn)(char* val, char* prev, const char **err); \/* Optional function to apply new value at runtime (generic doc above) *\/$/;"	m	struct:stringConfigData	file:
update_fn	config.c	/^    int (*update_fn)(int val, int prev, const char **err); \/* Optional function to apply new value at runtime (generic doc above) *\/$/;"	m	struct:boolConfigData	file:
update_fn	config.c	/^    int (*update_fn)(int val, int prev, const char **err); \/* Optional function to apply new value at runtime (generic doc above) *\/$/;"	m	struct:enumConfigData	file:
update_fn	config.c	/^    int (*update_fn)(long long val, long long prev, const char **err); \/* Optional function to apply new value at runtime (generic doc above) *\/$/;"	m	struct:numericConfigData	file:
update_fn	config.c	/^    int (*update_fn)(sds val, sds prev, const char **err); \/* Optional function to apply new value at runtime (generic doc above) *\/$/;"	m	struct:sdsConfigData	file:
update_zmalloc_stat_alloc	zmalloc.c	83;"	d	file:
update_zmalloc_stat_free	zmalloc.c	84;"	d	file:
updated_slots	redis-benchmark.c	/^    int *updated_slots;         \/* Used by updateClusterSlotsConfiguration *\/$/;"	m	struct:clusterNode	file:
updated_slots_count	redis-benchmark.c	/^    int updated_slots_count;    \/* Used by updateClusterSlotsConfiguration *\/$/;"	m	struct:clusterNode	file:
upper_bound	config.c	/^    long long upper_bound; \/* The upper bound of this numeric value *\/$/;"	m	struct:numericConfigData	file:
usUntilEarliestTimer	ae.c	/^static int64_t usUntilEarliestTimer(aeEventLoop *eventLoop) {$/;"	f	file:
usage	redis-cli.c	/^static void usage(void) {$/;"	f	file:
usage	server.c	/^void usage(void) {$/;"	f
useDisklessLoad	replication.c	/^static int useDisklessLoad() {$/;"	f	file:
use_exit_on_panic	server.h	/^    int use_exit_on_panic;          \/* Use exit() on panic and assert rather than$/;"	m	struct:redisServer
usec	intset.c	/^static long long usec(void) {$/;"	f	file:
usec	ziplist.c	/^static long long usec(void) {$/;"	f	file:
used	aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:
used	dict.h	/^    unsigned long used;$/;"	m	struct:dictht
used	geo.h	/^    size_t used;$/;"	m	struct:geoArray
used	module.c	/^    uint32_t used;$/;"	m	struct:RedisModulePoolAllocBlock	file:
used	server.h	/^    size_t size, used;$/;"	m	struct:clientReplyBlock
used_memory	zmalloc.c	/^static redisAtomic size_t used_memory = 0;$/;"	v	file:
usedby	module.c	/^    list *usedby;   \/* List of modules using APIs from this one. *\/$/;"	m	struct:RedisModule	file:
user	module.c	/^    user *user; \/* Reference to the real redis user *\/$/;"	m	struct:RedisModuleUser	file:
user	redis-benchmark.c	/^    const char *user;$/;"	m	struct:config	file:
user	redis-cli.c	/^    char *user;$/;"	m	struct:config	file:
user	server.h	/^    user *user;             \/* User associated with this connection. If the$/;"	m	struct:client
user	server.h	/^} user;$/;"	t	typeref:struct:__anon45
user_data	module.c	/^    void* user_data;$/;"	m	struct:__anon32	file:
user_data	module.c	/^    void* user_data;$/;"	m	struct:__anon33	file:
userdata	t_zset.c	/^    void                                *userdata;$/;"	m	struct:zrange_result_handler	file:
username	acl.c	/^    sds username;       \/* User the client is authenticated with. *\/$/;"	m	struct:ACLLogEntry	file:
using	module.c	/^    list *using;    \/* List of modules we use some APIs of. *\/$/;"	m	struct:RedisModule	file:
ustime	quicklist.c	/^static long long ustime(void) {$/;"	f	file:
ustime	redis-benchmark.c	/^static long long ustime(void) {$/;"	f	file:
ustime	redis-cli.c	/^static long long ustime(void) {$/;"	f	file:
ustime	server.c	/^long long ustime(void) {$/;"	f
ustime	server.h	/^    ustime_t ustime;            \/* 'unixtime' in microseconds. *\/$/;"	m	struct:redisServer
ustime_t	server.h	/^typedef long long ustime_t; \/* microsecond time type. *\/$/;"	t
utilTest	util.c	/^int utilTest(int argc, char **argv, int accurate) {$/;"	f
v	dict.h	/^    } v;$/;"	m	struct:dictEntry	typeref:union:dictEntry::__anon18
val	config.c	/^    const int val;$/;"	m	struct:configEnum	file:
val	dict.h	/^        void *val;$/;"	m	union:dictEntry::__anon18
val	module.c	/^    } val;$/;"	m	struct:RedisModuleCallReply	typeref:union:RedisModuleCallReply::__anon31	file:
valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType
valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType
validateClusterManagerCommand	redis-cli.c	/^static clusterManagerCommandProc *validateClusterManagerCommand(void) {$/;"	f	file:
validateProcTitleTemplate	server.c	/^int validateProcTitleTemplate(const char *template) {$/;"	f
value	adlist.h	/^    void *value;$/;"	m	struct:listNode
value	module.c	/^    robj *value;    \/* Value object, or NULL if the key was not found. *\/$/;"	m	struct:RedisModuleKey	file:
value	modules/hellotype.c	/^    int64_t value;$/;"	m	struct:HelloTypeNode	file:
value	quicklist.h	/^    unsigned char *value;$/;"	m	struct:quicklistEntry
value	server.h	/^    void *value;$/;"	m	struct:moduleValue
value	sparkline.h	/^    double value;$/;"	m	struct:sample
value_buf	stream.h	/^    unsigned char value_buf[LP_INTBUF_SIZE];$/;"	m	struct:streamIterator
vecswap	pqsort.c	86;"	d	file:
vectors_sip64	siphash.c	/^const uint8_t vectors_sip64[64][8] = {$/;"	v
ver	cluster.h	/^    uint16_t ver;       \/* Protocol version, currently set to 1. *\/$/;"	m	struct:__anon12
ver	module.c	/^    int ver;        \/* Module version. We use just progressive integers. *\/$/;"	m	struct:RedisModule	file:
ver	server.h	/^    int ver;            \/* Module serialization version: 1 (old),$/;"	m	struct:RedisModuleIO
verbose	redis-cli.c	/^    int verbose;$/;"	m	struct:config	file:
verbosity	server.h	/^    int verbosity;                  \/* Loglevel in redis.conf *\/$/;"	m	struct:redisServer
verify	ziplist.c	/^static void verify(unsigned char *zl, zlentry *e) {$/;"	f	file:
verifyClusterConfigWithData	cluster.c	/^int verifyClusterConfigWithData(void) {$/;"	f
verifyDumpPayload	cluster.c	/^int verifyDumpPayload(unsigned char *p, size_t len) {$/;"	f
version	redismodule.h	/^    uint64_t version;       \/* Not used since this structure is never passed$/;"	m	struct:RedisModuleCronLoopInfo
version	redismodule.h	/^    uint64_t version;       \/* Not used since this structure is never passed$/;"	m	struct:RedisModuleFlushInfo
version	redismodule.h	/^    uint64_t version;       \/* Not used since this structure is never passed$/;"	m	struct:RedisModuleLoadingProgressInfo
version	redismodule.h	/^    uint64_t version;       \/* Not used since this structure is never passed$/;"	m	struct:RedisModuleModuleChange
version	redismodule.h	/^    uint64_t version;       \/* Not used since this structure is never passed$/;"	m	struct:RedisModuleReplicationInfo
version	redismodule.h	/^    uint64_t version;       \/* Not used since this structure is never passed$/;"	m	struct:RedisModuleSwapDbInfo
version	redismodule.h	/^    uint64_t version;       \/* Version of this structure for ABI compat. *\/$/;"	m	struct:RedisModuleClientInfo
version	redismodule.h	/^    uint64_t version;$/;"	m	struct:RedisModuleTypeMethods
version	server.c	/^void version(void) {$/;"	f
voted_time	cluster.h	/^    mstime_t voted_time;     \/* Last time we voted for a slave of this master *\/$/;"	m	struct:clusterNode
votes	sentinel.c	/^    unsigned long votes;$/;"	m	struct:sentinelLeader	file:
vptr	server.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon53
waitCommand	replication.c	/^void waitCommand(client *c) {$/;"	f
watchCommand	multi.c	/^void watchCommand(client *c) {$/;"	f
watchForKey	multi.c	/^void watchForKey(client *c, robj *key) {$/;"	f
watchdogScheduleSignal	debug.c	/^void watchdogScheduleSignal(int period) {$/;"	f
watchdogSignalHandler	debug.c	/^void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {$/;"	f
watchdog_period	server.h	/^    int watchdog_period;  \/* Software watchdog period in ms. 0 = off *\/$/;"	m	struct:redisServer
watchedKey	multi.c	/^typedef struct watchedKey {$/;"	s	file:
watchedKey	multi.c	/^} watchedKey;$/;"	t	typeref:struct:watchedKey	file:
watched_keys	server.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	struct:redisDb
watched_keys	server.h	/^    list *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	struct:client
weight	redis-cli.c	/^    char **weight;$/;"	m	struct:clusterManagerCommand	file:
weight	redis-cli.c	/^    float weight;   \/* Weight used by rebalance *\/$/;"	m	struct:clusterManagerNode	file:
weight	t_zset.c	/^    double weight;$/;"	m	struct:__anon61	file:
weight_argc	redis-cli.c	/^    int weight_argc;$/;"	m	struct:clusterManagerCommand	file:
west	geohash.h	/^    GeoHashBits west;$/;"	m	struct:__anon23
wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when	ae.h	/^    monotime when;$/;"	m	struct:aeTimeEvent
wherefrom	server.h	/^        int wherefrom;      \/* Where to pop from *\/$/;"	m	struct:blockingState::listPos
whereto	server.h	/^        int whereto;        \/* Where to push to *\/$/;"	m	struct:blockingState::listPos
whileBlockedCron	server.c	/^void whileBlockedCron() {$/;"	f
width	geohash.h	/^            double width;$/;"	m	struct:__anon24::__anon25::__anon26
width	lolwut.h	/^    int width;$/;"	m	struct:lwCanvas
width	lolwut6.c	/^    int width;      \/* Pixels width. *\/$/;"	m	struct:skyscraper	file:
windows	lolwut6.c	/^    int windows;    \/* Draw windows if true. *\/$/;"	m	struct:skyscraper	file:
withscores	t_zset.c	/^    int                                  withscores;$/;"	m	struct:zrange_result_handler	file:
woff	server.h	/^    long long woff;         \/* Last write global replication offset. *\/$/;"	m	struct:client
write	connection.h	/^    int (*write)(struct connection *conn, const void *data, size_t data_len);$/;"	m	struct:ConnectionType
write	rio.h	/^    size_t (*write)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio
writeCommandsDeniedByDiskError	server.c	/^int writeCommandsDeniedByDiskError(void) {$/;"	f
writeHandler	redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
writeToClient	networking.c	/^int writeToClient(client *c, int handler_installed) {$/;"	f
write_handler	connection.h	/^    ConnectionCallbackFunc write_handler;$/;"	m	struct:connection
writing	sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:
written	redis-benchmark.c	/^    size_t written;         \/* Bytes of 'obuf' already written *\/$/;"	m	struct:_client	file:
wrongtypeerr	server.h	/^    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
ws	memtest.c	/^static struct winsize ws;$/;"	v	typeref:struct:winsize	file:
x	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
x	server.h	/^    unsigned char x[20];    \/* Xored elements. *\/$/;"	m	struct:RedisModuleDigest
xackCommand	t_stream.c	/^void xackCommand(client *c) {$/;"	f
xaddCommand	t_stream.c	/^void xaddCommand(client *c) {$/;"	f
xautoclaimCommand	t_stream.c	/^void xautoclaimCommand(client *c) {$/;"	f
xclaim	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
xclaimCommand	server.h	/^                        *expireCommand, *pexpireCommand, *xclaimCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
xclaimCommand	t_stream.c	/^void xclaimCommand(client *c) {$/;"	f
xdelCommand	t_stream.c	/^void xdelCommand(client *c) {$/;"	f
xgroup	server.h	/^    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  $/;"	m	struct:sharedObjectsStruct
xgroupCommand	server.h	/^                        *xgroupCommand, *rpoplpushCommand, *lmoveCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
xgroupCommand	t_stream.c	/^void xgroupCommand(client *c) {$/;"	f
xinfoCommand	t_stream.c	/^void xinfoCommand(client *c) {$/;"	f
xinfoReplyWithStreamInfo	t_stream.c	/^void xinfoReplyWithStreamInfo(client *c, stream *s) {$/;"	f
xlenCommand	t_stream.c	/^void xlenCommand(client *c) {$/;"	f
xoff	lolwut6.c	/^    int xoff;       \/* X offset. *\/$/;"	m	struct:skyscraper	file:
xorDigest	debug.c	/^void xorDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f
xorObjectDigest	debug.c	/^void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {$/;"	f
xorStringObjectDigest	debug.c	/^void xorStringObjectDigest(unsigned char *digest, robj *o) {$/;"	f
xorshift64star_next	memtest.c	131;"	d	file:
xpendingCommand	t_stream.c	/^void xpendingCommand(client *c) {$/;"	f
xrangeCommand	t_stream.c	/^void xrangeCommand(client *c) {$/;"	f
xrangeGenericCommand	t_stream.c	/^void xrangeGenericCommand(client *c, int rev) {$/;"	f
xreadCommand	t_stream.c	/^void xreadCommand(client *c) {$/;"	f
xreadGetKeys	db.c	/^int xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
xread_consumer	server.h	/^    robj *xread_consumer;   \/* XREADGROUP consumer name. *\/$/;"	m	struct:blockingState
xread_count	server.h	/^    size_t xread_count;     \/* XREAD COUNT option. *\/$/;"	m	struct:blockingState
xread_group	server.h	/^    robj *xread_group;      \/* XREADGROUP group name. *\/$/;"	m	struct:blockingState
xread_group_noack	server.h	/^    int xread_group_noack;$/;"	m	struct:blockingState
xrevrangeCommand	t_stream.c	/^void xrevrangeCommand(client *c) {$/;"	f
xsetidCommand	t_stream.c	/^void xsetidCommand(client *c) {$/;"	f
xtrimCommand	t_stream.c	/^void xtrimCommand(client *c) {$/;"	f
xy	geohash.h	/^    double xy[2]; \/* search center point, xy[0]: lon, xy[1]: lat *\/$/;"	m	struct:__anon24
yell	quicklist.c	1521;"	d	file:
yesno	config.c	/^    boolConfigData yesno;$/;"	m	union:typeData	file:
yesnotoi	config.c	/^int yesnotoi(char *s) {$/;"	f
zaddCommand	t_zset.c	/^void zaddCommand(client *c) {$/;"	f
zaddGenericCommand	t_zset.c	/^void zaddGenericCommand(client *c, int flags) {$/;"	f
zarndmemberReplyWithZiplist	t_zset.c	/^static void zarndmemberReplyWithZiplist(client *c, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {$/;"	f	file:
zcalloc	zmalloc.c	/^void *zcalloc(size_t size) {$/;"	f
zcalloc_usable	zmalloc.c	/^void *zcalloc_usable(size_t size, size_t *usable) {$/;"	f
zcardCommand	t_zset.c	/^void zcardCommand(client *c) {$/;"	f
zcountCommand	t_zset.c	/^void zcountCommand(client *c) {$/;"	f
zdiff	t_zset.c	/^static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {$/;"	f	file:
zdiffAlgorithm1	t_zset.c	/^static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {$/;"	f	file:
zdiffAlgorithm2	t_zset.c	/^static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {$/;"	f	file:
zdiffCommand	t_zset.c	/^void zdiffCommand(client *c) {$/;"	f
zdiffstoreCommand	t_zset.c	/^void zdiffstoreCommand(client *c) {$/;"	f
zfree	zmalloc.c	/^void zfree(void *ptr) {$/;"	f
zfree_no_tcache	zmalloc.c	/^void zfree_no_tcache(void *ptr) {$/;"	f
zfree_usable	zmalloc.c	/^void zfree_usable(void *ptr, size_t *usable) {$/;"	f
zi	quicklist.h	/^    unsigned char *zi;$/;"	m	struct:quicklistEntry
zi	quicklist.h	/^    unsigned char *zi;$/;"	m	struct:quicklistIter
zincrbyCommand	t_zset.c	/^void zincrbyCommand(client *c) {$/;"	f
zinterCommand	t_zset.c	/^void zinterCommand(client *c) {$/;"	f
zinterstoreCommand	t_zset.c	/^void zinterstoreCommand(client *c) {$/;"	f
zipAssertValidEntry	ziplist.c	/^static inline void zipAssertValidEntry(unsigned char* zl, size_t zlbytes, unsigned char *p) {$/;"	f	file:
zipEncodingLenSize	ziplist.c	/^static inline unsigned int zipEncodingLenSize(unsigned char encoding) {$/;"	f	file:
zipEntry	ziplist.c	/^static inline void zipEntry(unsigned char *p, zlentry *e) {$/;"	f	file:
zipEntrySafe	ziplist.c	/^static inline int zipEntrySafe(unsigned char* zl, size_t zlbytes, unsigned char *p, zlentry *e, int validate_prevlen) {$/;"	f	file:
zipIntSize	ziplist.c	/^static inline unsigned int zipIntSize(unsigned char encoding) {$/;"	f	file:
zipLoadInteger	ziplist.c	/^int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {$/;"	f
zipPrevLenByteDiff	ziplist.c	/^int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {$/;"	f
zipRawEntryLength	ziplist.c	/^static inline unsigned int zipRawEntryLength(unsigned char *p) {$/;"	f	file:
zipRawEntryLengthSafe	ziplist.c	/^static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {$/;"	f	file:
zipSaveInteger	ziplist.c	/^void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {$/;"	f
zipStoreEntryEncoding	ziplist.c	/^unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {$/;"	f
zipStorePrevEntryLength	ziplist.c	/^unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {$/;"	f
zipStorePrevEntryLengthLarge	ziplist.c	/^int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {$/;"	f
zipTryEncoding	ziplist.c	/^int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {$/;"	f
ziplistBlobLen	ziplist.c	/^size_t ziplistBlobLen(unsigned char *zl) {$/;"	f
ziplistCompare	ziplist.c	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {$/;"	f
ziplistDelete	ziplist.c	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {$/;"	f
ziplistDeleteRange	ziplist.c	/^unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {$/;"	f
ziplistEntry	ziplist.h	/^} ziplistEntry;$/;"	t	typeref:struct:__anon72
ziplistFind	ziplist.c	/^unsigned char *ziplistFind(unsigned char *zl, unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {$/;"	f
ziplistGet	ziplist.c	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {$/;"	f
ziplistGetObject	t_zset.c	/^sds ziplistGetObject(unsigned char *sptr) {$/;"	f
ziplistIndex	ziplist.c	/^unsigned char *ziplistIndex(unsigned char *zl, int index) {$/;"	f
ziplistInsert	ziplist.c	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f
ziplistLen	ziplist.c	/^unsigned int ziplistLen(unsigned char *zl) {$/;"	f
ziplistMerge	ziplist.c	/^unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {$/;"	f
ziplistNew	ziplist.c	/^unsigned char *ziplistNew(void) {$/;"	f
ziplistNext	ziplist.c	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {$/;"	f
ziplistPrev	ziplist.c	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {$/;"	f
ziplistPush	ziplist.c	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {$/;"	f
ziplistRandomPair	ziplist.c	/^void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val) {$/;"	f
ziplistRandomPairs	ziplist.c	/^void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {$/;"	f
ziplistRandomPairsUnique	ziplist.c	/^unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {$/;"	f
ziplistReplace	ziplist.c	/^unsigned char *ziplistReplace(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f
ziplistRepr	ziplist.c	/^void ziplistRepr(unsigned char *zl) {$/;"	f
ziplistResize	ziplist.c	/^unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {$/;"	f
ziplistSaveValue	ziplist.c	/^static inline void ziplistSaveValue(unsigned char *val, unsigned int len, long long lval, ziplistEntry *dest) {$/;"	f	file:
ziplistTest	ziplist.c	/^int ziplistTest(int argc, char **argv, int accurate) {$/;"	f
ziplistValidateEntryCB	ziplist.h	/^typedef int (*ziplistValidateEntryCB)(unsigned char* p, void* userdata);$/;"	t
ziplistValidateIntegrity	ziplist.c	/^int ziplistValidateIntegrity(unsigned char *zl, size_t size, int deep,$/;"	f
zipmapBlobLen	zipmap.c	/^size_t zipmapBlobLen(unsigned char *zm) {$/;"	f
zipmapDecodeLength	zipmap.c	/^static unsigned int zipmapDecodeLength(unsigned char *p) {$/;"	f	file:
zipmapDel	zipmap.c	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {$/;"	f
zipmapEncodeLength	zipmap.c	/^static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:
zipmapExists	zipmap.c	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {$/;"	f
zipmapGet	zipmap.c	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapGetEncodedLengthSize	zipmap.c	/^static unsigned int zipmapGetEncodedLengthSize(unsigned char *p) {$/;"	f	file:
zipmapLen	zipmap.c	/^unsigned int zipmapLen(unsigned char *zm) {$/;"	f
zipmapLookupRaw	zipmap.c	/^static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {$/;"	f	file:
zipmapNew	zipmap.c	/^unsigned char *zipmapNew(void) {$/;"	f
zipmapNext	zipmap.c	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapRawEntryLength	zipmap.c	/^static unsigned int zipmapRawEntryLength(unsigned char *p) {$/;"	f	file:
zipmapRawKeyLength	zipmap.c	/^static unsigned int zipmapRawKeyLength(unsigned char *p) {$/;"	f	file:
zipmapRawValueLength	zipmap.c	/^static unsigned int zipmapRawValueLength(unsigned char *p) {$/;"	f	file:
zipmapRepr	zipmap.c	/^static void zipmapRepr(unsigned char *p) {$/;"	f	file:
zipmapRequiredLength	zipmap.c	/^static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {$/;"	f	file:
zipmapResize	zipmap.c	/^static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {$/;"	f	file:
zipmapRewind	zipmap.c	/^unsigned char *zipmapRewind(unsigned char *zm) {$/;"	f
zipmapSet	zipmap.c	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {$/;"	f
zipmapTest	zipmap.c	/^int zipmapTest(int argc, char *argv[], int accurate) {$/;"	f
zipmapValidateIntegrity	zipmap.c	/^int zipmapValidateIntegrity(unsigned char *zm, size_t size, int deep) {$/;"	f
zl	quicklist.h	/^    unsigned char *zl;$/;"	m	struct:quicklistNode
zl	t_zset.c	/^                unsigned char *zl;$/;"	m	struct:__anon61::__anon62::_iterzset::__anon65	file:
zl	t_zset.c	/^            } zl;$/;"	m	union:__anon61::__anon62::_iterzset	typeref:struct:__anon61::__anon62::_iterzset::__anon65	file:
zlentry	ziplist.c	/^typedef struct zlentry {$/;"	s	file:
zlentry	ziplist.c	/^} zlentry;$/;"	t	typeref:struct:zlentry	file:
zlexcountCommand	t_zset.c	/^void zlexcountCommand(client *c) {$/;"	f
zlexrangespec	server.h	/^} zlexrangespec;$/;"	t	typeref:struct:__anon55
zlibc_free	zmalloc.c	/^void zlibc_free(void *ptr) {$/;"	f
zmalloc	zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f
zmalloc_default_oom	zmalloc.c	/^static void zmalloc_default_oom(size_t size) {$/;"	f	file:
zmalloc_get_allocator_info	zmalloc.c	/^int zmalloc_get_allocator_info(size_t *allocated,$/;"	f
zmalloc_get_memory_size	zmalloc.c	/^size_t zmalloc_get_memory_size(void) {$/;"	f
zmalloc_get_private_dirty	zmalloc.c	/^size_t zmalloc_get_private_dirty(long pid) {$/;"	f
zmalloc_get_rss	zmalloc.c	/^size_t zmalloc_get_rss(void) {$/;"	f
zmalloc_get_smap_bytes_by_field	zmalloc.c	/^size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {$/;"	f
zmalloc_no_tcache	zmalloc.c	/^void *zmalloc_no_tcache(size_t size) {$/;"	f
zmalloc_oom_handler	zmalloc.c	/^static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;$/;"	v	file:
zmalloc_set_oom_handler	zmalloc.c	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {$/;"	f
zmalloc_size	zmalloc.c	/^size_t zmalloc_size(void *ptr) {$/;"	f
zmalloc_size	zmalloc.h	43;"	d
zmalloc_size	zmalloc.h	53;"	d
zmalloc_size	zmalloc.h	61;"	d
zmalloc_size	zmalloc.h	87;"	d
zmalloc_test	zmalloc.c	/^int zmalloc_test(int argc, char **argv, int accurate) {$/;"	f
zmalloc_usable	zmalloc.c	/^void *zmalloc_usable(size_t size, size_t *usable) {$/;"	f
zmalloc_usable_size	zmalloc.c	/^size_t zmalloc_usable_size(void *ptr) {$/;"	f
zmalloc_usable_size	zmalloc.h	134;"	d
zmalloc_used	server.h	/^    size_t zmalloc_used;$/;"	m	struct:malloc_stats
zmalloc_used_memory	zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f
zmscoreCommand	t_zset.c	/^void zmscoreCommand(client *c) {$/;"	f
zpopmax	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
zpopmaxCommand	server.h	/^                        *zpopmaxCommand, *sremCommand, *execCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
zpopmaxCommand	t_zset.c	/^void zpopmaxCommand(client *c) {$/;"	f
zpopmin	server.h	/^    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,$/;"	m	struct:sharedObjectsStruct
zpopminCommand	server.h	/^                        *lpopCommand, *rpopCommand, *zpopminCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::
zpopminCommand	t_zset.c	/^void zpopminCommand(client *c) {$/;"	f
zrandmemberCommand	t_zset.c	/^void zrandmemberCommand(client *c) {$/;"	f
zrandmemberWithCountCommand	t_zset.c	/^void zrandmemberWithCountCommand(client *c, long l, int withscores) {$/;"	f
zrangeCommand	t_zset.c	/^void zrangeCommand(client *c) {$/;"	f
zrangeGenericCommand	t_zset.c	/^void zrangeGenericCommand(zrange_result_handler *handler, int argc_start, int store,$/;"	f
zrangeResultBeginClient	t_zset.c	/^static void zrangeResultBeginClient(zrange_result_handler *handler) {$/;"	f	file:
zrangeResultBeginFunction	t_zset.c	/^typedef void (*zrangeResultBeginFunction)(zrange_result_handler *c);$/;"	t	file:
zrangeResultBeginStore	t_zset.c	/^static void zrangeResultBeginStore(zrange_result_handler *handler)$/;"	f	file:
zrangeResultEmitCBufferForStore	t_zset.c	/^static void zrangeResultEmitCBufferForStore(zrange_result_handler *handler,$/;"	f	file:
zrangeResultEmitCBufferFunction	t_zset.c	/^typedef void (*zrangeResultEmitCBufferFunction)($/;"	t	file:
zrangeResultEmitCBufferToClient	t_zset.c	/^static void zrangeResultEmitCBufferToClient(zrange_result_handler *handler,$/;"	f	file:
zrangeResultEmitLongLongForStore	t_zset.c	/^static void zrangeResultEmitLongLongForStore(zrange_result_handler *handler,$/;"	f	file:
zrangeResultEmitLongLongFunction	t_zset.c	/^typedef void (*zrangeResultEmitLongLongFunction)($/;"	t	file:
zrangeResultEmitLongLongToClient	t_zset.c	/^static void zrangeResultEmitLongLongToClient(zrange_result_handler *handler,$/;"	f	file:
zrangeResultFinalizeClient	t_zset.c	/^static void zrangeResultFinalizeClient(zrange_result_handler *handler,$/;"	f	file:
zrangeResultFinalizeFunction	t_zset.c	/^typedef void (*zrangeResultFinalizeFunction)($/;"	t	file:
zrangeResultFinalizeStore	t_zset.c	/^static void zrangeResultFinalizeStore(zrange_result_handler *handler, size_t result_count)$/;"	f	file:
zrangeResultHandlerDestinationKeySet	t_zset.c	/^static void zrangeResultHandlerDestinationKeySet (zrange_result_handler *handler,$/;"	f	file:
zrangeResultHandlerInit	t_zset.c	/^static void zrangeResultHandlerInit(zrange_result_handler *handler,$/;"	f	file:
zrangeResultHandlerScoreEmissionEnable	t_zset.c	/^static void zrangeResultHandlerScoreEmissionEnable(zrange_result_handler *handler) {$/;"	f	file:
zrange_consumer_type	t_zset.c	/^} zrange_consumer_type;$/;"	t	typeref:enum:__anon69	file:
zrange_direction	t_zset.c	/^} zrange_direction;$/;"	t	typeref:enum:__anon68	file:
zrange_result_handler	t_zset.c	/^struct zrange_result_handler {$/;"	s	file:
zrange_result_handler	t_zset.c	/^typedef struct zrange_result_handler zrange_result_handler;$/;"	t	typeref:struct:zrange_result_handler	file:
zrange_type	t_zset.c	/^} zrange_type;$/;"	t	typeref:enum:__anon60	file:
zrangebylexCommand	t_zset.c	/^void zrangebylexCommand(client *c) {$/;"	f
zrangebyscoreCommand	t_zset.c	/^void zrangebyscoreCommand(client *c) {$/;"	f
zrangespec	server.h	/^} zrangespec;$/;"	t	typeref:struct:__anon54
zrangestoreCommand	t_zset.c	/^void zrangestoreCommand (client *c) {$/;"	f
zrankCommand	t_zset.c	/^void zrankCommand(client *c) {$/;"	f
zrankGenericCommand	t_zset.c	/^void zrankGenericCommand(client *c, int reverse) {$/;"	f
zrealloc	zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f
zrealloc_usable	zmalloc.c	/^void *zrealloc_usable(void *ptr, size_t size, size_t *usable) {$/;"	f
zremCommand	t_zset.c	/^void zremCommand(client *c) {$/;"	f
zremrangeGenericCommand	t_zset.c	/^void zremrangeGenericCommand(client *c, zrange_type rangetype) {$/;"	f
zremrangebylexCommand	t_zset.c	/^void zremrangebylexCommand(client *c) {$/;"	f
zremrangebyrankCommand	t_zset.c	/^void zremrangebyrankCommand(client *c) {$/;"	f
zremrangebyscoreCommand	t_zset.c	/^void zremrangebyscoreCommand(client *c) {$/;"	f
zrevrangeCommand	t_zset.c	/^void zrevrangeCommand(client *c) {$/;"	f
zrevrangebylexCommand	t_zset.c	/^void zrevrangebylexCommand(client *c) {$/;"	f
zrevrangebyscoreCommand	t_zset.c	/^void zrevrangebyscoreCommand(client *c) {$/;"	f
zrevrankCommand	t_zset.c	/^void zrevrankCommand(client *c) {$/;"	f
zs	defrag.c	/^    zset *zs;$/;"	m	struct:__anon16	file:
zs	t_zset.c	/^                zset *zs;$/;"	m	struct:__anon61::__anon62::_iterzset::__anon66	file:
zscanCommand	t_zset.c	/^void zscanCommand(client *c) {$/;"	f
zscoreCommand	t_zset.c	/^void zscoreCommand(client *c) {$/;"	f
zset	module.c	/^        } zset;$/;"	m	union:RedisModuleKey::__anon28	typeref:struct:RedisModuleKey::__anon28::__anon29	file:
zset	server.h	/^typedef struct zset {$/;"	s
zset	server.h	/^} zset;$/;"	t	typeref:struct:zset
zset	t_zset.c	/^        } zset;$/;"	m	union:__anon61::__anon62	typeref:union:__anon61::__anon62::_iterzset	file:
zsetAdd	t_zset.c	/^int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {$/;"	f
zsetChooseDiffAlgorithm	t_zset.c	/^static int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {$/;"	f	file:
zsetConvert	t_zset.c	/^void zsetConvert(robj *zobj, int encoding) {$/;"	f
zsetConvertToZiplistIfNeeded	t_zset.c	/^void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {$/;"	f
zsetDel	t_zset.c	/^int zsetDel(robj *zobj, sds ele) {$/;"	f
zsetDictGetMaxElementLength	t_zset.c	/^static int zsetDictGetMaxElementLength(dict *d) {$/;"	f	file:
zsetDictType	server.c	/^dictType zsetDictType = {$/;"	v
zsetDup	t_zset.c	/^robj *zsetDup(robj *o) {$/;"	f
zsetInitLexRange	module.c	/^int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {$/;"	f
zsetInitScoreRange	module.c	/^int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {$/;"	f
zsetKeyReset	module.c	/^void zsetKeyReset(RedisModuleKey *key) {$/;"	f
zsetLength	t_zset.c	/^unsigned long zsetLength(const robj *zobj) {$/;"	f
zsetRank	t_zset.c	/^long zsetRank(robj *zobj, sds ele, int reverse) {$/;"	f
zsetRemoveFromSkiplist	t_zset.c	/^static int zsetRemoveFromSkiplist(zset *zs, sds ele) {$/;"	f	file:
zsetReplyFromZiplistEntry	t_zset.c	/^void zsetReplyFromZiplistEntry(client *c, ziplistEntry *e) {$/;"	f
zsetScore	t_zset.c	/^int zsetScore(robj *zobj, sds member, double *score) {$/;"	f
zsetSdsFromZiplistEntry	t_zset.c	/^sds zsetSdsFromZiplistEntry(ziplistEntry *e) {$/;"	f
zsetTypeRandomElement	t_zset.c	/^void zsetTypeRandomElement(robj *zsetobj, unsigned long zsetsize, ziplistEntry *key, double *score) {$/;"	f
zsetZiplistValidateIntegrity	t_zset.c	/^int zsetZiplistValidateIntegrity(unsigned char *zl, size_t size, int deep) {$/;"	f
zset_max_ziplist_entries	server.h	/^    size_t zset_max_ziplist_entries;$/;"	m	struct:redisServer
zset_max_ziplist_value	server.h	/^    size_t zset_max_ziplist_value;$/;"	m	struct:redisServer
zsetopsrc	t_zset.c	/^} zsetopsrc;$/;"	t	typeref:struct:__anon61	file:
zsetopval	t_zset.c	/^} zsetopval;$/;"	t	typeref:struct:__anon67	file:
zskiplist	server.h	/^typedef struct zskiplist {$/;"	s
zskiplist	server.h	/^} zskiplist;$/;"	t	typeref:struct:zskiplist
zskiplistLevel	server.h	/^    struct zskiplistLevel {$/;"	s	struct:zskiplistNode
zskiplistNode	server.h	/^typedef struct zskiplistNode {$/;"	s
zskiplistNode	server.h	/^} zskiplistNode;$/;"	t	typeref:struct:zskiplistNode
zsl	server.h	/^    zskiplist *zsl;$/;"	m	struct:zset
zslCreate	t_zset.c	/^zskiplist *zslCreate(void) {$/;"	f
zslCreateNode	t_zset.c	/^zskiplistNode *zslCreateNode(int level, double score, sds ele) {$/;"	f
zslDefrag	defrag.c	/^double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {$/;"	f
zslDelete	t_zset.c	/^int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {$/;"	f
zslDeleteNode	t_zset.c	/^void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {$/;"	f
zslDeleteRangeByLex	t_zset.c	/^unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {$/;"	f
zslDeleteRangeByRank	t_zset.c	/^unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {$/;"	f
zslDeleteRangeByScore	t_zset.c	/^unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {$/;"	f
zslFirstInLexRange	t_zset.c	/^zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f
zslFirstInRange	t_zset.c	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslFree	t_zset.c	/^void zslFree(zskiplist *zsl) {$/;"	f
zslFreeLexRange	t_zset.c	/^void zslFreeLexRange(zlexrangespec *spec) {$/;"	f
zslFreeNode	t_zset.c	/^void zslFreeNode(zskiplistNode *node) {$/;"	f
zslGetElementByRank	t_zset.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {$/;"	f
zslGetRank	t_zset.c	/^unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {$/;"	f
zslInsert	t_zset.c	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {$/;"	f
zslIsInLexRange	t_zset.c	/^int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f
zslIsInRange	t_zset.c	/^int zslIsInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslLastInLexRange	t_zset.c	/^zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f
zslLastInRange	t_zset.c	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslLexValueGteMin	t_zset.c	/^int zslLexValueGteMin(sds value, zlexrangespec *spec) {$/;"	f
zslLexValueLteMax	t_zset.c	/^int zslLexValueLteMax(sds value, zlexrangespec *spec) {$/;"	f
zslParseLexRange	t_zset.c	/^int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {$/;"	f
zslParseLexRangeItem	t_zset.c	/^int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {$/;"	f
zslParseRange	t_zset.c	/^static int zslParseRange(robj *min, robj *max, zrangespec *spec) {$/;"	f	file:
zslRandomLevel	t_zset.c	/^int zslRandomLevel(void) {$/;"	f
zslUpdateNode	defrag.c	/^void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnode, zskiplistNode **update) {$/;"	f
zslUpdateScore	t_zset.c	/^zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {$/;"	f
zslValueGteMin	t_zset.c	/^int zslValueGteMin(double value, zrangespec *spec) {$/;"	f
zslValueLteMax	t_zset.c	/^int zslValueLteMax(double value, zrangespec *spec) {$/;"	f
zstrdup	zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f
ztrycalloc	zmalloc.c	/^void *ztrycalloc(size_t size) {$/;"	f
ztrycalloc_usable	zmalloc.c	/^void *ztrycalloc_usable(size_t size, size_t *usable) {$/;"	f
ztrymalloc	zmalloc.c	/^void *ztrymalloc(size_t size) {$/;"	f
ztrymalloc_usable	zmalloc.c	/^void *ztrymalloc_usable(size_t size, size_t *usable) {$/;"	f
ztryrealloc	zmalloc.c	/^void *ztryrealloc(void *ptr, size_t size) {$/;"	f
ztryrealloc_usable	zmalloc.c	/^void *ztryrealloc_usable(void *ptr, size_t size, size_t *usable) {$/;"	f
zuiBufferFromValue	t_zset.c	/^int zuiBufferFromValue(zsetopval *val) {$/;"	f
zuiClearIterator	t_zset.c	/^void zuiClearIterator(zsetopsrc *op) {$/;"	f
zuiCompareByCardinality	t_zset.c	/^int zuiCompareByCardinality(const void *s1, const void *s2) {$/;"	f
zuiCompareByRevCardinality	t_zset.c	/^static int zuiCompareByRevCardinality(const void *s1, const void *s2) {$/;"	f	file:
zuiFind	t_zset.c	/^int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {$/;"	f
zuiInitIterator	t_zset.c	/^void zuiInitIterator(zsetopsrc *op) {$/;"	f
zuiLength	t_zset.c	/^unsigned long zuiLength(zsetopsrc *op) {$/;"	f
zuiLongLongFromValue	t_zset.c	/^int zuiLongLongFromValue(zsetopval *val) {$/;"	f
zuiNewSdsFromValue	t_zset.c	/^sds zuiNewSdsFromValue(zsetopval *val) {$/;"	f
zuiNext	t_zset.c	/^int zuiNext(zsetopsrc *op, zsetopval *val) {$/;"	f
zuiSdsFromValue	t_zset.c	/^sds zuiSdsFromValue(zsetopval *val) {$/;"	f
zunionCommand	t_zset.c	/^void zunionCommand(client *c) {$/;"	f
zunionInterAggregate	t_zset.c	/^inline static void zunionInterAggregate(double *target, double val, int aggregate) {$/;"	f	file:
zunionInterDictValue	t_zset.c	2345;"	d	file:
zunionInterDiffGenericCommand	t_zset.c	/^void zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op) {$/;"	f
zunionInterDiffGetKeys	db.c	/^int zunionInterDiffGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
zunionInterDiffStoreGetKeys	db.c	/^int zunionInterDiffStoreGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {$/;"	f
zunionstoreCommand	t_zset.c	/^void zunionstoreCommand(client *c) {$/;"	f
zzlCompareElements	t_zset.c	/^int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {$/;"	f
zzlDelete	t_zset.c	/^unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {$/;"	f
zzlDeleteRangeByLex	t_zset.c	/^unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {$/;"	f
zzlDeleteRangeByRank	t_zset.c	/^unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {$/;"	f
zzlDeleteRangeByScore	t_zset.c	/^unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {$/;"	f
zzlFind	t_zset.c	/^unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {$/;"	f
zzlFirstInLexRange	t_zset.c	/^unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f
zzlFirstInRange	t_zset.c	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlGetScore	t_zset.c	/^double zzlGetScore(unsigned char *sptr) {$/;"	f
zzlInsert	t_zset.c	/^unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {$/;"	f
zzlInsertAt	t_zset.c	/^unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {$/;"	f
zzlIsInLexRange	t_zset.c	/^int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f
zzlIsInRange	t_zset.c	/^int zzlIsInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlLastInLexRange	t_zset.c	/^unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f
zzlLastInRange	t_zset.c	/^unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlLength	t_zset.c	/^unsigned int zzlLength(unsigned char *zl) {$/;"	f
zzlLexValueGteMin	t_zset.c	/^int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {$/;"	f
zzlLexValueLteMax	t_zset.c	/^int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {$/;"	f
zzlNext	t_zset.c	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f
zzlPrev	t_zset.c	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f
zzlStrtod	t_zset.c	/^double zzlStrtod(unsigned char *vstr, unsigned int vlen) {$/;"	f
