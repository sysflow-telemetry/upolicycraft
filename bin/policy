#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys

from stat import *
from queue import Queue

def call(argv):
    p = subprocess.run(argv, stdout=subprocess.PIPE)
    lines = list(filter(lambda s: s != "", p.stdout.decode("utf-8").split("\n")))

    return lines

class DockerTool(object):
    def __getattr__(self, called_method):
        program_name = called_method.replace("_", "-")
        return lambda *argv: call((program_name,) + argv)

def make_falco_rules(files):
    """
    Generate falco rules based on the static model obtained for an image.
    """
    pass

def main():
    parser = argparse.ArgumentParser(description='Compile a behavior model from a docker image.')
    parser.add_argument('image', help="The name of the docker image.")

    dt = DockerTool()
    args = parser.parse_args()

    # Fetch the Entrypoint
    output = dt.extract_entrypoint(args.image)

    print(output)

    # Find the ELF of the entrypoint
    elf = dt.find_elf(output[0])

    print(elf)

    # Find its library dependencies
    libs = set(dt.libs(elf[0]))

    reqlibs = set()
    reqfiles = set(dt.files(elf[0]))

    while (len(libs) > 0):
        lib = libs.pop()
        files = dt.find_file(lib)
        f = files[0]
        reqlibs.add(f)
        reqfiles = reqfiles.union(set(dt.files(f)))
        next = set(dt.libs(f))
        # print("Adding libs {}".format(next))
        libs = libs.union(next)

    print("Adding files to the queue")
    q = set(reqfiles)

    visited = set()

    model = set()

    print("Consuming the queue")
    while len(q) > 0:
        file = q.pop()

        print("Looking for file {}".format(file))
        print("{}/{}".format(len(q), len(visited)))

        if file in visited:
            continue

        location = dt.find_file(file)

        visited.add(file)

        if len(location) == 0:
            continue

        for l in location:
            lf = "/" + "/".join(l.split('/')[3:])
            visited.add(lf)
            q.add(lf)

            model.add(l)

            try:
                if os.readlink(l).startswith('/dev/'):
                    continue
            except OSError:
                print("Unexpected error:", sys.exc_info()[0])
            print("Looking for files referenced by {}".format(l))
            next = dt.files(l)
            q = q.union(set(next)).difference(visited)

    print("Required Libraries")
    print("==================")

    for l in sorted(reqlibs):
        print(l)

    print("  ")
    print("  ")

    print("Required Files")
    print("==============")

    for f in sorted(model):
        print(f)

if __name__ == "__main__":
    main()
