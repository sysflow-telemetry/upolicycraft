#!/usr/bin/env ocaml

(**
  This is meant as a utility for inspecting docker images.
*)

#use "topfind"

(**
 #warnings "+a"
*)

#thread

#require "core"
#require "core_kernel"
#require "ppx_let"
#require "shexp.process"
#require "yojson"

module List' = Core_kernel.List

open Core

open Printf
open Shexp_process
open Shexp_process.Infix

module Yo = Yojson
module Util = Yojson.Basic.Util

let usage =
  printf "Usage uIDS image pathname"

let optional_parameter opt =
  match opt with
    None -> raise (Invalid_argument "required parameter not provided.")
  | Some s -> s

let unpack image =
  let imagedir = sprintf "images/%s" image in
  let tarname = sprintf "images/%s.tar" image in
  run "mkdir" ["-p"; imagedir] >>
  run "tar"   ["-xf"; tarname; "-C"; imagedir]

let layers image =
  let manifestfile = sprintf "./images/%s/manifest.json" image in
  run "cat" [manifestfile] |- run "jq" [".[0].Layers"]

let mount_layers image =
  layers image
  |- read_all >>= fun layers ->
  (Yo.Basic.from_string layers)
  |> Util.to_list
  |> List'.map ~f:(fun f -> f |> Util.to_string)
  |> List'.fold_left ~init:(return(), 0) ~f:(fun (cont, i) layer ->
      let layername = layer |> String.split ~on:'/' |> List'.hd_exn in
      let layerarchive = sprintf "./images/%s/%s/layer.tar" image layername in
      let layerdir = sprintf "./images/%s/%d/" image i in
      let unpack = run "mkdir" ["-p"; layerdir] >>
        run "tar" ["--skip-old-files"; "-xf"; layerarchive; "-C"; layerdir] in
      (unpack >> cont, (succ i)))
  |> fst

let config image =
  let manifestfile = sprintf "./images/%s/manifest.json" image in
  run "cat" [manifestfile] |- run "jq" [".[0].Config"]

let entrypoint image =
  config image |- read_all >>= fun config ->
  let trimmed = String.strip ~drop:(fun c -> c = '"' || c = '\n') config in
  let filename = sprintf "images/%s/%s" image trimmed in
  run "cat" [filename] |- run "jq" [".config.Entrypoint[0]"]

let path image opt =
  let entrypoint = optional_parameter opt in
  let errormsg = echo "File does not exist" in
  layers image |- read_all >>= fun layers ->
  (Yo.Basic.from_string layers)
  |> Util.to_list
  |> List'.map ~f:(fun f -> f |> Util.to_string)
  |> List'.fold_left ~init:(errormsg, 0) ~f:(fun (path, i) _ ->
      try
        let absolutepath = sprintf "./images/%s/%d/%s" image i entrypoint in
        let _ = eval (stat absolutepath) in
        (echo absolutepath, (succ i))
      with Unix.Unix_error (_, _, _) ->
        (path, (succ i)))
  |> fst

let binary opt =
  let path = optional_parameter opt in
  printf "path: %s" path

let handle_command op image filepath =
  match op with
    "config" -> config image
  | "entrypoint" -> entrypoint image
  | "mount-layers" -> mount_layers image
  | "path" -> path image filepath
  | "unpack" -> unpack image
  | "binary" -> binary filepath
  | _ -> (usage)

let main =
  let open Command.Let_syntax in
  let command =
    Command.basic ~summary:"uIDS Static Behavior Analysis"
      [%map_open
        let op = anon ("operation" %: string)
        and image = flag "image" (required string) ~doc:"The image to inspect"
        and path = flag "path" (optional string) ~doc:"A path within the image relevant to the operation" in
       fun () ->
          try
            (eval (handle_command op image path))
          with e ->
            let msg = Exn.to_string e in
            Printf.eprintf "error: %s" msg
      ]
  in
  Command.run command

let () =
  (main)
